import {createRequire} from "node:module";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __require = createRequire(import.meta.url);

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var Events = function() {
  };
  var EE = function(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  };
  var addListener = function(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  };
  var clearEvent = function(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  };
  var EventEmitter = function() {
    this._events = new Events;
    this._eventsCount = 0;
  };
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  var parse4 = function(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode2;
    var index = 0;
    while (index < str.length) {
      var eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str.slice(index, eqIdx).trim();
      if (obj[key] === undefined) {
        var val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    }
    return obj;
  };
  var serialize = function(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode2;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value11 = enc(val);
    if (value11 && !fieldContentRegExp.test(value11)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value11;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.partitioned) {
      str += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  };
  var decode2 = function(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  };
  var encode2 = function(val) {
    return encodeURIComponent(val);
  };
  var isDate = function(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  };
  var tryDecode = function(str, decode3) {
    try {
      return decode3(str);
    } catch (e) {
      return str;
    }
  };
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse4;
  exports.serialize = serialize;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var decodeURIComponent2 = function(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type74 = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type74];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type74];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  };
  var hexCodeToInt = function(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  };
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse = __commonJS((exports, module) => {
  var parse4 = function(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value11 = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value11 = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value11 = value11.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value11 = fastDecode(value11) || value11;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value11;
          } else {
            if (currentValue.pop) {
              currentValue.push(value11);
            } else {
              result[key] = [currentValue, value11];
            }
          }
        }
        value11 = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  };
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {
  };
  Empty.prototype = Object.create(null);
  module.exports = parse4;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var encodeString = function(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  };
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var getAsPrimitive = function(value11) {
    const type74 = typeof value11;
    if (type74 === "string") {
      return encodeString(value11);
    } else if (type74 === "bigint") {
      return value11.toString();
    } else if (type74 === "boolean") {
      return value11 ? "true" : "false";
    } else if (type74 === "number" && Number.isFinite(value11)) {
      return value11 < 1000000000000000000000 ? "" + value11 : encodeString("" + value11);
    }
    return "";
  };
  var stringify = function(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value11 = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value11)) {
        valueLength = value11.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value11[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value11);
      }
    }
    return result;
  };
  var { encodeString } = require_querystring();
  module.exports = stringify;
});

// node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var parse4 = require_parse();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse: parse4,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse4;
  module.exports.stringify = stringify;
});

// node_modules/@kitajs/html/index.js
var require_html = __commonJS((exports, module) => {
  var isUpper = function(input, index) {
    const code = input.charCodeAt(index);
    return code >= 65 && code <= 90;
  };
  var toKebabCase = function(camel) {
    if (!CAMEL_REGEX.test(camel)) {
      return camel;
    }
    const length = camel.length;
    let start = 0;
    let end = 0;
    let kebab = "";
    let prev = true;
    let curr = isUpper(camel, 0);
    let next;
    for (;end < length; end++) {
      next = isUpper(camel, end + 1);
      if (!prev && curr && !next) {
        kebab += camel.slice(start, end) + "-" + camel[end].toLowerCase();
        start = end + 1;
      }
      prev = curr;
      curr = next;
    }
    kebab += camel.slice(start, end);
    return kebab;
  };
  var escape = function(strings, ...values) {
    const stringsLength = strings.length;
    const valuesLength = values.length;
    let index = 0;
    let result = "";
    for (;index < stringsLength; index++) {
      result += strings[index];
      if (index < valuesLength) {
        result += values[index];
      }
    }
    return escapeHtml(result);
  };
  var isVoidElement = function(tag) {
    return tag === "meta" || tag === "link" || tag === "img" || tag === "br" || tag === "input" || tag === "hr" || tag === "area" || tag === "base" || tag === "col" || tag === "command" || tag === "embed" || tag === "keygen" || tag === "param" || tag === "source" || tag === "track" || tag === "wbr";
  };
  var styleToString = function(style) {
    if (typeof style === "string") {
      let end2 = style.indexOf('"');
      if (end2 === -1) {
        return style;
      }
      const length2 = style.length;
      let escaped = "";
      let start2 = 0;
      for (;end2 < length2; end2++) {
        if (style[end2] === '"') {
          escaped += style.slice(start2, end2) + "&#34;";
          start2 = end2 + 1;
        }
      }
      escaped += style.slice(start2, end2);
      return escaped;
    }
    const keys = Object.keys(style);
    const length = keys.length;
    let key, value15, end, start;
    let index = 0;
    let result = "";
    for (;index < length; index++) {
      key = keys[index];
      value15 = style[key];
      if (value15 === null || value15 === undefined) {
        continue;
      }
      result += toKebabCase(key) + ":";
      if (typeof value15 !== "string") {
        result += value15.toString() + ";";
        continue;
      }
      end = value15.indexOf('"');
      if (end === -1) {
        result += value15 + ";";
        continue;
      }
      const length2 = value15.length;
      start = 0;
      for (;end < length2; end++) {
        if (value15[end] === '"') {
          result += value15.slice(start, end) + "&#34;";
          start = end + 1;
        }
      }
      result += value15.slice(start, end) + ";";
    }
    return result;
  };
  var attributesToString = function(attributes) {
    const keys = Object.keys(attributes);
    const length = keys.length;
    let key, value15, type74, end, start, classItems, valueLength;
    let result = "";
    let index = 0;
    for (;index < length; index++) {
      key = keys[index];
      if (key === "children" || key === "safe") {
        continue;
      }
      value15 = attributes[key];
      if (key === "className") {
        if (attributes.class !== undefined) {
          continue;
        }
        key = "class";
      } else if (key === "class" && Array.isArray(value15)) {
        classItems = value15;
        valueLength = value15.length;
        value15 = "";
        for (let i = 0;i < valueLength; i++) {
          if (classItems[i] && classItems[i].length > 0) {
            if (value15) {
              value15 += " " + classItems[i].trim();
            } else {
              value15 += classItems[i].trim();
            }
          }
        }
        if (value15.length === 0) {
          continue;
        }
      } else if (key === "style") {
        result += ' style="' + styleToString(value15) + '"';
        continue;
      } else if (key === "attrs") {
        if (typeof value15 === "string") {
          result += " " + value15;
        } else {
          result += attributesToString(value15);
        }
        continue;
      }
      type74 = typeof value15;
      if (type74 === "boolean") {
        if (value15) {
          result += " " + key;
        }
        continue;
      }
      if (value15 === null || value15 === undefined) {
        continue;
      }
      result += " " + key;
      if (type74 !== "string") {
        if (type74 !== "object") {
          result += '="' + value15.toString() + '"';
          continue;
        }
        if (value15 instanceof Date) {
          result += '="' + value15.toISOString() + '"';
          continue;
        }
        value15 = value15.toString();
      }
      end = value15.indexOf('"');
      if (end === -1) {
        result += '="' + value15 + '"';
        continue;
      }
      result += '="';
      valueLength = value15.length;
      start = 0;
      for (;end < valueLength; end++) {
        if (value15[end] === '"') {
          result += value15.slice(start, end) + "&#34;";
          start = end + 1;
        }
      }
      result += value15.slice(start, end) + '"';
    }
    return result;
  };
  var contentsToString = function(contents, escape2) {
    let length = contents.length;
    let result = "";
    let content;
    let index = 0;
    for (;index < length; index++) {
      content = contents[index];
      if (typeof content !== "string") {
        if (!content && content !== 0) {
          continue;
        }
        if (content.then) {
          return Promise.all(contents.slice(index)).then(function resolveAsyncContent(resolved) {
            resolved.unshift(result);
            return contentsToString(resolved, escape2);
          });
        }
        if (Array.isArray(content)) {
          contents.splice(index--, 1, ...content);
          length += content.length - 1;
          continue;
        }
      }
      result += content;
    }
    if (escape2 === true) {
      return escapeHtml(result);
    }
    return result;
  };
  var createElement = function(name, attrs, ...children) {
    const hasAttrs = attrs !== null;
    if (typeof name === "function") {
      if (!hasAttrs) {
        attrs = { children: children.length > 1 ? children : children[0] };
      } else if (attrs.children === undefined) {
        attrs.children = children.length > 1 ? children : children[0];
      }
      return name(attrs);
    }
    if (hasAttrs && name === "tag") {
      name = String(attrs.of);
      delete attrs.of;
    }
    const attributes = hasAttrs ? attributesToString(attrs) : "";
    if (children.length === 0 && isVoidElement(name)) {
      return "<" + name + attributes + "/>";
    }
    const contents = contentsToString(children, hasAttrs && attrs.safe);
    if (typeof contents === "string") {
      return "<" + name + attributes + ">" + contents + "</" + name + ">";
    }
    return contents.then(function asyncChildren(child) {
      return "<" + name + attributes + ">" + child + "</" + name + ">";
    });
  };
  var Fragment = function(props) {
    return Html2.contentsToString([props.children]);
  };
  var compile = function(htmlFn, strict4 = true, separator = "/*\0*/") {
    if (typeof htmlFn !== "function") {
      throw new Error("The first argument must be a function.");
    }
    const properties = new Set;
    const html = htmlFn(new Proxy({}, {
      get(_, name) {
        properties.add(name);
        const isChildren = name === "children";
        let access = `args[${separator}\`${name.toString()}\`${separator}]`;
        if (isChildren) {
          access = `Array.isArray(${access}) ? ${access}.join(${separator}\`\`${separator}) : ${access}`;
        }
        return `\`${separator} + (${access} || ${strict4 && !isChildren ? `throwPropertyNotFound(${separator}\`${name.toString()}\`${separator})` : `${separator}\`\`${separator}`}) + ${separator}\``;
      }
    }));
    if (typeof html !== "string") {
      throw new Error("You cannot use compile() with async components.");
    }
    const sepLength = separator.length;
    const length = html.length;
    let body = "";
    let nextStart = 0;
    let index = 0;
    for (;index < length; index++) {
      if (html[index] === "`" && html.slice(index - sepLength, index) !== separator && html.slice(index + 1, index + sepLength + 1) !== separator) {
        body += html.slice(nextStart, index) + "\\`";
        nextStart = index + 1;
        continue;
      }
    }
    body += html.slice(nextStart);
    if (strict4) {
      return Function("args", 'if (args === undefined) { throw new Error("The arguments object was not provided.") };\nfunction throwPropertyNotFound(name) { throw new Error("Property " + name + " was not provided.") };\n' + `return \`${body}\``);
    }
    return Function("args", "if (args === undefined) { args = Object.create(null) };\n" + `return \`${body}\``);
  };
  var ESCAPED_REGEX = /[<"'&]/;
  var CAMEL_REGEX = /[a-z][A-Z]/;
  var escapeHtml = function(value15) {
    if (typeof value15 !== "string") {
      value15 = value15.toString();
    }
    if (!ESCAPED_REGEX.test(value15)) {
      return value15;
    }
    const length = value15.length;
    let escaped = "";
    let start = 0;
    let end = 0;
    for (;end < length; end++) {
      switch (value15[end]) {
        case "&":
          escaped += value15.slice(start, end) + "&amp;";
          start = end + 1;
          continue;
        case "<":
          escaped += value15.slice(start, end) + "&lt;";
          start = end + 1;
          continue;
        case '"':
          escaped += value15.slice(start, end) + "&#34;";
          start = end + 1;
          continue;
        case "'":
          escaped += value15.slice(start, end) + "&#39;";
          start = end + 1;
          continue;
      }
    }
    escaped += value15.slice(start, end);
    return escaped;
  };
  if (typeof Bun !== "undefined")
    escapeHtml = Bun.escapeHTML;
  var Html2 = {
    escape,
    e: escape,
    escapeHtml,
    isVoidElement,
    attributesToString,
    toKebabCase,
    isUpper,
    styleToString,
    createElement,
    h: createElement,
    contentsToString,
    compile,
    Fragment
  };
  module.exports = Html2;
  module.exports.Html = Html2;
  module.exports.default = Html2;
});

// node_modules/@elysiajs/html/dist/cjs/h.js
var require_h = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createElement = undefined;
  var html_1 = require_html();
  var createElement = (name, attrs, ...children) => {
    const { $elysia, ...attr } = attrs ?? {};
    const a2 = (0, html_1.createElement)(name, attr, ...children);
    return a2;
  };
  exports.createElement = createElement;
});

// node_modules/@sinclair/typebox/build/require/value/guard/guard.js
var require_guard = __commonJS((exports) => {
  var IsAsyncIterator4 = function(value15) {
    return IsObject4(value15) && Symbol.asyncIterator in value15;
  };
  var IsIterator4 = function(value15) {
    return IsObject4(value15) && Symbol.iterator in value15;
  };
  var IsStandardObject2 = function(value15) {
    return IsObject4(value15) && !IsArray4(value15) && IsFunction4(value15.constructor) && value15.constructor.name === "Object";
  };
  var IsInstanceObject = function(value15) {
    return IsObject4(value15) && !IsArray4(value15) && IsFunction4(value15.constructor) && value15.constructor.name !== "Object";
  };
  var IsPromise3 = function(value15) {
    return value15 instanceof Promise;
  };
  var IsDate4 = function(value15) {
    return value15 instanceof Date && Number.isFinite(value15.getTime());
  };
  var IsMap = function(value15) {
    return value15 instanceof globalThis.Map;
  };
  var IsSet = function(value15) {
    return value15 instanceof globalThis.Set;
  };
  var IsRegExp3 = function(value15) {
    return value15 instanceof globalThis.RegExp;
  };
  var IsTypedArray2 = function(value15) {
    return ArrayBuffer.isView(value15);
  };
  var IsInt8Array = function(value15) {
    return value15 instanceof globalThis.Int8Array;
  };
  var IsUint8Array4 = function(value15) {
    return value15 instanceof globalThis.Uint8Array;
  };
  var IsUint8ClampedArray = function(value15) {
    return value15 instanceof globalThis.Uint8ClampedArray;
  };
  var IsInt16Array = function(value15) {
    return value15 instanceof globalThis.Int16Array;
  };
  var IsUint16Array = function(value15) {
    return value15 instanceof globalThis.Uint16Array;
  };
  var IsInt32Array = function(value15) {
    return value15 instanceof globalThis.Int32Array;
  };
  var IsUint32Array = function(value15) {
    return value15 instanceof globalThis.Uint32Array;
  };
  var IsFloat32Array = function(value15) {
    return value15 instanceof globalThis.Float32Array;
  };
  var IsFloat64Array = function(value15) {
    return value15 instanceof globalThis.Float64Array;
  };
  var IsBigInt64Array = function(value15) {
    return value15 instanceof globalThis.BigInt64Array;
  };
  var IsBigUint64Array = function(value15) {
    return value15 instanceof globalThis.BigUint64Array;
  };
  var HasPropertyKey2 = function(value15, key) {
    return key in value15;
  };
  var IsObject4 = function(value15) {
    return value15 !== null && typeof value15 === "object";
  };
  var IsArray4 = function(value15) {
    return Array.isArray(value15) && !ArrayBuffer.isView(value15);
  };
  var IsUndefined4 = function(value15) {
    return value15 === undefined;
  };
  var IsNull4 = function(value15) {
    return value15 === null;
  };
  var IsBoolean4 = function(value15) {
    return typeof value15 === "boolean";
  };
  var IsNumber4 = function(value15) {
    return typeof value15 === "number";
  };
  var IsInteger3 = function(value15) {
    return IsNumber4(value15) && Number.isInteger(value15);
  };
  var IsBigInt4 = function(value15) {
    return typeof value15 === "bigint";
  };
  var IsString4 = function(value15) {
    return typeof value15 === "string";
  };
  var IsFunction4 = function(value15) {
    return typeof value15 === "function";
  };
  var IsSymbol4 = function(value15) {
    return typeof value15 === "symbol";
  };
  var IsValueType2 = function(value15) {
    return IsBigInt4(value15) || IsBoolean4(value15) || IsNull4(value15) || IsNumber4(value15) || IsString4(value15) || IsSymbol4(value15) || IsUndefined4(value15);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.HasPropertyKey = exports.IsBigUint64Array = exports.IsBigInt64Array = exports.IsFloat64Array = exports.IsFloat32Array = exports.IsUint32Array = exports.IsInt32Array = exports.IsUint16Array = exports.IsInt16Array = exports.IsUint8ClampedArray = exports.IsUint8Array = exports.IsInt8Array = exports.IsTypedArray = exports.IsRegExp = exports.IsSet = exports.IsMap = exports.IsDate = exports.IsPromise = exports.IsInstanceObject = exports.IsStandardObject = exports.IsIterator = exports.IsAsyncIterator = undefined;
  exports.IsAsyncIterator = IsAsyncIterator4;
  exports.IsIterator = IsIterator4;
  exports.IsStandardObject = IsStandardObject2;
  exports.IsInstanceObject = IsInstanceObject;
  exports.IsPromise = IsPromise3;
  exports.IsDate = IsDate4;
  exports.IsMap = IsMap;
  exports.IsSet = IsSet;
  exports.IsRegExp = IsRegExp3;
  exports.IsTypedArray = IsTypedArray2;
  exports.IsInt8Array = IsInt8Array;
  exports.IsUint8Array = IsUint8Array4;
  exports.IsUint8ClampedArray = IsUint8ClampedArray;
  exports.IsInt16Array = IsInt16Array;
  exports.IsUint16Array = IsUint16Array;
  exports.IsInt32Array = IsInt32Array;
  exports.IsUint32Array = IsUint32Array;
  exports.IsFloat32Array = IsFloat32Array;
  exports.IsFloat64Array = IsFloat64Array;
  exports.IsBigInt64Array = IsBigInt64Array;
  exports.IsBigUint64Array = IsBigUint64Array;
  exports.HasPropertyKey = HasPropertyKey2;
  exports.IsObject = IsObject4;
  exports.IsArray = IsArray4;
  exports.IsUndefined = IsUndefined4;
  exports.IsNull = IsNull4;
  exports.IsBoolean = IsBoolean4;
  exports.IsNumber = IsNumber4;
  exports.IsInteger = IsInteger3;
  exports.IsBigInt = IsBigInt4;
  exports.IsString = IsString4;
  exports.IsFunction = IsFunction4;
  exports.IsSymbol = IsSymbol4;
  exports.IsValueType = IsValueType2;
});

// node_modules/@sinclair/typebox/build/require/value/guard/index.js
var require_guard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_guard(), exports);
});

// node_modules/@sinclair/typebox/build/require/system/policy.js
var require_policy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystemPolicy = undefined;
  var index_1 = require_guard2();
  var TypeSystemPolicy2;
  (function(TypeSystemPolicy3) {
    TypeSystemPolicy3.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy3.AllowArrayObject = false;
    TypeSystemPolicy3.AllowNaN = false;
    TypeSystemPolicy3.AllowNullVoid = false;
    function IsExactOptionalProperty(value15, key) {
      return TypeSystemPolicy3.ExactOptionalPropertyTypes ? key in value15 : value15[key] !== undefined;
    }
    TypeSystemPolicy3.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value15) {
      const isObject2 = (0, index_1.IsObject)(value15);
      return TypeSystemPolicy3.AllowArrayObject ? isObject2 : isObject2 && !(0, index_1.IsArray)(value15);
    }
    TypeSystemPolicy3.IsObjectLike = IsObjectLike;
    function IsRecordLike(value15) {
      return IsObjectLike(value15) && !(value15 instanceof Date) && !(value15 instanceof Uint8Array);
    }
    TypeSystemPolicy3.IsRecordLike = IsRecordLike;
    function IsNumberLike(value15) {
      const isNumber = (0, index_1.IsNumber)(value15);
      return TypeSystemPolicy3.AllowNaN ? isNumber : isNumber && Number.isFinite(value15);
    }
    TypeSystemPolicy3.IsNumberLike = IsNumberLike;
    function IsVoidLike(value15) {
      const isUndefined = (0, index_1.IsUndefined)(value15);
      return TypeSystemPolicy3.AllowNullVoid ? isUndefined || value15 === null : isUndefined;
    }
    TypeSystemPolicy3.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy2 || (exports.TypeSystemPolicy = TypeSystemPolicy2 = {}));
});

// node_modules/@sinclair/typebox/build/require/type/registry/format.js
var require_format = __commonJS((exports) => {
  var Entries3 = function() {
    return new Map(map3);
  };
  var Clear3 = function() {
    return map3.clear();
  };
  var Delete5 = function(format) {
    return map3.delete(format);
  };
  var Has4 = function(format) {
    return map3.has(format);
  };
  var Set5 = function(format, func) {
    map3.set(format, func);
  };
  var Get4 = function(format) {
    return map3.get(format);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Get = exports.Set = exports.Has = exports.Delete = exports.Clear = exports.Entries = undefined;
  var map3 = new Map;
  exports.Entries = Entries3;
  exports.Clear = Clear3;
  exports.Delete = Delete5;
  exports.Has = Has4;
  exports.Set = Set5;
  exports.Get = Get4;
});

// node_modules/@sinclair/typebox/build/require/type/registry/type.js
var require_type = __commonJS((exports) => {
  var Entries3 = function() {
    return new Map(map3);
  };
  var Clear3 = function() {
    return map3.clear();
  };
  var Delete5 = function(kind) {
    return map3.delete(kind);
  };
  var Has4 = function(kind) {
    return map3.has(kind);
  };
  var Set5 = function(kind, func) {
    map3.set(kind, func);
  };
  var Get4 = function(kind) {
    return map3.get(kind);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Get = exports.Set = exports.Has = exports.Delete = exports.Clear = exports.Entries = undefined;
  var map3 = new Map;
  exports.Entries = Entries3;
  exports.Clear = Clear3;
  exports.Delete = Delete5;
  exports.Has = Has4;
  exports.Set = Set5;
  exports.Get = Get4;
});

// node_modules/@sinclair/typebox/build/require/type/registry/index.js
var require_registry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeRegistry = exports.FormatRegistry = undefined;
  exports.FormatRegistry = require_format();
  exports.TypeRegistry = require_type();
});

// node_modules/@sinclair/typebox/build/require/type/symbols/symbols.js
var require_symbols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Kind = exports.Hint = exports.OptionalKind = exports.ReadonlyKind = exports.TransformKind = undefined;
  exports.TransformKind = Symbol.for("TypeBox.Transform");
  exports.ReadonlyKind = Symbol.for("TypeBox.Readonly");
  exports.OptionalKind = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
});

// node_modules/@sinclair/typebox/build/require/type/symbols/index.js
var require_symbols2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbols(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/unsafe/unsafe.js
var require_unsafe = __commonJS((exports) => {
  var Unsafe2 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: options[index_1.Kind] ?? "Unsafe"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unsafe = undefined;
  var index_1 = require_symbols2();
  exports.Unsafe = Unsafe2;
});

// node_modules/@sinclair/typebox/build/require/type/unsafe/index.js
var require_unsafe2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unsafe(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/error/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeBoxError = undefined;

  class TypeBoxError2 extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports.TypeBoxError = TypeBoxError2;
});

// node_modules/@sinclair/typebox/build/require/type/error/index.js
var require_error2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_error(), exports);
});

// node_modules/@sinclair/typebox/build/require/system/system.js
var require_system = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = undefined;
  var index_1 = require_registry();
  var index_2 = require_unsafe2();
  var index_3 = require_symbols2();
  var index_4 = require_error2();

  class TypeSystemDuplicateTypeKind2 extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind2;

  class TypeSystemDuplicateFormat2 extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat2;
  var TypeSystem2;
  (function(TypeSystem3) {
    function Type2(kind, check11) {
      if (index_1.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind2(kind);
      index_1.TypeRegistry.Set(kind, check11);
      return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
    }
    TypeSystem3.Type = Type2;
    function Format2(format, check11) {
      if (index_1.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat2(format);
      index_1.FormatRegistry.Set(format, check11);
      return format;
    }
    TypeSystem3.Format = Format2;
  })(TypeSystem2 || (exports.TypeSystem = TypeSystem2 = {}));
});

// node_modules/@sinclair/typebox/build/require/system/index.js
var require_system2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_policy(), exports);
  __exportStar(require_system(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/mapped/mapped-key.js
var require_mapped_key = __commonJS((exports) => {
  var MappedKey = function(T) {
    return {
      [index_1.Kind]: "MappedKey",
      keys: T
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedKey = undefined;
  var index_1 = require_symbols2();
  exports.MappedKey = MappedKey;
});

// node_modules/@sinclair/typebox/build/require/type/mapped/mapped-result.js
var require_mapped_result = __commonJS((exports) => {
  var MappedResult2 = function(properties) {
    return {
      [index_1.Kind]: "MappedResult",
      properties
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedResult = undefined;
  var index_1 = require_symbols2();
  exports.MappedResult = MappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/guard/value.js
var require_value = __commonJS((exports) => {
  var IsAsyncIterator4 = function(value15) {
    return IsObject4(value15) && !IsArray4(value15) && !IsUint8Array4(value15) && Symbol.asyncIterator in value15;
  };
  var IsArray4 = function(value15) {
    return Array.isArray(value15);
  };
  var IsBigInt4 = function(value15) {
    return typeof value15 === "bigint";
  };
  var IsBoolean4 = function(value15) {
    return typeof value15 === "boolean";
  };
  var IsDate4 = function(value15) {
    return value15 instanceof globalThis.Date;
  };
  var IsFunction4 = function(value15) {
    return typeof value15 === "function";
  };
  var IsIterator4 = function(value15) {
    return IsObject4(value15) && !IsArray4(value15) && !IsUint8Array4(value15) && Symbol.iterator in value15;
  };
  var IsNull4 = function(value15) {
    return value15 === null;
  };
  var IsNumber4 = function(value15) {
    return typeof value15 === "number";
  };
  var IsObject4 = function(value15) {
    return typeof value15 === "object" && value15 !== null;
  };
  var IsRegExp3 = function(value15) {
    return value15 instanceof globalThis.RegExp;
  };
  var IsString4 = function(value15) {
    return typeof value15 === "string";
  };
  var IsSymbol4 = function(value15) {
    return typeof value15 === "symbol";
  };
  var IsUint8Array4 = function(value15) {
    return value15 instanceof globalThis.Uint8Array;
  };
  var IsUndefined4 = function(value15) {
    return value15 === undefined;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsUndefined = exports.IsUint8Array = exports.IsSymbol = exports.IsString = exports.IsRegExp = exports.IsObject = exports.IsNumber = exports.IsNull = exports.IsIterator = exports.IsFunction = exports.IsDate = exports.IsBoolean = exports.IsBigInt = exports.IsArray = exports.IsAsyncIterator = undefined;
  exports.IsAsyncIterator = IsAsyncIterator4;
  exports.IsArray = IsArray4;
  exports.IsBigInt = IsBigInt4;
  exports.IsBoolean = IsBoolean4;
  exports.IsDate = IsDate4;
  exports.IsFunction = IsFunction4;
  exports.IsIterator = IsIterator4;
  exports.IsNull = IsNull4;
  exports.IsNumber = IsNumber4;
  exports.IsObject = IsObject4;
  exports.IsRegExp = IsRegExp3;
  exports.IsString = IsString4;
  exports.IsSymbol = IsSymbol4;
  exports.IsUint8Array = IsUint8Array4;
  exports.IsUndefined = IsUndefined4;
});

// node_modules/@sinclair/typebox/build/require/type/clone/value.js
var require_value2 = __commonJS((exports) => {
  var ArrayType7 = function(value15) {
    return value15.map((value16) => Visit17(value16));
  };
  var DateType5 = function(value15) {
    return new Date(value15.getTime());
  };
  var Uint8ArrayType3 = function(value15) {
    return new Uint8Array(value15);
  };
  var RegExpType2 = function(value15) {
    return new RegExp(value15.source, value15.flags);
  };
  var ObjectType7 = function(value15) {
    const clonedProperties = Object.getOwnPropertyNames(value15).reduce((acc, key) => ({ ...acc, [key]: Visit17(value15[key]) }), {});
    const clonedSymbols = Object.getOwnPropertySymbols(value15).reduce((acc, key) => ({ ...acc, [key]: Visit17(value15[key]) }), {});
    return { ...clonedProperties, ...clonedSymbols };
  };
  var Visit17 = function(value15) {
    return ValueGuard.IsArray(value15) ? ArrayType7(value15) : ValueGuard.IsDate(value15) ? DateType5(value15) : ValueGuard.IsUint8Array(value15) ? Uint8ArrayType3(value15) : ValueGuard.IsRegExp(value15) ? RegExpType2(value15) : ValueGuard.IsObject(value15) ? ObjectType7(value15) : value15;
  };
  var Clone4 = function(value15) {
    return Visit17(value15);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = undefined;
  var ValueGuard = require_value();
  exports.Clone = Clone4;
});

// node_modules/@sinclair/typebox/build/require/type/clone/type.js
var require_type2 = __commonJS((exports) => {
  var CloneRest2 = function(schemas) {
    return schemas.map((schema3) => CloneType2(schema3));
  };
  var CloneType2 = function(schema3, options = {}) {
    return { ...(0, value_1.Clone)(schema3), ...options };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CloneType = exports.CloneRest = undefined;
  var value_1 = require_value2();
  exports.CloneRest = CloneRest2;
  exports.CloneType = CloneType2;
});

// node_modules/@sinclair/typebox/build/require/type/discard/discard.js
var require_discard = __commonJS((exports) => {
  var DiscardKey2 = function(value15, key) {
    const { [key]: _, ...rest4 } = value15;
    return rest4;
  };
  var Discard2 = function(value15, keys) {
    return keys.reduce((acc, key) => DiscardKey2(acc, key), value15);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Discard = undefined;
  exports.Discard = Discard2;
});

// node_modules/@sinclair/typebox/build/require/type/discard/index.js
var require_discard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_discard(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/array/array.js
var require_array = __commonJS((exports) => {
  var Array3 = function(schema3, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Array",
      type: "array",
      items: (0, type_1.CloneType)(schema3)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Array = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.Array = Array3;
});

// node_modules/@sinclair/typebox/build/require/type/array/index.js
var require_array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_array(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/async-iterator/async-iterator.js
var require_async_iterator = __commonJS((exports) => {
  var AsyncIterator2 = function(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "AsyncIterator",
      type: "AsyncIterator",
      items: (0, type_1.CloneType)(items)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncIterator = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  exports.AsyncIterator = AsyncIterator2;
});

// node_modules/@sinclair/typebox/build/require/type/async-iterator/index.js
var require_async_iterator2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_async_iterator(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/constructor/constructor.js
var require_constructor = __commonJS((exports) => {
  var Constructor2 = function(parameters4, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Constructor",
      type: "Constructor",
      parameters: (0, type_1.CloneRest)(parameters4),
      returns: (0, type_1.CloneType)(returns)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Constructor = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.Constructor = Constructor2;
});

// node_modules/@sinclair/typebox/build/require/type/constructor/index.js
var require_constructor2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/function/function.js
var require_function = __commonJS((exports) => {
  var Function3 = function(parameters4, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Function",
      type: "Function",
      parameters: (0, type_1.CloneRest)(parameters4),
      returns: (0, type_1.CloneType)(returns)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Function = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.Function = Function3;
});

// node_modules/@sinclair/typebox/build/require/type/function/index.js
var require_function2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_function(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/never/never.js
var require_never = __commonJS((exports) => {
  var Never2 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Never",
      not: {}
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Never = undefined;
  var index_1 = require_symbols2();
  exports.Never = Never2;
});

// node_modules/@sinclair/typebox/build/require/type/never/index.js
var require_never2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_never(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/guard/type.js
var require_type3 = __commonJS((exports) => {
  var IsPattern2 = function(value15) {
    try {
      new RegExp(value15);
      return true;
    } catch {
      return false;
    }
  };
  var IsControlCharacterFree2 = function(value15) {
    if (!ValueGuard.IsString(value15))
      return false;
    for (let i = 0;i < value15.length; i++) {
      const code = value15.charCodeAt(i);
      if (code >= 7 && code <= 13 || code === 27 || code === 127) {
        return false;
      }
    }
    return true;
  };
  var IsAdditionalProperties2 = function(value15) {
    return IsOptionalBoolean2(value15) || IsSchema2(value15);
  };
  var IsOptionalBigInt2 = function(value15) {
    return ValueGuard.IsUndefined(value15) || ValueGuard.IsBigInt(value15);
  };
  var IsOptionalNumber2 = function(value15) {
    return ValueGuard.IsUndefined(value15) || ValueGuard.IsNumber(value15);
  };
  var IsOptionalBoolean2 = function(value15) {
    return ValueGuard.IsUndefined(value15) || ValueGuard.IsBoolean(value15);
  };
  var IsOptionalString2 = function(value15) {
    return ValueGuard.IsUndefined(value15) || ValueGuard.IsString(value15);
  };
  var IsOptionalPattern2 = function(value15) {
    return ValueGuard.IsUndefined(value15) || ValueGuard.IsString(value15) && IsControlCharacterFree2(value15) && IsPattern2(value15);
  };
  var IsOptionalFormat2 = function(value15) {
    return ValueGuard.IsUndefined(value15) || ValueGuard.IsString(value15) && IsControlCharacterFree2(value15);
  };
  var IsOptionalSchema2 = function(value15) {
    return ValueGuard.IsUndefined(value15) || IsSchema2(value15);
  };
  var IsReadonly2 = function(value15) {
    return ValueGuard.IsObject(value15) && value15[index_1.ReadonlyKind] === "Readonly";
  };
  var IsOptional2 = function(value15) {
    return ValueGuard.IsObject(value15) && value15[index_1.OptionalKind] === "Optional";
  };
  var IsAny2 = function(value15) {
    return IsKindOf2(value15, "Any") && IsOptionalString2(value15.$id);
  };
  var IsArray4 = function(value15) {
    return IsKindOf2(value15, "Array") && value15.type === "array" && IsOptionalString2(value15.$id) && IsSchema2(value15.items) && IsOptionalNumber2(value15.minItems) && IsOptionalNumber2(value15.maxItems) && IsOptionalBoolean2(value15.uniqueItems) && IsOptionalSchema2(value15.contains) && IsOptionalNumber2(value15.minContains) && IsOptionalNumber2(value15.maxContains);
  };
  var IsAsyncIterator4 = function(value15) {
    return IsKindOf2(value15, "AsyncIterator") && value15.type === "AsyncIterator" && IsOptionalString2(value15.$id) && IsSchema2(value15.items);
  };
  var IsBigInt4 = function(value15) {
    return IsKindOf2(value15, "BigInt") && value15.type === "bigint" && IsOptionalString2(value15.$id) && IsOptionalBigInt2(value15.exclusiveMaximum) && IsOptionalBigInt2(value15.exclusiveMinimum) && IsOptionalBigInt2(value15.maximum) && IsOptionalBigInt2(value15.minimum) && IsOptionalBigInt2(value15.multipleOf);
  };
  var IsBoolean4 = function(value15) {
    return IsKindOf2(value15, "Boolean") && value15.type === "boolean" && IsOptionalString2(value15.$id);
  };
  var IsConstructor2 = function(value15) {
    return IsKindOf2(value15, "Constructor") && value15.type === "Constructor" && IsOptionalString2(value15.$id) && ValueGuard.IsArray(value15.parameters) && value15.parameters.every((schema3) => IsSchema2(schema3)) && IsSchema2(value15.returns);
  };
  var IsDate4 = function(value15) {
    return IsKindOf2(value15, "Date") && value15.type === "Date" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.exclusiveMaximumTimestamp) && IsOptionalNumber2(value15.exclusiveMinimumTimestamp) && IsOptionalNumber2(value15.maximumTimestamp) && IsOptionalNumber2(value15.minimumTimestamp) && IsOptionalNumber2(value15.multipleOfTimestamp);
  };
  var IsFunction4 = function(value15) {
    return IsKindOf2(value15, "Function") && value15.type === "Function" && IsOptionalString2(value15.$id) && ValueGuard.IsArray(value15.parameters) && value15.parameters.every((schema3) => IsSchema2(schema3)) && IsSchema2(value15.returns);
  };
  var IsInteger3 = function(value15) {
    return IsKindOf2(value15, "Integer") && value15.type === "integer" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.exclusiveMaximum) && IsOptionalNumber2(value15.exclusiveMinimum) && IsOptionalNumber2(value15.maximum) && IsOptionalNumber2(value15.minimum) && IsOptionalNumber2(value15.multipleOf);
  };
  var IsProperties2 = function(value15) {
    return ValueGuard.IsObject(value15) && Object.entries(value15).every(([key, schema3]) => IsControlCharacterFree2(key) && IsSchema2(schema3));
  };
  var IsIntersect2 = function(value15) {
    return IsKindOf2(value15, "Intersect") && (ValueGuard.IsString(value15.type) && value15.type !== "object" ? false : true) && ValueGuard.IsArray(value15.allOf) && value15.allOf.every((schema3) => IsSchema2(schema3) && !IsTransform2(schema3)) && IsOptionalString2(value15.type) && (IsOptionalBoolean2(value15.unevaluatedProperties) || IsOptionalSchema2(value15.unevaluatedProperties)) && IsOptionalString2(value15.$id);
  };
  var IsIterator4 = function(value15) {
    return IsKindOf2(value15, "Iterator") && value15.type === "Iterator" && IsOptionalString2(value15.$id) && IsSchema2(value15.items);
  };
  var IsKindOf2 = function(value15, kind) {
    return ValueGuard.IsObject(value15) && index_1.Kind in value15 && value15[index_1.Kind] === kind;
  };
  var IsLiteralString2 = function(value15) {
    return IsLiteral2(value15) && ValueGuard.IsString(value15.const);
  };
  var IsLiteralNumber2 = function(value15) {
    return IsLiteral2(value15) && ValueGuard.IsNumber(value15.const);
  };
  var IsLiteralBoolean2 = function(value15) {
    return IsLiteral2(value15) && ValueGuard.IsBoolean(value15.const);
  };
  var IsLiteral2 = function(value15) {
    return IsKindOf2(value15, "Literal") && IsOptionalString2(value15.$id) && IsLiteralValue2(value15.const);
  };
  var IsLiteralValue2 = function(value15) {
    return ValueGuard.IsBoolean(value15) || ValueGuard.IsNumber(value15) || ValueGuard.IsString(value15);
  };
  var IsMappedKey2 = function(value15) {
    return IsKindOf2(value15, "MappedKey") && ValueGuard.IsArray(value15.keys) && value15.keys.every((key) => ValueGuard.IsNumber(key) || ValueGuard.IsString(key));
  };
  var IsMappedResult2 = function(value15) {
    return IsKindOf2(value15, "MappedResult") && IsProperties2(value15.properties);
  };
  var IsNever2 = function(value15) {
    return IsKindOf2(value15, "Never") && ValueGuard.IsObject(value15.not) && Object.getOwnPropertyNames(value15.not).length === 0;
  };
  var IsNot2 = function(value15) {
    return IsKindOf2(value15, "Not") && IsSchema2(value15.not);
  };
  var IsNull4 = function(value15) {
    return IsKindOf2(value15, "Null") && value15.type === "null" && IsOptionalString2(value15.$id);
  };
  var IsNumber4 = function(value15) {
    return IsKindOf2(value15, "Number") && value15.type === "number" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.exclusiveMaximum) && IsOptionalNumber2(value15.exclusiveMinimum) && IsOptionalNumber2(value15.maximum) && IsOptionalNumber2(value15.minimum) && IsOptionalNumber2(value15.multipleOf);
  };
  var IsObject4 = function(value15) {
    return IsKindOf2(value15, "Object") && value15.type === "object" && IsOptionalString2(value15.$id) && IsProperties2(value15.properties) && IsAdditionalProperties2(value15.additionalProperties) && IsOptionalNumber2(value15.minProperties) && IsOptionalNumber2(value15.maxProperties);
  };
  var IsPromise3 = function(value15) {
    return IsKindOf2(value15, "Promise") && value15.type === "Promise" && IsOptionalString2(value15.$id) && IsSchema2(value15.item);
  };
  var IsRecord2 = function(value15) {
    return IsKindOf2(value15, "Record") && value15.type === "object" && IsOptionalString2(value15.$id) && IsAdditionalProperties2(value15.additionalProperties) && ValueGuard.IsObject(value15.patternProperties) && ((schema3) => {
      const keys = Object.getOwnPropertyNames(schema3.patternProperties);
      return keys.length === 1 && IsPattern2(keys[0]) && ValueGuard.IsObject(schema3.patternProperties) && IsSchema2(schema3.patternProperties[keys[0]]);
    })(value15);
  };
  var IsRecursive2 = function(value15) {
    return ValueGuard.IsObject(value15) && index_1.Hint in value15 && value15[index_1.Hint] === "Recursive";
  };
  var IsRef2 = function(value15) {
    return IsKindOf2(value15, "Ref") && IsOptionalString2(value15.$id) && ValueGuard.IsString(value15.$ref);
  };
  var IsRegExp3 = function(value15) {
    return IsKindOf2(value15, "RegExp") && IsOptionalString2(value15.$id) && ValueGuard.IsString(value15.source) && ValueGuard.IsString(value15.flags) && IsOptionalNumber2(value15.maxLength) && IsOptionalNumber2(value15.minLength);
  };
  var IsString4 = function(value15) {
    return IsKindOf2(value15, "String") && value15.type === "string" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.minLength) && IsOptionalNumber2(value15.maxLength) && IsOptionalPattern2(value15.pattern) && IsOptionalFormat2(value15.format);
  };
  var IsSymbol4 = function(value15) {
    return IsKindOf2(value15, "Symbol") && value15.type === "symbol" && IsOptionalString2(value15.$id);
  };
  var IsTemplateLiteral2 = function(value15) {
    return IsKindOf2(value15, "TemplateLiteral") && value15.type === "string" && ValueGuard.IsString(value15.pattern) && value15.pattern[0] === "^" && value15.pattern[value15.pattern.length - 1] === "$";
  };
  var IsThis2 = function(value15) {
    return IsKindOf2(value15, "This") && IsOptionalString2(value15.$id) && ValueGuard.IsString(value15.$ref);
  };
  var IsTransform2 = function(value15) {
    return ValueGuard.IsObject(value15) && index_1.TransformKind in value15;
  };
  var IsTuple2 = function(value15) {
    return IsKindOf2(value15, "Tuple") && value15.type === "array" && IsOptionalString2(value15.$id) && ValueGuard.IsNumber(value15.minItems) && ValueGuard.IsNumber(value15.maxItems) && value15.minItems === value15.maxItems && (ValueGuard.IsUndefined(value15.items) && ValueGuard.IsUndefined(value15.additionalItems) && value15.minItems === 0 || ValueGuard.IsArray(value15.items) && value15.items.every((schema3) => IsSchema2(schema3)));
  };
  var IsUndefined4 = function(value15) {
    return IsKindOf2(value15, "Undefined") && value15.type === "undefined" && IsOptionalString2(value15.$id);
  };
  var IsUnionLiteral2 = function(value15) {
    return IsUnion2(value15) && value15.anyOf.every((schema3) => IsLiteralString2(schema3) || IsLiteralNumber2(schema3));
  };
  var IsUnion2 = function(value15) {
    return IsKindOf2(value15, "Union") && IsOptionalString2(value15.$id) && ValueGuard.IsObject(value15) && ValueGuard.IsArray(value15.anyOf) && value15.anyOf.every((schema3) => IsSchema2(schema3));
  };
  var IsUint8Array4 = function(value15) {
    return IsKindOf2(value15, "Uint8Array") && value15.type === "Uint8Array" && IsOptionalString2(value15.$id) && IsOptionalNumber2(value15.minByteLength) && IsOptionalNumber2(value15.maxByteLength);
  };
  var IsUnknown2 = function(value15) {
    return IsKindOf2(value15, "Unknown") && IsOptionalString2(value15.$id);
  };
  var IsUnsafe2 = function(value15) {
    return IsKindOf2(value15, "Unsafe");
  };
  var IsVoid2 = function(value15) {
    return IsKindOf2(value15, "Void") && value15.type === "void" && IsOptionalString2(value15.$id);
  };
  var IsKind2 = function(value15) {
    return ValueGuard.IsObject(value15) && index_1.Kind in value15 && ValueGuard.IsString(value15[index_1.Kind]) && !KnownTypes2.includes(value15[index_1.Kind]);
  };
  var IsSchema2 = function(value15) {
    return ValueGuard.IsObject(value15) && (IsAny2(value15) || IsArray4(value15) || IsBoolean4(value15) || IsBigInt4(value15) || IsAsyncIterator4(value15) || IsConstructor2(value15) || IsDate4(value15) || IsFunction4(value15) || IsInteger3(value15) || IsIntersect2(value15) || IsIterator4(value15) || IsLiteral2(value15) || IsMappedKey2(value15) || IsMappedResult2(value15) || IsNever2(value15) || IsNot2(value15) || IsNull4(value15) || IsNumber4(value15) || IsObject4(value15) || IsPromise3(value15) || IsRecord2(value15) || IsRef2(value15) || IsRegExp3(value15) || IsString4(value15) || IsSymbol4(value15) || IsTemplateLiteral2(value15) || IsThis2(value15) || IsTuple2(value15) || IsUndefined4(value15) || IsUnion2(value15) || IsUint8Array4(value15) || IsUnknown2(value15) || IsUnsafe2(value15) || IsVoid2(value15) || IsKind2(value15));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsSchema = exports.IsKind = exports.IsVoid = exports.IsUnsafe = exports.IsUnknown = exports.IsUint8Array = exports.IsUnion = exports.IsUnionLiteral = exports.IsUndefined = exports.IsTuple = exports.IsTransform = exports.IsThis = exports.IsTemplateLiteral = exports.IsSymbol = exports.IsString = exports.IsRegExp = exports.IsRef = exports.IsRecursive = exports.IsRecord = exports.IsPromise = exports.IsObject = exports.IsNumber = exports.IsNull = exports.IsNot = exports.IsNever = exports.IsMappedResult = exports.IsMappedKey = exports.IsLiteralValue = exports.IsLiteral = exports.IsLiteralBoolean = exports.IsLiteralNumber = exports.IsLiteralString = exports.IsKindOf = exports.IsIterator = exports.IsIntersect = exports.IsProperties = exports.IsInteger = exports.IsFunction = exports.IsDate = exports.IsConstructor = exports.IsBoolean = exports.IsBigInt = exports.IsAsyncIterator = exports.IsArray = exports.IsAny = exports.IsOptional = exports.IsReadonly = exports.TypeGuardUnknownTypeError = undefined;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  var index_2 = require_error2();

  class TypeGuardUnknownTypeError2 extends index_2.TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError2;
  var KnownTypes2 = [
    "Any",
    "Array",
    "AsyncIterator",
    "BigInt",
    "Boolean",
    "Constructor",
    "Date",
    "Enum",
    "Function",
    "Integer",
    "Intersect",
    "Iterator",
    "Literal",
    "MappedKey",
    "MappedResult",
    "Not",
    "Null",
    "Number",
    "Object",
    "Promise",
    "Record",
    "Ref",
    "RegExp",
    "String",
    "Symbol",
    "TemplateLiteral",
    "This",
    "Tuple",
    "Undefined",
    "Union",
    "Uint8Array",
    "Unknown",
    "Void"
  ];
  exports.IsReadonly = IsReadonly2;
  exports.IsOptional = IsOptional2;
  exports.IsAny = IsAny2;
  exports.IsArray = IsArray4;
  exports.IsAsyncIterator = IsAsyncIterator4;
  exports.IsBigInt = IsBigInt4;
  exports.IsBoolean = IsBoolean4;
  exports.IsConstructor = IsConstructor2;
  exports.IsDate = IsDate4;
  exports.IsFunction = IsFunction4;
  exports.IsInteger = IsInteger3;
  exports.IsProperties = IsProperties2;
  exports.IsIntersect = IsIntersect2;
  exports.IsIterator = IsIterator4;
  exports.IsKindOf = IsKindOf2;
  exports.IsLiteralString = IsLiteralString2;
  exports.IsLiteralNumber = IsLiteralNumber2;
  exports.IsLiteralBoolean = IsLiteralBoolean2;
  exports.IsLiteral = IsLiteral2;
  exports.IsLiteralValue = IsLiteralValue2;
  exports.IsMappedKey = IsMappedKey2;
  exports.IsMappedResult = IsMappedResult2;
  exports.IsNever = IsNever2;
  exports.IsNot = IsNot2;
  exports.IsNull = IsNull4;
  exports.IsNumber = IsNumber4;
  exports.IsObject = IsObject4;
  exports.IsPromise = IsPromise3;
  exports.IsRecord = IsRecord2;
  exports.IsRecursive = IsRecursive2;
  exports.IsRef = IsRef2;
  exports.IsRegExp = IsRegExp3;
  exports.IsString = IsString4;
  exports.IsSymbol = IsSymbol4;
  exports.IsTemplateLiteral = IsTemplateLiteral2;
  exports.IsThis = IsThis2;
  exports.IsTransform = IsTransform2;
  exports.IsTuple = IsTuple2;
  exports.IsUndefined = IsUndefined4;
  exports.IsUnionLiteral = IsUnionLiteral2;
  exports.IsUnion = IsUnion2;
  exports.IsUint8Array = IsUint8Array4;
  exports.IsUnknown = IsUnknown2;
  exports.IsUnsafe = IsUnsafe2;
  exports.IsVoid = IsVoid2;
  exports.IsKind = IsKind2;
  exports.IsSchema = IsSchema2;
});

// node_modules/@sinclair/typebox/build/require/type/optional/optional.js
var require_optional = __commonJS((exports) => {
  var RemoveOptional2 = function(schema3) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema3), [index_1.OptionalKind]);
  };
  var AddOptional2 = function(schema3) {
    return { ...(0, type_1.CloneType)(schema3), [index_1.OptionalKind]: "Optional" };
  };
  var OptionalWithFlag2 = function(schema3, F) {
    return F === false ? RemoveOptional2(schema3) : AddOptional2(schema3);
  };
  var Optional2 = function(schema3, enable) {
    const F = enable ?? true;
    return (0, type_2.IsMappedResult)(schema3) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema3, F) : OptionalWithFlag2(schema3, F);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Optional = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var optional_from_mapped_result_1 = require_optional_from_mapped_result();
  var type_2 = require_type3();
  exports.Optional = Optional2;
});

// node_modules/@sinclair/typebox/build/require/type/optional/optional-from-mapped-result.js
var require_optional_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(P, F) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, optional_1.Optional)(P[K2], F) };
    }, {});
  };
  var FromMappedResult13 = function(R, F) {
    return FromProperties20(R.properties, F);
  };
  var OptionalFromMappedResult2 = function(R, F) {
    const P = FromMappedResult13(R, F);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionalFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var optional_1 = require_optional();
  exports.OptionalFromMappedResult = OptionalFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/optional/index.js
var require_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_optional_from_mapped_result(), exports);
  __exportStar(require_optional(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/intersect/intersect-create.js
var require_intersect_create = __commonJS((exports) => {
  var IntersectCreate2 = function(T, options) {
    const allObjects = T.every((schema3) => (0, type_2.IsObject)(schema3));
    const clonedUnevaluatedProperties = (0, type_2.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: (0, type_1.CloneType)(options.unevaluatedProperties) } : {};
    return options.unevaluatedProperties === false || (0, type_2.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: (0, type_1.CloneRest)(T) } : { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: (0, type_1.CloneRest)(T) };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectCreate = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var type_2 = require_type3();
  exports.IntersectCreate = IntersectCreate2;
});

// node_modules/@sinclair/typebox/build/require/type/intersect/intersect-evaluated.js
var require_intersect_evaluated = __commonJS((exports) => {
  var IsIntersectOptional2 = function(T) {
    return T.every((L) => (0, type_2.IsOptional)(L));
  };
  var RemoveOptionalFromType3 = function(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  };
  var RemoveOptionalFromRest3 = function(T) {
    return T.map((L) => (0, type_2.IsOptional)(L) ? RemoveOptionalFromType3(L) : L);
  };
  var ResolveIntersect2 = function(T, options) {
    return IsIntersectOptional2(T) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest3(T), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest3(T), options);
  };
  var IntersectEvaluated2 = function(T, options = {}) {
    if (T.length === 0)
      return (0, index_3.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema3) => (0, type_2.IsTransform)(schema3)))
      throw new Error("Cannot intersect transform types");
    return ResolveIntersect2(T, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectEvaluated = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never2();
  var index_4 = require_optional2();
  var intersect_create_1 = require_intersect_create();
  var type_2 = require_type3();
  exports.IntersectEvaluated = IntersectEvaluated2;
});

// node_modules/@sinclair/typebox/build/require/type/intersect/intersect-type.js
var require_intersect_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/require/type/intersect/intersect.js
var require_intersect = __commonJS((exports) => {
  var Intersect3 = function(T, options = {}) {
    if (T.length === 0)
      return (0, index_1.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema3) => (0, type_2.IsTransform)(schema3)))
      throw new Error("Cannot intersect transform types");
    return (0, intersect_create_1.IntersectCreate)(T, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intersect = undefined;
  var type_1 = require_type2();
  var index_1 = require_never2();
  var intersect_create_1 = require_intersect_create();
  var type_2 = require_type3();
  exports.Intersect = Intersect3;
});

// node_modules/@sinclair/typebox/build/require/type/intersect/index.js
var require_intersect2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_intersect_evaluated(), exports);
  __exportStar(require_intersect_type(), exports);
  __exportStar(require_intersect(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/union/union-create.js
var require_union_create = __commonJS((exports) => {
  var UnionCreate2 = function(T, options) {
    return { ...options, [index_1.Kind]: "Union", anyOf: (0, type_1.CloneRest)(T) };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionCreate = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.UnionCreate = UnionCreate2;
});

// node_modules/@sinclair/typebox/build/require/type/union/union-evaluated.js
var require_union_evaluated = __commonJS((exports) => {
  var IsUnionOptional2 = function(T) {
    return T.some((L) => (0, type_2.IsOptional)(L));
  };
  var RemoveOptionalFromRest3 = function(T) {
    return T.map((L) => (0, type_2.IsOptional)(L) ? RemoveOptionalFromType3(L) : L);
  };
  var RemoveOptionalFromType3 = function(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  };
  var ResolveUnion2 = function(T, options) {
    return IsUnionOptional2(T) ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest3(T), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest3(T), options);
  };
  var UnionEvaluated2 = function(T, options = {}) {
    return T.length === 0 ? (0, index_3.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : ResolveUnion2(T, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionEvaluated = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never2();
  var index_4 = require_optional2();
  var union_create_1 = require_union_create();
  var type_2 = require_type3();
  exports.UnionEvaluated = UnionEvaluated2;
});

// node_modules/@sinclair/typebox/build/require/type/union/union-type.js
var require_union_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/require/type/union/union.js
var require_union = __commonJS((exports) => {
  var Union3 = function(T, options = {}) {
    return T.length === 0 ? (0, index_1.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : (0, union_create_1.UnionCreate)(T, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Union = undefined;
  var index_1 = require_never2();
  var type_1 = require_type2();
  var union_create_1 = require_union_create();
  exports.Union = Union3;
});

// node_modules/@sinclair/typebox/build/require/type/union/index.js
var require_union2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_union_evaluated(), exports);
  __exportStar(require_union_type(), exports);
  __exportStar(require_union(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/parse.js
var require_parse2 = __commonJS((exports) => {
  var Unescape2 = function(pattern3) {
    return pattern3.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  };
  var IsNonEscaped2 = function(pattern3, index, char) {
    return pattern3[index] === char && pattern3.charCodeAt(index - 1) !== 92;
  };
  var IsOpenParen2 = function(pattern3, index) {
    return IsNonEscaped2(pattern3, index, "(");
  };
  var IsCloseParen2 = function(pattern3, index) {
    return IsNonEscaped2(pattern3, index, ")");
  };
  var IsSeparator2 = function(pattern3, index) {
    return IsNonEscaped2(pattern3, index, "|");
  };
  var IsGroup2 = function(pattern3) {
    if (!(IsOpenParen2(pattern3, 0) && IsCloseParen2(pattern3, pattern3.length - 1)))
      return false;
    let count = 0;
    for (let index = 0;index < pattern3.length; index++) {
      if (IsOpenParen2(pattern3, index))
        count += 1;
      if (IsCloseParen2(pattern3, index))
        count -= 1;
      if (count === 0 && index !== pattern3.length - 1)
        return false;
    }
    return true;
  };
  var InGroup2 = function(pattern3) {
    return pattern3.slice(1, pattern3.length - 1);
  };
  var IsPrecedenceOr2 = function(pattern3) {
    let count = 0;
    for (let index = 0;index < pattern3.length; index++) {
      if (IsOpenParen2(pattern3, index))
        count += 1;
      if (IsCloseParen2(pattern3, index))
        count -= 1;
      if (IsSeparator2(pattern3, index) && count === 0)
        return true;
    }
    return false;
  };
  var IsPrecedenceAnd2 = function(pattern3) {
    for (let index = 0;index < pattern3.length; index++) {
      if (IsOpenParen2(pattern3, index))
        return true;
    }
    return false;
  };
  var Or2 = function(pattern3) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index = 0;index < pattern3.length; index++) {
      if (IsOpenParen2(pattern3, index))
        count += 1;
      if (IsCloseParen2(pattern3, index))
        count -= 1;
      if (IsSeparator2(pattern3, index) && count === 0) {
        const range2 = pattern3.slice(start, index);
        if (range2.length > 0)
          expressions.push(TemplateLiteralParse2(range2));
        start = index + 1;
      }
    }
    const range = pattern3.slice(start);
    if (range.length > 0)
      expressions.push(TemplateLiteralParse2(range));
    if (expressions.length === 0)
      return { type: "const", const: "" };
    if (expressions.length === 1)
      return expressions[0];
    return { type: "or", expr: expressions };
  };
  var And2 = function(pattern3) {
    function Group(value15, index) {
      if (!IsOpenParen2(value15, index))
        throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
      let count = 0;
      for (let scan = index;scan < value15.length; scan++) {
        if (IsOpenParen2(value15, scan))
          count += 1;
        if (IsCloseParen2(value15, scan))
          count -= 1;
        if (count === 0)
          return [index, scan];
      }
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern4, index) {
      for (let scan = index;scan < pattern4.length; scan++) {
        if (IsOpenParen2(pattern4, scan))
          return [index, scan];
      }
      return [index, pattern4.length];
    }
    const expressions = [];
    for (let index = 0;index < pattern3.length; index++) {
      if (IsOpenParen2(pattern3, index)) {
        const [start, end] = Group(pattern3, index);
        const range = pattern3.slice(start, end + 1);
        expressions.push(TemplateLiteralParse2(range));
        index = end;
      } else {
        const [start, end] = Range(pattern3, index);
        const range = pattern3.slice(start, end);
        if (range.length > 0)
          expressions.push(TemplateLiteralParse2(range));
        index = end - 1;
      }
    }
    return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
  };
  var TemplateLiteralParse2 = function(pattern3) {
    return IsGroup2(pattern3) ? TemplateLiteralParse2(InGroup2(pattern3)) : IsPrecedenceOr2(pattern3) ? Or2(pattern3) : IsPrecedenceAnd2(pattern3) ? And2(pattern3) : { type: "const", const: Unescape2(pattern3) };
  };
  var TemplateLiteralParseExact2 = function(pattern3) {
    return TemplateLiteralParse2(pattern3.slice(1, pattern3.length - 1));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralParseExact = exports.TemplateLiteralParse = exports.TemplateLiteralParserError = undefined;
  var index_1 = require_error2();

  class TemplateLiteralParserError2 extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError2;
  exports.TemplateLiteralParse = TemplateLiteralParse2;
  exports.TemplateLiteralParseExact = TemplateLiteralParseExact2;
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/finite.js
var require_finite = __commonJS((exports) => {
  var IsNumberExpression2 = function(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
  };
  var IsBooleanExpression2 = function(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
  };
  var IsStringExpression2 = function(expression) {
    return expression.type === "const" && expression.const === ".*";
  };
  var IsTemplateLiteralExpressionFinite2 = function(expression) {
    return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
      throw new TemplateLiteralFiniteError2(`Unknown expression type`);
    })();
  };
  var IsTemplateLiteralFinite2 = function(schema3) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema3.pattern);
    return IsTemplateLiteralExpressionFinite2(expression);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsTemplateLiteralFinite = exports.IsTemplateLiteralExpressionFinite = exports.TemplateLiteralFiniteError = undefined;
  var parse_1 = require_parse2();
  var index_1 = require_error2();

  class TemplateLiteralFiniteError2 extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError2;
  exports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite2;
  exports.IsTemplateLiteralFinite = IsTemplateLiteralFinite2;
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/generate.js
var require_generate = __commonJS((exports) => {
  function* GenerateReduce2(buffer) {
    if (buffer.length === 1)
      return yield* buffer[0];
    for (const left of buffer[0]) {
      for (const right of GenerateReduce2(buffer.slice(1))) {
        yield `${left}${right}`;
      }
    }
  }
  function* GenerateAnd2(expression) {
    return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
  }
  function* GenerateOr2(expression) {
    for (const expr of expression.expr)
      yield* TemplateLiteralExpressionGenerate2(expr);
  }
  function* GenerateConst2(expression) {
    return yield expression.const;
  }
  function* TemplateLiteralExpressionGenerate2(expression) {
    return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
      throw new TemplateLiteralGenerateError2("Unknown expression");
    })();
  }
  var TemplateLiteralGenerate2 = function(schema3) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema3.pattern);
    return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralGenerate = exports.TemplateLiteralExpressionGenerate = exports.TemplateLiteralGenerateError = undefined;
  var finite_1 = require_finite();
  var parse_1 = require_parse2();
  var index_1 = require_error2();

  class TemplateLiteralGenerateError2 extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralGenerateError = TemplateLiteralGenerateError2;
  exports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate2;
  exports.TemplateLiteralGenerate = TemplateLiteralGenerate2;
});

// node_modules/@sinclair/typebox/build/require/type/literal/literal.js
var require_literal = __commonJS((exports) => {
  var Literal2 = function(value15, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Literal",
      const: value15,
      type: typeof value15
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Literal = undefined;
  var index_1 = require_symbols2();
  exports.Literal = Literal2;
});

// node_modules/@sinclair/typebox/build/require/type/literal/index.js
var require_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_literal(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/boolean/boolean.js
var require_boolean = __commonJS((exports) => {
  var Boolean2 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Boolean",
      type: "boolean"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Boolean = undefined;
  var index_1 = require_symbols2();
  exports.Boolean = Boolean2;
});

// node_modules/@sinclair/typebox/build/require/type/boolean/index.js
var require_boolean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_boolean(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/bigint/bigint.js
var require_bigint = __commonJS((exports) => {
  var BigInt3 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "BigInt",
      type: "bigint"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BigInt = undefined;
  var index_1 = require_symbols2();
  exports.BigInt = BigInt3;
});

// node_modules/@sinclair/typebox/build/require/type/bigint/index.js
var require_bigint2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_bigint(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/number/number.js
var require_number = __commonJS((exports) => {
  var Number3 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Number",
      type: "number"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Number = undefined;
  var index_1 = require_symbols2();
  exports.Number = Number3;
});

// node_modules/@sinclair/typebox/build/require/type/number/index.js
var require_number2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_number(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/string/string.js
var require_string = __commonJS((exports) => {
  var String3 = function(options = {}) {
    return { ...options, [index_1.Kind]: "String", type: "string" };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.String = undefined;
  var index_1 = require_symbols2();
  exports.String = String3;
});

// node_modules/@sinclair/typebox/build/require/type/string/index.js
var require_string2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_string(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/syntax.js
var require_syntax = __commonJS((exports) => {
  function* FromUnion20(syntax3) {
    const trim = syntax3.trim().replace(/"|'/g, "");
    return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
      const literals = trim.split("|").map((literal14) => (0, index_1.Literal)(literal14.trim()));
      return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
    })();
  }
  function* FromTerminal2(syntax3) {
    if (syntax3[1] !== "{") {
      const L = (0, index_1.Literal)("$");
      const R = FromSyntax2(syntax3.slice(1));
      return yield* [L, ...R];
    }
    for (let i = 2;i < syntax3.length; i++) {
      if (syntax3[i] === "}") {
        const L = FromUnion20(syntax3.slice(2, i));
        const R = FromSyntax2(syntax3.slice(i + 1));
        return yield* [...L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax3);
  }
  function* FromSyntax2(syntax3) {
    for (let i = 0;i < syntax3.length; i++) {
      if (syntax3[i] === "$") {
        const L = (0, index_1.Literal)(syntax3.slice(0, i));
        const R = FromTerminal2(syntax3.slice(i));
        return yield* [L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax3);
  }
  var TemplateLiteralSyntax2 = function(syntax3) {
    return [...FromSyntax2(syntax3)];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralSyntax = undefined;
  var index_1 = require_literal2();
  var index_2 = require_boolean2();
  var index_3 = require_bigint2();
  var index_4 = require_number2();
  var index_5 = require_string2();
  var index_6 = require_union2();
  var index_7 = require_never2();
  exports.TemplateLiteralSyntax = TemplateLiteralSyntax2;
});

// node_modules/@sinclair/typebox/build/require/type/patterns/patterns.js
var require_patterns = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = undefined;
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}\$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}\$`;
  exports.PatternStringExact = `^${exports.PatternString}\$`;
});

// node_modules/@sinclair/typebox/build/require/type/patterns/index.js
var require_patterns2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_patterns(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/pattern.js
var require_pattern = __commonJS((exports) => {
  var Escape3 = function(value15) {
    return value15.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  };
  var Visit17 = function(schema3, acc) {
    return (0, type_1.IsTemplateLiteral)(schema3) ? schema3.pattern.slice(1, schema3.pattern.length - 1) : (0, type_1.IsUnion)(schema3) ? `(${schema3.anyOf.map((schema4) => Visit17(schema4, acc)).join("|")})` : (0, type_1.IsNumber)(schema3) ? `${acc}${index_1.PatternNumber}` : (0, type_1.IsInteger)(schema3) ? `${acc}${index_1.PatternNumber}` : (0, type_1.IsBigInt)(schema3) ? `${acc}${index_1.PatternNumber}` : (0, type_1.IsString)(schema3) ? `${acc}${index_1.PatternString}` : (0, type_1.IsLiteral)(schema3) ? `${acc}${Escape3(schema3.const.toString())}` : (0, type_1.IsBoolean)(schema3) ? `${acc}${index_1.PatternBoolean}` : (() => {
      throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema3[index_2.Kind]}'`);
    })();
  };
  var TemplateLiteralPattern2 = function(kinds) {
    return `^${kinds.map((schema3) => Visit17(schema3, "")).join("")}$`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = undefined;
  var index_1 = require_patterns2();
  var index_2 = require_symbols2();
  var index_3 = require_error2();
  var type_1 = require_type3();

  class TemplateLiteralPatternError2 extends index_3.TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError2;
  exports.TemplateLiteralPattern = TemplateLiteralPattern2;
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/union.js
var require_union3 = __commonJS((exports) => {
  var TemplateLiteralToUnion2 = function(schema3) {
    const R = (0, generate_1.TemplateLiteralGenerate)(schema3);
    const L = R.map((S) => (0, index_2.Literal)(S));
    return (0, index_1.UnionEvaluated)(L);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralToUnion = undefined;
  var index_1 = require_union2();
  var index_2 = require_literal2();
  var generate_1 = require_generate();
  exports.TemplateLiteralToUnion = TemplateLiteralToUnion2;
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/template-literal.js
var require_template_literal = __commonJS((exports) => {
  var TemplateLiteral2 = function(unresolved, options = {}) {
    const pattern3 = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
    return { ...options, [index_1.Kind]: "TemplateLiteral", type: "string", pattern: pattern3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteral = undefined;
  var syntax_1 = require_syntax();
  var pattern_1 = require_pattern();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  exports.TemplateLiteral = TemplateLiteral2;
});

// node_modules/@sinclair/typebox/build/require/type/template-literal/index.js
var require_template_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_finite(), exports);
  __exportStar(require_generate(), exports);
  __exportStar(require_syntax(), exports);
  __exportStar(require_parse2(), exports);
  __exportStar(require_pattern(), exports);
  __exportStar(require_union3(), exports);
  __exportStar(require_template_literal(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/indexed/indexed-property-keys.js
var require_indexed_property_keys = __commonJS((exports) => {
  var FromTemplateLiteral7 = function(T) {
    const R = (0, index_1.TemplateLiteralGenerate)(T);
    return R.map((S) => S.toString());
  };
  var FromUnion20 = function(T) {
    return T.reduce((Acc, L) => {
      return [...Acc, ...IndexPropertyKeys2(L)];
    }, []);
  };
  var FromLiteral7 = function(T) {
    return [T.toString()];
  };
  var IndexPropertyKeys2 = function(T) {
    return [...new Set((0, type_1.IsTemplateLiteral)(T) ? FromTemplateLiteral7(T) : (0, type_1.IsUnion)(T) ? FromUnion20(T.anyOf) : (0, type_1.IsLiteral)(T) ? FromLiteral7(T.const) : (0, type_1.IsNumber)(T) ? ["[number]"] : (0, type_1.IsInteger)(T) ? ["[number]"] : [])];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexPropertyKeys = undefined;
  var index_1 = require_template_literal2();
  var type_1 = require_type3();
  exports.IndexPropertyKeys = IndexPropertyKeys2;
});

// node_modules/@sinclair/typebox/build/require/type/indexed/indexed-from-mapped-result.js
var require_indexed_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(T, P, options) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, index_2.Index)(T, (0, indexed_property_keys_1.IndexPropertyKeys)(P[K2]), options) };
    }, {});
  };
  var FromMappedResult13 = function(T, R, options) {
    return FromProperties20(T, R.properties, options);
  };
  var IndexFromMappedResult2 = function(T, R, options) {
    const P = FromMappedResult13(T, R, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var index_2 = require_indexed2();
  exports.IndexFromMappedResult = IndexFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/indexed/indexed.js
var require_indexed = __commonJS((exports) => {
  var FromRest9 = function(T, K) {
    return T.map((L) => IndexFromPropertyKey2(L, K));
  };
  var FromIntersectRest2 = function(T) {
    return T.filter((L) => !(0, type_2.IsNever)(L));
  };
  var FromIntersect18 = function(T, K) {
    return (0, index_2.IntersectEvaluated)(FromIntersectRest2(FromRest9(T, K)));
  };
  var FromUnionRest2 = function(T) {
    return T.some((L) => (0, type_2.IsNever)(L)) ? [] : T;
  };
  var FromUnion20 = function(T, K) {
    return (0, index_3.UnionEvaluated)(FromUnionRest2(FromRest9(T, K)));
  };
  var FromTuple15 = function(T, K) {
    return K in T ? T[K] : K === "[number]" ? (0, index_3.UnionEvaluated)(T) : (0, index_1.Never)();
  };
  var FromArray16 = function(T, K) {
    return K === "[number]" ? T : (0, index_1.Never)();
  };
  var FromProperty3 = function(T, K) {
    return K in T ? T[K] : (0, index_1.Never)();
  };
  var IndexFromPropertyKey2 = function(T, K) {
    return (0, type_2.IsIntersect)(T) ? FromIntersect18(T.allOf, K) : (0, type_2.IsUnion)(T) ? FromUnion20(T.anyOf, K) : (0, type_2.IsTuple)(T) ? FromTuple15(T.items ?? [], K) : (0, type_2.IsArray)(T) ? FromArray16(T.items, K) : (0, type_2.IsObject)(T) ? FromProperty3(T.properties, K) : (0, index_1.Never)();
  };
  var IndexFromPropertyKeys2 = function(T, K) {
    return K.map((L) => IndexFromPropertyKey2(T, L));
  };
  var FromSchema2 = function(T, K) {
    return (0, index_3.UnionEvaluated)(IndexFromPropertyKeys2(T, K));
  };
  var Index2 = function(T, K, options = {}) {
    return (0, type_2.IsMappedResult)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_result_1.IndexFromMappedResult)(T, K, options)) : (0, type_2.IsMappedKey)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_key_1.IndexFromMappedKey)(T, K, options)) : (0, type_2.IsSchema)(K) ? (0, type_1.CloneType)(FromSchema2(T, (0, indexed_property_keys_1.IndexPropertyKeys)(K)), options) : (0, type_1.CloneType)(FromSchema2(T, K), options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Index = exports.IndexFromPropertyKeys = exports.IndexFromPropertyKey = undefined;
  var index_1 = require_never2();
  var index_2 = require_intersect2();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var indexed_from_mapped_key_1 = require_indexed_from_mapped_key();
  var indexed_from_mapped_result_1 = require_indexed_from_mapped_result();
  var type_2 = require_type3();
  exports.IndexFromPropertyKey = IndexFromPropertyKey2;
  exports.IndexFromPropertyKeys = IndexFromPropertyKeys2;
  exports.Index = Index2;
});

// node_modules/@sinclair/typebox/build/require/type/indexed/indexed-from-mapped-key.js
var require_indexed_from_mapped_key = __commonJS((exports) => {
  var MappedIndexPropertyKey2 = function(T, K, options) {
    return { [K]: (0, indexed_1.Index)(T, [K], options) };
  };
  var MappedIndexPropertyKeys2 = function(T, K, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIndexPropertyKey2(T, L, options) };
    }, {});
  };
  var MappedIndexProperties2 = function(T, K, options) {
    return MappedIndexPropertyKeys2(T, K.keys, options);
  };
  var IndexFromMappedKey2 = function(T, K, options) {
    const P = MappedIndexProperties2(T, K, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedKey = undefined;
  var indexed_1 = require_indexed();
  var index_1 = require_mapped2();
  exports.IndexFromMappedKey = IndexFromMappedKey2;
});

// node_modules/@sinclair/typebox/build/require/type/indexed/index.js
var require_indexed2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_indexed_from_mapped_key(), exports);
  __exportStar(require_indexed_from_mapped_result(), exports);
  __exportStar(require_indexed_property_keys(), exports);
  __exportStar(require_indexed(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/iterator/iterator.js
var require_iterator = __commonJS((exports) => {
  var Iterator2 = function(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Iterator",
      type: "Iterator",
      items: (0, type_1.CloneType)(items)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Iterator = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.Iterator = Iterator2;
});

// node_modules/@sinclair/typebox/build/require/type/iterator/index.js
var require_iterator2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_iterator(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/object/object.js
var require_object = __commonJS((exports) => {
  var _Object2 = function(properties, options = {}) {
    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
    const optionalKeys = propertyKeys.filter((key) => (0, type_2.IsOptional)(properties[key]));
    const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
    const clonedAdditionalProperties = (0, type_2.IsSchema)(options.additionalProperties) ? { additionalProperties: (0, type_1.CloneType)(options.additionalProperties) } : {};
    const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: (0, type_1.CloneType)(properties[key]) }), {});
    return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Object = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var type_2 = require_type3();
  exports.Object = _Object2;
});

// node_modules/@sinclair/typebox/build/require/type/object/index.js
var require_object2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_object(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/promise/promise.js
var require_promise = __commonJS((exports) => {
  var Promise3 = function(item, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Promise",
      type: "Promise",
      item: (0, type_1.CloneType)(item)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Promise = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.Promise = Promise3;
});

// node_modules/@sinclair/typebox/build/require/type/promise/index.js
var require_promise2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_promise(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/readonly/readonly.js
var require_readonly = __commonJS((exports) => {
  var RemoveReadonly2 = function(schema3) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema3), [index_1.ReadonlyKind]);
  };
  var AddReadonly2 = function(schema3) {
    return { ...(0, type_1.CloneType)(schema3), [index_1.ReadonlyKind]: "Readonly" };
  };
  var ReadonlyWithFlag2 = function(schema3, F) {
    return F === false ? RemoveReadonly2(schema3) : AddReadonly2(schema3);
  };
  var Readonly2 = function(schema3, enable) {
    const F = enable ?? true;
    return (0, type_2.IsMappedResult)(schema3) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema3, F) : ReadonlyWithFlag2(schema3, F);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Readonly = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var readonly_from_mapped_result_1 = require_readonly_from_mapped_result();
  var type_2 = require_type3();
  exports.Readonly = Readonly2;
});

// node_modules/@sinclair/typebox/build/require/type/readonly/readonly-from-mapped-result.js
var require_readonly_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(K, F) {
    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, readonly_1.Readonly)(K[K2], F) };
    }, {});
  };
  var FromMappedResult13 = function(R, F) {
    return FromProperties20(R.properties, F);
  };
  var ReadonlyFromMappedResult2 = function(R, F) {
    const P = FromMappedResult13(R, F);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var readonly_1 = require_readonly();
  exports.ReadonlyFromMappedResult = ReadonlyFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/readonly/index.js
var require_readonly2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_from_mapped_result(), exports);
  __exportStar(require_readonly(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/tuple/tuple.js
var require_tuple = __commonJS((exports) => {
  var Tuple2 = function(items, options = {}) {
    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
    return items.length > 0 ? { ...options, [index_1.Kind]: "Tuple", type: "array", items: (0, type_1.CloneRest)(items), additionalItems, minItems, maxItems } : { ...options, [index_1.Kind]: "Tuple", type: "array", minItems, maxItems };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tuple = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.Tuple = Tuple2;
});

// node_modules/@sinclair/typebox/build/require/type/tuple/index.js
var require_tuple2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_tuple(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/sets/set.js
var require_set = __commonJS((exports) => {
  var SetIncludes2 = function(T, S) {
    return T.includes(S);
  };
  var SetIsSubset = function(T, S) {
    return T.every((L) => SetIncludes2(S, L));
  };
  var SetDistinct2 = function(T) {
    return [...new Set(T)];
  };
  var SetIntersect2 = function(T, S) {
    return T.filter((L) => S.includes(L));
  };
  var SetUnion = function(T, S) {
    return [...T, ...S];
  };
  var SetComplement = function(T, S) {
    return T.filter((L) => !S.includes(L));
  };
  var SetIntersectManyResolve2 = function(T, Init) {
    return T.reduce((Acc, L) => {
      return SetIntersect2(Acc, L);
    }, Init);
  };
  var SetIntersectMany2 = function(T) {
    return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve2(T.slice(1), T[0]) : [];
  };
  var SetUnionMany2 = function(T) {
    return T.reduce((Acc, L) => [...Acc, ...L], []);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetUnionMany = exports.SetIntersectMany = exports.SetComplement = exports.SetUnion = exports.SetIntersect = exports.SetDistinct = exports.SetIsSubset = exports.SetIncludes = undefined;
  exports.SetIncludes = SetIncludes2;
  exports.SetIsSubset = SetIsSubset;
  exports.SetDistinct = SetDistinct2;
  exports.SetIntersect = SetIntersect2;
  exports.SetUnion = SetUnion;
  exports.SetComplement = SetComplement;
  exports.SetIntersectMany = SetIntersectMany2;
  exports.SetUnionMany = SetUnionMany2;
});

// node_modules/@sinclair/typebox/build/require/type/sets/index.js
var require_sets = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_set(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/mapped/mapped.js
var require_mapped = __commonJS((exports) => {
  var FromMappedResult13 = function(K, P) {
    return K in P ? FromSchemaType2(K, P[K]) : (0, mapped_result_1.MappedResult)(P);
  };
  var MappedKeyToKnownMappedResultProperties2 = function(K) {
    return { [K]: (0, index_10.Literal)(K) };
  };
  var MappedKeyToUnknownMappedResultProperties2 = function(P) {
    return P.reduce((Acc, L) => {
      return { ...Acc, [L]: (0, index_10.Literal)(L) };
    }, {});
  };
  var MappedKeyToMappedResultProperties2 = function(K, P) {
    return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P);
  };
  var FromMappedKey5 = function(K, P) {
    const R = MappedKeyToMappedResultProperties2(K, P);
    return FromMappedResult13(K, R);
  };
  var FromRest9 = function(K, T) {
    return T.map((L) => FromSchemaType2(K, L));
  };
  var FromProperties20 = function(K, T) {
    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
      return { ...Acc, [K2]: FromSchemaType2(K, T[K2]) };
    }, {});
  };
  var FromSchemaType2 = function(K, T) {
    return (0, type_2.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType2(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, type_2.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType2(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) : (0, type_2.IsMappedResult)(T) ? FromMappedResult13(K, T.properties) : (0, type_2.IsMappedKey)(T) ? FromMappedKey5(K, T.keys) : (0, type_2.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest9(K, T.parameters), FromSchemaType2(K, T.returns)) : (0, type_2.IsFunction)(T) ? (0, index_6.Function)(FromRest9(K, T.parameters), FromSchemaType2(K, T.returns)) : (0, type_2.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType2(K, T.items)) : (0, type_2.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType2(K, T.items)) : (0, type_2.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest9(K, T.allOf)) : (0, type_2.IsUnion)(T) ? (0, index_16.Union)(FromRest9(K, T.anyOf)) : (0, type_2.IsTuple)(T) ? (0, index_15.Tuple)(FromRest9(K, T.items ?? [])) : (0, type_2.IsObject)(T) ? (0, index_11.Object)(FromProperties20(K, T.properties)) : (0, type_2.IsArray)(T) ? (0, index_3.Array)(FromSchemaType2(K, T.items)) : (0, type_2.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType2(K, T.item)) : T;
  };
  var MappedFunctionReturnType2 = function(K, T, Acc = {}) {
    return K.reduce((Acc2, L) => {
      return { ...Acc2, [L]: FromSchemaType2(L, T) };
    }, {});
  };
  var Mapped2 = function(key, map3, options = {}) {
    const K = (0, type_2.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map3({ [index_1.Kind]: "MappedKey", keys: K });
    const R = MappedFunctionReturnType2(K, RT);
    return (0, type_1.CloneType)((0, index_11.Object)(R), options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Mapped = exports.MappedFunctionReturnType = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_array2();
  var index_4 = require_async_iterator2();
  var index_5 = require_constructor2();
  var index_6 = require_function2();
  var index_7 = require_indexed2();
  var index_8 = require_intersect2();
  var index_9 = require_iterator2();
  var index_10 = require_literal2();
  var index_11 = require_object2();
  var index_12 = require_optional2();
  var index_13 = require_promise2();
  var index_14 = require_readonly2();
  var index_15 = require_tuple2();
  var index_16 = require_union2();
  var index_17 = require_sets();
  var mapped_result_1 = require_mapped_result();
  var type_2 = require_type3();
  exports.MappedFunctionReturnType = MappedFunctionReturnType2;
  exports.Mapped = Mapped2;
});

// node_modules/@sinclair/typebox/build/require/type/mapped/index.js
var require_mapped2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mapped_key(), exports);
  __exportStar(require_mapped_result(), exports);
  __exportStar(require_mapped(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/keyof/keyof-property-keys.js
var require_keyof_property_keys = __commonJS((exports) => {
  var FromRest9 = function(T) {
    return T.reduce((Acc, L) => {
      return [...Acc, KeyOfPropertyKeys2(L)];
    }, []);
  };
  var FromIntersect18 = function(T) {
    const C = FromRest9(T);
    const R = (0, index_1.SetUnionMany)(C);
    return R;
  };
  var FromUnion20 = function(T) {
    const C = FromRest9(T);
    const R = (0, index_1.SetIntersectMany)(C);
    return R;
  };
  var FromTuple15 = function(T) {
    return T.map((_, I) => I.toString());
  };
  var FromArray16 = function(_) {
    return ["[number]"];
  };
  var FromProperties20 = function(T) {
    return globalThis.Object.getOwnPropertyNames(T);
  };
  var FromPatternProperties2 = function(patternProperties) {
    if (!includePatternProperties2)
      return [];
    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
    return patternPropertyKeys.map((key) => {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    });
  };
  var KeyOfPropertyKeys2 = function(T) {
    return (0, type_1.IsIntersect)(T) ? FromIntersect18(T.allOf) : (0, type_1.IsUnion)(T) ? FromUnion20(T.anyOf) : (0, type_1.IsTuple)(T) ? FromTuple15(T.items ?? []) : (0, type_1.IsArray)(T) ? FromArray16(T.items) : (0, type_1.IsObject)(T) ? FromProperties20(T.properties) : (0, type_1.IsRecord)(T) ? FromPatternProperties2(T.patternProperties) : [];
  };
  var KeyOfPattern2 = function(schema3) {
    includePatternProperties2 = true;
    const keys = KeyOfPropertyKeys2(schema3);
    includePatternProperties2 = false;
    const pattern3 = keys.map((key) => `(${key})`);
    return `^(${pattern3.join("|")})\$`;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPattern = exports.KeyOfPropertyKeys = undefined;
  var index_1 = require_sets();
  var type_1 = require_type3();
  exports.KeyOfPropertyKeys = KeyOfPropertyKeys2;
  var includePatternProperties2 = false;
  exports.KeyOfPattern = KeyOfPattern2;
});

// node_modules/@sinclair/typebox/build/require/type/keyof/keyof.js
var require_keyof = __commonJS((exports) => {
  var KeyOfPropertyKeysToRest2 = function(T) {
    return T.map((L) => L === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L));
  };
  var KeyOf2 = function(T, options = {}) {
    if ((0, type_2.IsMappedResult)(T)) {
      return (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(T, options);
    } else {
      const K = (0, keyof_property_keys_1.KeyOfPropertyKeys)(T);
      const S = KeyOfPropertyKeysToRest2(K);
      const U = (0, index_3.UnionEvaluated)(S);
      return (0, type_1.CloneType)(U, options);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOf = exports.KeyOfPropertyKeysToRest = undefined;
  var index_1 = require_literal2();
  var index_2 = require_number2();
  var keyof_property_keys_1 = require_keyof_property_keys();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var keyof_from_mapped_result_1 = require_keyof_from_mapped_result();
  var type_2 = require_type3();
  exports.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest2;
  exports.KeyOf = KeyOf2;
});

// node_modules/@sinclair/typebox/build/require/type/keyof/keyof-from-mapped-result.js
var require_keyof_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(K, options) {
    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, keyof_1.KeyOf)(K[K2], options) };
    }, {});
  };
  var FromMappedResult13 = function(R, options) {
    return FromProperties20(R.properties, options);
  };
  var KeyOfFromMappedResult2 = function(R, options) {
    const P = FromMappedResult13(R, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var keyof_1 = require_keyof();
  exports.KeyOfFromMappedResult = KeyOfFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/keyof/index.js
var require_keyof2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_keyof_from_mapped_result(), exports);
  __exportStar(require_keyof_property_keys(), exports);
  __exportStar(require_keyof(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/extends/extends-undefined.js
var require_extends_undefined = __commonJS((exports) => {
  var Intersect3 = function(schema3) {
    return schema3.allOf.every((schema4) => ExtendsUndefinedCheck2(schema4));
  };
  var Union3 = function(schema3) {
    return schema3.anyOf.some((schema4) => ExtendsUndefinedCheck2(schema4));
  };
  var Not3 = function(schema3) {
    return !ExtendsUndefinedCheck2(schema3.not);
  };
  var ExtendsUndefinedCheck2 = function(schema3) {
    return schema3[index_1.Kind] === "Intersect" ? Intersect3(schema3) : schema3[index_1.Kind] === "Union" ? Union3(schema3) : schema3[index_1.Kind] === "Not" ? Not3(schema3) : schema3[index_1.Kind] === "Undefined" ? true : false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsUndefinedCheck = undefined;
  var index_1 = require_symbols2();
  exports.ExtendsUndefinedCheck = ExtendsUndefinedCheck2;
});

// node_modules/@sinclair/typebox/build/require/errors/function.js
var require_function3 = __commonJS((exports) => {
  var DefaultErrorFunction2 = function(error23) {
    switch (error23.errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${error23.schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${error23.schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${error23.schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${error23.schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${error23.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${error23.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${error23.schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${error23.schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${error23.schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${error23.schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${error23.schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${error23.schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${error23.schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${error23.schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${error23.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${error23.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${error23.schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${error23.schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${error23.schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof error23.schema.const === "string" ? `'${error23.schema.const}'` : error23.schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${error23.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${error23.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${error23.schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${error23.schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${error23.schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${error23.schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${error23.schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.RegExp:
        return "Expected string to match regular expression";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${error23.schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${error23.schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${error23.schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${error23.schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${error23.schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${error23.schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${error23.schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${error23.schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${error23.schema[index_1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  var SetErrorFunction = function(callback) {
    errorFunction2 = callback;
  };
  var GetErrorFunction2 = function() {
    return errorFunction2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GetErrorFunction = exports.SetErrorFunction = exports.DefaultErrorFunction = undefined;
  var index_1 = require_symbols2();
  var errors_1 = require_errors();
  exports.DefaultErrorFunction = DefaultErrorFunction2;
  var errorFunction2 = DefaultErrorFunction2;
  exports.SetErrorFunction = SetErrorFunction;
  exports.GetErrorFunction = GetErrorFunction2;
});

// node_modules/@sinclair/typebox/build/require/value/deref/deref.js
var require_deref = __commonJS((exports) => {
  var Deref3 = function(schema3, references) {
    const index = references.findIndex((target) => target.$id === schema3.$ref);
    if (index === -1)
      throw new TypeDereferenceError2(schema3);
    return references[index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deref = exports.TypeDereferenceError = undefined;
  var index_1 = require_error2();

  class TypeDereferenceError2 extends index_1.TypeBoxError {
    constructor(schema3) {
      super(`Unable to dereference schema with \$id '${schema3.$id}'`);
      this.schema = schema3;
    }
  }
  exports.TypeDereferenceError = TypeDereferenceError2;
  exports.Deref = Deref3;
});

// node_modules/@sinclair/typebox/build/require/value/deref/index.js
var require_deref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deref(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/hash/hash.js
var require_hash = __commonJS((exports) => {
  function* NumberToBytes2(value15) {
    const byteCount = value15 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value15) + 1) / 8);
    for (let i = 0;i < byteCount; i++) {
      yield value15 >> 8 * (byteCount - 1 - i) & 255;
    }
  }
  var ArrayType7 = function(value15) {
    FNV1A642(ByteMarker2.Array);
    for (const item of value15) {
      Visit17(item);
    }
  };
  var BooleanType2 = function(value15) {
    FNV1A642(ByteMarker2.Boolean);
    FNV1A642(value15 ? 1 : 0);
  };
  var BigIntType2 = function(value15) {
    FNV1A642(ByteMarker2.BigInt);
    F64In2.setBigInt64(0, value15);
    for (const byte2 of F64Out2) {
      FNV1A642(byte2);
    }
  };
  var DateType5 = function(value15) {
    FNV1A642(ByteMarker2.Date);
    Visit17(value15.getTime());
  };
  var NullType2 = function(value15) {
    FNV1A642(ByteMarker2.Null);
  };
  var NumberType2 = function(value15) {
    FNV1A642(ByteMarker2.Number);
    F64In2.setFloat64(0, value15);
    for (const byte2 of F64Out2) {
      FNV1A642(byte2);
    }
  };
  var ObjectType7 = function(value15) {
    FNV1A642(ByteMarker2.Object);
    for (const key of globalThis.Object.keys(value15).sort()) {
      Visit17(key);
      Visit17(value15[key]);
    }
  };
  var StringType2 = function(value15) {
    FNV1A642(ByteMarker2.String);
    for (let i = 0;i < value15.length; i++) {
      for (const byte2 of NumberToBytes2(value15.charCodeAt(i))) {
        FNV1A642(byte2);
      }
    }
  };
  var SymbolType2 = function(value15) {
    FNV1A642(ByteMarker2.Symbol);
    Visit17(value15.description);
  };
  var Uint8ArrayType3 = function(value15) {
    FNV1A642(ByteMarker2.Uint8Array);
    for (let i = 0;i < value15.length; i++) {
      FNV1A642(value15[i]);
    }
  };
  var UndefinedType2 = function(value15) {
    return FNV1A642(ByteMarker2.Undefined);
  };
  var Visit17 = function(value15) {
    if ((0, index_1.IsArray)(value15))
      return ArrayType7(value15);
    if ((0, index_1.IsBoolean)(value15))
      return BooleanType2(value15);
    if ((0, index_1.IsBigInt)(value15))
      return BigIntType2(value15);
    if ((0, index_1.IsDate)(value15))
      return DateType5(value15);
    if ((0, index_1.IsNull)(value15))
      return NullType2(value15);
    if ((0, index_1.IsNumber)(value15))
      return NumberType2(value15);
    if ((0, index_1.IsStandardObject)(value15))
      return ObjectType7(value15);
    if ((0, index_1.IsString)(value15))
      return StringType2(value15);
    if ((0, index_1.IsSymbol)(value15))
      return SymbolType2(value15);
    if ((0, index_1.IsUint8Array)(value15))
      return Uint8ArrayType3(value15);
    if ((0, index_1.IsUndefined)(value15))
      return UndefinedType2(value15);
    throw new ValueHashError2(value15);
  };
  var FNV1A642 = function(byte2) {
    Accumulator2 = Accumulator2 ^ Bytes2[byte2];
    Accumulator2 = Accumulator2 * Prime2 % Size2;
  };
  var Hash3 = function(value15) {
    Accumulator2 = BigInt("14695981039346656037");
    Visit17(value15);
    return Accumulator2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash = exports.ValueHashError = undefined;
  var index_1 = require_guard2();
  var index_2 = require_error2();

  class ValueHashError2 extends index_2.TypeBoxError {
    constructor(value15) {
      super(`Unable to hash value`);
      this.value = value15;
    }
  }
  exports.ValueHashError = ValueHashError2;
  var ByteMarker2;
  (function(ByteMarker3) {
    ByteMarker3[ByteMarker3["Undefined"] = 0] = "Undefined";
    ByteMarker3[ByteMarker3["Null"] = 1] = "Null";
    ByteMarker3[ByteMarker3["Boolean"] = 2] = "Boolean";
    ByteMarker3[ByteMarker3["Number"] = 3] = "Number";
    ByteMarker3[ByteMarker3["String"] = 4] = "String";
    ByteMarker3[ByteMarker3["Object"] = 5] = "Object";
    ByteMarker3[ByteMarker3["Array"] = 6] = "Array";
    ByteMarker3[ByteMarker3["Date"] = 7] = "Date";
    ByteMarker3[ByteMarker3["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker3[ByteMarker3["Symbol"] = 9] = "Symbol";
    ByteMarker3[ByteMarker3["BigInt"] = 10] = "BigInt";
  })(ByteMarker2 || (ByteMarker2 = {}));
  var Accumulator2 = BigInt("14695981039346656037");
  var [Prime2, Size2] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
  var Bytes2 = Array.from({ length: 256 }).map((_, i) => BigInt(i));
  var F642 = new Float64Array(1);
  var F64In2 = new DataView(F642.buffer);
  var F64Out2 = new Uint8Array(F642.buffer);
  exports.Hash = Hash3;
});

// node_modules/@sinclair/typebox/build/require/value/hash/index.js
var require_hash2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_hash(), exports);
});

// node_modules/@sinclair/typebox/build/require/errors/errors.js
var require_errors = __commonJS((exports) => {
  var EscapeKey2 = function(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  };
  var IsDefined3 = function(value15) {
    return value15 !== undefined;
  };
  var Create4 = function(errorType, schema3, path, value15) {
    return { type: errorType, schema: schema3, path, value: value15, message: (0, function_1.GetErrorFunction)()({ errorType, path, schema: schema3, value: value15 }) };
  };
  function* FromAny5(schema3, references, path, value15) {
  }
  function* FromArray16(schema3, references, path, value15) {
    if (!(0, index_9.IsArray)(value15)) {
      return yield Create4(ValueErrorType2.Array, schema3, path, value15);
    }
    if (IsDefined3(schema3.minItems) && !(value15.length >= schema3.minItems)) {
      yield Create4(ValueErrorType2.ArrayMinItems, schema3, path, value15);
    }
    if (IsDefined3(schema3.maxItems) && !(value15.length <= schema3.maxItems)) {
      yield Create4(ValueErrorType2.ArrayMaxItems, schema3, path, value15);
    }
    for (let i = 0;i < value15.length; i++) {
      yield* Visit17(schema3.items, references, `${path}/${i}`, value15[i]);
    }
    if (schema3.uniqueItems === true && !function() {
      const set2 = new Set;
      for (const element of value15) {
        const hashed = (0, index_6.Hash)(element);
        if (set2.has(hashed)) {
          return false;
        } else {
          set2.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create4(ValueErrorType2.ArrayUniqueItems, schema3, path, value15);
    }
    if (!(IsDefined3(schema3.contains) || IsDefined3(schema3.minContains) || IsDefined3(schema3.maxContains))) {
      return;
    }
    const containsSchema = IsDefined3(schema3.contains) ? schema3.contains : (0, index_8.Never)();
    const containsCount = value15.reduce((acc, value16, index) => Visit17(containsSchema, references, `${path}${index}`, value16).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create4(ValueErrorType2.ArrayContains, schema3, path, value15);
    }
    if ((0, index_9.IsNumber)(schema3.minContains) && containsCount < schema3.minContains) {
      yield Create4(ValueErrorType2.ArrayMinContains, schema3, path, value15);
    }
    if ((0, index_9.IsNumber)(schema3.maxContains) && containsCount > schema3.maxContains) {
      yield Create4(ValueErrorType2.ArrayMaxContains, schema3, path, value15);
    }
  }
  function* FromAsyncIterator7(schema3, references, path, value15) {
    if (!(0, index_9.IsAsyncIterator)(value15))
      yield Create4(ValueErrorType2.AsyncIterator, schema3, path, value15);
  }
  function* FromBigInt6(schema3, references, path, value15) {
    if (!(0, index_9.IsBigInt)(value15))
      return yield Create4(ValueErrorType2.BigInt, schema3, path, value15);
    if (IsDefined3(schema3.exclusiveMaximum) && !(value15 < schema3.exclusiveMaximum)) {
      yield Create4(ValueErrorType2.BigIntExclusiveMaximum, schema3, path, value15);
    }
    if (IsDefined3(schema3.exclusiveMinimum) && !(value15 > schema3.exclusiveMinimum)) {
      yield Create4(ValueErrorType2.BigIntExclusiveMinimum, schema3, path, value15);
    }
    if (IsDefined3(schema3.maximum) && !(value15 <= schema3.maximum)) {
      yield Create4(ValueErrorType2.BigIntMaximum, schema3, path, value15);
    }
    if (IsDefined3(schema3.minimum) && !(value15 >= schema3.minimum)) {
      yield Create4(ValueErrorType2.BigIntMinimum, schema3, path, value15);
    }
    if (IsDefined3(schema3.multipleOf) && !(value15 % schema3.multipleOf === BigInt(0))) {
      yield Create4(ValueErrorType2.BigIntMultipleOf, schema3, path, value15);
    }
  }
  function* FromBoolean6(schema3, references, path, value15) {
    if (!(0, index_9.IsBoolean)(value15))
      yield Create4(ValueErrorType2.Boolean, schema3, path, value15);
  }
  function* FromConstructor8(schema3, references, path, value15) {
    yield* Visit17(schema3.returns, references, path, value15.prototype);
  }
  function* FromDate6(schema3, references, path, value15) {
    if (!(0, index_9.IsDate)(value15))
      return yield Create4(ValueErrorType2.Date, schema3, path, value15);
    if (IsDefined3(schema3.exclusiveMaximumTimestamp) && !(value15.getTime() < schema3.exclusiveMaximumTimestamp)) {
      yield Create4(ValueErrorType2.DateExclusiveMaximumTimestamp, schema3, path, value15);
    }
    if (IsDefined3(schema3.exclusiveMinimumTimestamp) && !(value15.getTime() > schema3.exclusiveMinimumTimestamp)) {
      yield Create4(ValueErrorType2.DateExclusiveMinimumTimestamp, schema3, path, value15);
    }
    if (IsDefined3(schema3.maximumTimestamp) && !(value15.getTime() <= schema3.maximumTimestamp)) {
      yield Create4(ValueErrorType2.DateMaximumTimestamp, schema3, path, value15);
    }
    if (IsDefined3(schema3.minimumTimestamp) && !(value15.getTime() >= schema3.minimumTimestamp)) {
      yield Create4(ValueErrorType2.DateMinimumTimestamp, schema3, path, value15);
    }
    if (IsDefined3(schema3.multipleOfTimestamp) && !(value15.getTime() % schema3.multipleOfTimestamp === 0)) {
      yield Create4(ValueErrorType2.DateMultipleOfTimestamp, schema3, path, value15);
    }
  }
  function* FromFunction7(schema3, references, path, value15) {
    if (!(0, index_9.IsFunction)(value15))
      yield Create4(ValueErrorType2.Function, schema3, path, value15);
  }
  function* FromInteger6(schema3, references, path, value15) {
    if (!(0, index_9.IsInteger)(value15))
      return yield Create4(ValueErrorType2.Integer, schema3, path, value15);
    if (IsDefined3(schema3.exclusiveMaximum) && !(value15 < schema3.exclusiveMaximum)) {
      yield Create4(ValueErrorType2.IntegerExclusiveMaximum, schema3, path, value15);
    }
    if (IsDefined3(schema3.exclusiveMinimum) && !(value15 > schema3.exclusiveMinimum)) {
      yield Create4(ValueErrorType2.IntegerExclusiveMinimum, schema3, path, value15);
    }
    if (IsDefined3(schema3.maximum) && !(value15 <= schema3.maximum)) {
      yield Create4(ValueErrorType2.IntegerMaximum, schema3, path, value15);
    }
    if (IsDefined3(schema3.minimum) && !(value15 >= schema3.minimum)) {
      yield Create4(ValueErrorType2.IntegerMinimum, schema3, path, value15);
    }
    if (IsDefined3(schema3.multipleOf) && !(value15 % schema3.multipleOf === 0)) {
      yield Create4(ValueErrorType2.IntegerMultipleOf, schema3, path, value15);
    }
  }
  function* FromIntersect18(schema3, references, path, value15) {
    for (const inner of schema3.allOf) {
      const next = Visit17(inner, references, path, value15).next();
      if (!next.done) {
        yield Create4(ValueErrorType2.Intersect, schema3, path, value15);
        yield next.value;
      }
    }
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema3));
      for (const valueKey of Object.getOwnPropertyNames(value15)) {
        if (!keyCheck.test(valueKey)) {
          yield Create4(ValueErrorType2.IntersectUnevaluatedProperties, schema3, `${path}/${valueKey}`, value15);
        }
      }
    }
    if (typeof schema3.unevaluatedProperties === "object") {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema3));
      for (const valueKey of Object.getOwnPropertyNames(value15)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit17(schema3.unevaluatedProperties, references, `${path}/${valueKey}`, value15[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* FromIterator7(schema3, references, path, value15) {
    if (!(0, index_9.IsIterator)(value15))
      yield Create4(ValueErrorType2.Iterator, schema3, path, value15);
  }
  function* FromLiteral7(schema3, references, path, value15) {
    if (!(value15 === schema3.const))
      yield Create4(ValueErrorType2.Literal, schema3, path, value15);
  }
  function* FromNever6(schema3, references, path, value15) {
    yield Create4(ValueErrorType2.Never, schema3, path, value15);
  }
  function* FromNot8(schema3, references, path, value15) {
    if (Visit17(schema3.not, references, path, value15).next().done === true)
      yield Create4(ValueErrorType2.Not, schema3, path, value15);
  }
  function* FromNull6(schema3, references, path, value15) {
    if (!(0, index_9.IsNull)(value15))
      yield Create4(ValueErrorType2.Null, schema3, path, value15);
  }
  function* FromNumber6(schema3, references, path, value15) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value15))
      return yield Create4(ValueErrorType2.Number, schema3, path, value15);
    if (IsDefined3(schema3.exclusiveMaximum) && !(value15 < schema3.exclusiveMaximum)) {
      yield Create4(ValueErrorType2.NumberExclusiveMaximum, schema3, path, value15);
    }
    if (IsDefined3(schema3.exclusiveMinimum) && !(value15 > schema3.exclusiveMinimum)) {
      yield Create4(ValueErrorType2.NumberExclusiveMinimum, schema3, path, value15);
    }
    if (IsDefined3(schema3.maximum) && !(value15 <= schema3.maximum)) {
      yield Create4(ValueErrorType2.NumberMaximum, schema3, path, value15);
    }
    if (IsDefined3(schema3.minimum) && !(value15 >= schema3.minimum)) {
      yield Create4(ValueErrorType2.NumberMinimum, schema3, path, value15);
    }
    if (IsDefined3(schema3.multipleOf) && !(value15 % schema3.multipleOf === 0)) {
      yield Create4(ValueErrorType2.NumberMultipleOf, schema3, path, value15);
    }
  }
  function* FromObject13(schema3, references, path, value15) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value15))
      return yield Create4(ValueErrorType2.Object, schema3, path, value15);
    if (IsDefined3(schema3.minProperties) && !(Object.getOwnPropertyNames(value15).length >= schema3.minProperties)) {
      yield Create4(ValueErrorType2.ObjectMinProperties, schema3, path, value15);
    }
    if (IsDefined3(schema3.maxProperties) && !(Object.getOwnPropertyNames(value15).length <= schema3.maxProperties)) {
      yield Create4(ValueErrorType2.ObjectMaxProperties, schema3, path, value15);
    }
    const requiredKeys = Array.isArray(schema3.required) ? schema3.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    const unknownKeys = Object.getOwnPropertyNames(value15);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create4(ValueErrorType2.ObjectRequiredProperty, schema3.properties[requiredKey], `${path}/${EscapeKey2(requiredKey)}`, undefined);
    }
    if (schema3.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema3, `${path}/${EscapeKey2(valueKey)}`, value15[valueKey]);
        }
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit17(schema3.additionalProperties, references, `${path}/${EscapeKey2(valueKey)}`, value15[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, `${path}/${EscapeKey2(knownKey)}`, value15[knownKey]);
        if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema3) && !(knownKey in value15)) {
          yield Create4(ValueErrorType2.ObjectRequiredProperty, property, `${path}/${EscapeKey2(knownKey)}`, undefined);
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value15, knownKey)) {
          yield* Visit17(property, references, `${path}/${EscapeKey2(knownKey)}`, value15[knownKey]);
        }
      }
    }
  }
  function* FromPromise8(schema3, references, path, value15) {
    if (!(0, index_9.IsPromise)(value15))
      yield Create4(ValueErrorType2.Promise, schema3, path, value15);
  }
  function* FromRecord12(schema3, references, path, value15) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value15))
      return yield Create4(ValueErrorType2.Object, schema3, path, value15);
    if (IsDefined3(schema3.minProperties) && !(Object.getOwnPropertyNames(value15).length >= schema3.minProperties)) {
      yield Create4(ValueErrorType2.ObjectMinProperties, schema3, path, value15);
    }
    if (IsDefined3(schema3.maxProperties) && !(Object.getOwnPropertyNames(value15).length <= schema3.maxProperties)) {
      yield Create4(ValueErrorType2.ObjectMaxProperties, schema3, path, value15);
    }
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const regex2 = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value15)) {
      if (regex2.test(propertyKey))
        yield* Visit17(patternSchema, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
    }
    if (typeof schema3.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value15)) {
        if (!regex2.test(propertyKey))
          yield* Visit17(schema3.additionalProperties, references, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
      }
    }
    if (schema3.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value15)) {
        if (regex2.test(propertyKey))
          continue;
        return yield Create4(ValueErrorType2.ObjectAdditionalProperties, schema3, `${path}/${EscapeKey2(propertyKey)}`, propertyValue);
      }
    }
  }
  function* FromRef12(schema3, references, path, value15) {
    yield* Visit17((0, index_5.Deref)(schema3, references), references, path, value15);
  }
  function* FromRegExp5(schema3, references, path, value15) {
    if (!(0, index_9.IsString)(value15))
      return yield Create4(ValueErrorType2.String, schema3, path, value15);
    if (IsDefined3(schema3.minLength) && !(value15.length >= schema3.minLength)) {
      yield Create4(ValueErrorType2.StringMinLength, schema3, path, value15);
    }
    if (IsDefined3(schema3.maxLength) && !(value15.length <= schema3.maxLength)) {
      yield Create4(ValueErrorType2.StringMaxLength, schema3, path, value15);
    }
    const regex2 = new RegExp(schema3.source, schema3.flags);
    if (!regex2.test(value15)) {
      return yield Create4(ValueErrorType2.RegExp, schema3, path, value15);
    }
  }
  function* FromString6(schema3, references, path, value15) {
    if (!(0, index_9.IsString)(value15))
      return yield Create4(ValueErrorType2.String, schema3, path, value15);
    if (IsDefined3(schema3.minLength) && !(value15.length >= schema3.minLength)) {
      yield Create4(ValueErrorType2.StringMinLength, schema3, path, value15);
    }
    if (IsDefined3(schema3.maxLength) && !(value15.length <= schema3.maxLength)) {
      yield Create4(ValueErrorType2.StringMaxLength, schema3, path, value15);
    }
    if ((0, index_9.IsString)(schema3.pattern)) {
      const regex2 = new RegExp(schema3.pattern);
      if (!regex2.test(value15)) {
        yield Create4(ValueErrorType2.StringPattern, schema3, path, value15);
      }
    }
    if ((0, index_9.IsString)(schema3.format)) {
      if (!index_3.FormatRegistry.Has(schema3.format)) {
        yield Create4(ValueErrorType2.StringFormatUnknown, schema3, path, value15);
      } else {
        const format = index_3.FormatRegistry.Get(schema3.format);
        if (!format(value15)) {
          yield Create4(ValueErrorType2.StringFormat, schema3, path, value15);
        }
      }
    }
  }
  function* FromSymbol6(schema3, references, path, value15) {
    if (!(0, index_9.IsSymbol)(value15))
      yield Create4(ValueErrorType2.Symbol, schema3, path, value15);
  }
  function* FromTemplateLiteral7(schema3, references, path, value15) {
    if (!(0, index_9.IsString)(value15))
      return yield Create4(ValueErrorType2.String, schema3, path, value15);
    const regex2 = new RegExp(schema3.pattern);
    if (!regex2.test(value15)) {
      yield Create4(ValueErrorType2.StringPattern, schema3, path, value15);
    }
  }
  function* FromThis11(schema3, references, path, value15) {
    yield* Visit17((0, index_5.Deref)(schema3, references), references, path, value15);
  }
  function* FromTuple15(schema3, references, path, value15) {
    if (!(0, index_9.IsArray)(value15))
      return yield Create4(ValueErrorType2.Tuple, schema3, path, value15);
    if (schema3.items === undefined && !(value15.length === 0)) {
      return yield Create4(ValueErrorType2.TupleLength, schema3, path, value15);
    }
    if (!(value15.length === schema3.maxItems)) {
      return yield Create4(ValueErrorType2.TupleLength, schema3, path, value15);
    }
    if (!schema3.items) {
      return;
    }
    for (let i = 0;i < schema3.items.length; i++) {
      yield* Visit17(schema3.items[i], references, `${path}/${i}`, value15[i]);
    }
  }
  function* FromUndefined6(schema3, references, path, value15) {
    if (!(0, index_9.IsUndefined)(value15))
      yield Create4(ValueErrorType2.Undefined, schema3, path, value15);
  }
  function* FromUnion20(schema3, references, path, value15) {
    let count = 0;
    for (const subschema of schema3.anyOf) {
      const errors5 = [...Visit17(subschema, references, path, value15)];
      if (errors5.length === 0)
        return;
      count += errors5.length;
    }
    if (count > 0) {
      yield Create4(ValueErrorType2.Union, schema3, path, value15);
    }
  }
  function* FromUint8Array5(schema3, references, path, value15) {
    if (!(0, index_9.IsUint8Array)(value15))
      return yield Create4(ValueErrorType2.Uint8Array, schema3, path, value15);
    if (IsDefined3(schema3.maxByteLength) && !(value15.length <= schema3.maxByteLength)) {
      yield Create4(ValueErrorType2.Uint8ArrayMaxByteLength, schema3, path, value15);
    }
    if (IsDefined3(schema3.minByteLength) && !(value15.length >= schema3.minByteLength)) {
      yield Create4(ValueErrorType2.Uint8ArrayMinByteLength, schema3, path, value15);
    }
  }
  function* FromUnknown5(schema3, references, path, value15) {
  }
  function* FromVoid5(schema3, references, path, value15) {
    if (!index_1.TypeSystemPolicy.IsVoidLike(value15))
      yield Create4(ValueErrorType2.Void, schema3, path, value15);
  }
  function* FromKind4(schema3, references, path, value15) {
    const check11 = index_3.TypeRegistry.Get(schema3[index_7.Kind]);
    if (!check11(schema3, value15))
      yield Create4(ValueErrorType2.Kind, schema3, path, value15);
  }
  function* Visit17(schema3, references, path, value15) {
    const references_ = IsDefined3(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema_[index_7.Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, path, value15);
      case "Array":
        return yield* FromArray16(schema_, references_, path, value15);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, path, value15);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, path, value15);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, path, value15);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, path, value15);
      case "Date":
        return yield* FromDate6(schema_, references_, path, value15);
      case "Function":
        return yield* FromFunction7(schema_, references_, path, value15);
      case "Integer":
        return yield* FromInteger6(schema_, references_, path, value15);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, path, value15);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, path, value15);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, path, value15);
      case "Never":
        return yield* FromNever6(schema_, references_, path, value15);
      case "Not":
        return yield* FromNot8(schema_, references_, path, value15);
      case "Null":
        return yield* FromNull6(schema_, references_, path, value15);
      case "Number":
        return yield* FromNumber6(schema_, references_, path, value15);
      case "Object":
        return yield* FromObject13(schema_, references_, path, value15);
      case "Promise":
        return yield* FromPromise8(schema_, references_, path, value15);
      case "Record":
        return yield* FromRecord12(schema_, references_, path, value15);
      case "Ref":
        return yield* FromRef12(schema_, references_, path, value15);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, path, value15);
      case "String":
        return yield* FromString6(schema_, references_, path, value15);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, path, value15);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, path, value15);
      case "This":
        return yield* FromThis11(schema_, references_, path, value15);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, path, value15);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, path, value15);
      case "Union":
        return yield* FromUnion20(schema_, references_, path, value15);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, path, value15);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, path, value15);
      case "Void":
        return yield* FromVoid5(schema_, references_, path, value15);
      default:
        if (!index_3.TypeRegistry.Has(schema_[index_7.Kind]))
          throw new ValueErrorsUnknownTypeError2(schema3);
        return yield* FromKind4(schema_, references_, path, value15);
    }
  }
  var Errors3 = function(...args) {
    const iterator5 = args.length === 3 ? Visit17(args[0], args[1], "", args[2]) : Visit17(args[0], [], "", args[1]);
    return new ValueErrorIterator2(iterator5);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Errors = exports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = undefined;
  var index_1 = require_system2();
  var index_2 = require_keyof2();
  var index_3 = require_registry();
  var extends_undefined_1 = require_extends_undefined();
  var function_1 = require_function3();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_symbols2();
  var index_8 = require_never2();
  var index_9 = require_guard2();
  var ValueErrorType2;
  (function(ValueErrorType3) {
    ValueErrorType3[ValueErrorType3["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType3[ValueErrorType3["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType3[ValueErrorType3["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType3[ValueErrorType3["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType3[ValueErrorType3["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType3[ValueErrorType3["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType3[ValueErrorType3["Array"] = 6] = "Array";
    ValueErrorType3[ValueErrorType3["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType3[ValueErrorType3["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType3[ValueErrorType3["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType3[ValueErrorType3["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType3[ValueErrorType3["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType3[ValueErrorType3["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType3[ValueErrorType3["BigInt"] = 13] = "BigInt";
    ValueErrorType3[ValueErrorType3["Boolean"] = 14] = "Boolean";
    ValueErrorType3[ValueErrorType3["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType3[ValueErrorType3["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType3[ValueErrorType3["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType3[ValueErrorType3["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType3[ValueErrorType3["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType3[ValueErrorType3["Date"] = 20] = "Date";
    ValueErrorType3[ValueErrorType3["Function"] = 21] = "Function";
    ValueErrorType3[ValueErrorType3["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType3[ValueErrorType3["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType3[ValueErrorType3["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType3[ValueErrorType3["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType3[ValueErrorType3["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType3[ValueErrorType3["Integer"] = 27] = "Integer";
    ValueErrorType3[ValueErrorType3["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType3[ValueErrorType3["Intersect"] = 29] = "Intersect";
    ValueErrorType3[ValueErrorType3["Iterator"] = 30] = "Iterator";
    ValueErrorType3[ValueErrorType3["Kind"] = 31] = "Kind";
    ValueErrorType3[ValueErrorType3["Literal"] = 32] = "Literal";
    ValueErrorType3[ValueErrorType3["Never"] = 33] = "Never";
    ValueErrorType3[ValueErrorType3["Not"] = 34] = "Not";
    ValueErrorType3[ValueErrorType3["Null"] = 35] = "Null";
    ValueErrorType3[ValueErrorType3["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType3[ValueErrorType3["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType3[ValueErrorType3["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType3[ValueErrorType3["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType3[ValueErrorType3["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType3[ValueErrorType3["Number"] = 41] = "Number";
    ValueErrorType3[ValueErrorType3["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType3[ValueErrorType3["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType3[ValueErrorType3["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType3[ValueErrorType3["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType3[ValueErrorType3["Object"] = 46] = "Object";
    ValueErrorType3[ValueErrorType3["Promise"] = 47] = "Promise";
    ValueErrorType3[ValueErrorType3["RegExp"] = 48] = "RegExp";
    ValueErrorType3[ValueErrorType3["StringFormatUnknown"] = 49] = "StringFormatUnknown";
    ValueErrorType3[ValueErrorType3["StringFormat"] = 50] = "StringFormat";
    ValueErrorType3[ValueErrorType3["StringMaxLength"] = 51] = "StringMaxLength";
    ValueErrorType3[ValueErrorType3["StringMinLength"] = 52] = "StringMinLength";
    ValueErrorType3[ValueErrorType3["StringPattern"] = 53] = "StringPattern";
    ValueErrorType3[ValueErrorType3["String"] = 54] = "String";
    ValueErrorType3[ValueErrorType3["Symbol"] = 55] = "Symbol";
    ValueErrorType3[ValueErrorType3["TupleLength"] = 56] = "TupleLength";
    ValueErrorType3[ValueErrorType3["Tuple"] = 57] = "Tuple";
    ValueErrorType3[ValueErrorType3["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
    ValueErrorType3[ValueErrorType3["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
    ValueErrorType3[ValueErrorType3["Uint8Array"] = 60] = "Uint8Array";
    ValueErrorType3[ValueErrorType3["Undefined"] = 61] = "Undefined";
    ValueErrorType3[ValueErrorType3["Union"] = 62] = "Union";
    ValueErrorType3[ValueErrorType3["Void"] = 63] = "Void";
  })(ValueErrorType2 || (exports.ValueErrorType = ValueErrorType2 = {}));

  class ValueErrorsUnknownTypeError2 extends index_4.TypeBoxError {
    constructor(schema3) {
      super("Unknown type");
      this.schema = schema3;
    }
  }
  exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError2;

  class ValueErrorIterator2 {
    constructor(iterator5) {
      this.iterator = iterator5;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const next = this.iterator.next();
      return next.done ? undefined : next.value;
    }
  }
  exports.ValueErrorIterator = ValueErrorIterator2;
  exports.Errors = Errors3;
});

// node_modules/@sinclair/typebox/build/require/errors/index.js
var require_errors2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors(), exports);
  __exportStar(require_function3(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/any/any.js
var require_any = __commonJS((exports) => {
  var Any2 = function(options = {}) {
    return { ...options, [index_1.Kind]: "Any" };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Any = undefined;
  var index_1 = require_symbols2();
  exports.Any = Any2;
});

// node_modules/@sinclair/typebox/build/require/type/any/index.js
var require_any2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_any(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/unknown/unknown.js
var require_unknown = __commonJS((exports) => {
  var Unknown2 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Unknown"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unknown = undefined;
  var index_1 = require_symbols2();
  exports.Unknown = Unknown2;
});

// node_modules/@sinclair/typebox/build/require/type/unknown/index.js
var require_unknown2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unknown(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/guard/index.js
var require_guard3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueGuard = exports.TypeGuard = undefined;
  exports.TypeGuard = require_type3();
  exports.ValueGuard = require_value();
});

// node_modules/@sinclair/typebox/build/require/type/extends/extends-check.js
var require_extends_check = __commonJS((exports) => {
  var IntoBooleanResult2 = function(result) {
    return result === ExtendsResult2.False ? result : ExtendsResult2.True;
  };
  var Throw2 = function(message) {
    throw new ExtendsResolverError2(message);
  };
  var IsStructuralRight2 = function(right) {
    return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
  };
  var StructuralRight2 = function(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight2(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
  };
  var FromAnyRight2 = function(left, right) {
    return ExtendsResult2.True;
  };
  var FromAny5 = function(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema3) => index_10.TypeGuard.IsAny(schema3) || index_10.TypeGuard.IsUnknown(schema3)) ? ExtendsResult2.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult2.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult2.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
  };
  var FromArrayRight2 = function(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromArray16 = function(left, right) {
    return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
  };
  var FromAsyncIterator7 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
  };
  var FromBigInt6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromBooleanRight2 = function(left, right) {
    return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult2.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromBoolean6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromConstructor8 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema3, index) => IntoBooleanResult2(Visit17(right.parameters[index], schema3)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.returns, right.returns));
  };
  var FromDate6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromFunction7 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema3, index) => IntoBooleanResult2(Visit17(right.parameters[index], schema3)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.returns, right.returns));
  };
  var FromIntegerRight2 = function(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult2.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromInteger6 = function(left, right) {
    return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
  };
  var FromIntersectRight2 = function(left, right) {
    return right.allOf.every((schema3) => Visit17(left, schema3) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromIntersect18 = function(left, right) {
    return left.allOf.some((schema3) => Visit17(schema3, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromIterator7 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.items, right.items));
  };
  var FromLiteral7 = function(left, right) {
    return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight2(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight2(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
  };
  var FromNeverRight2 = function(left, right) {
    return ExtendsResult2.False;
  };
  var FromNever6 = function(left, right) {
    return ExtendsResult2.True;
  };
  var UnwrapTNot2 = function(schema3) {
    let [current, depth] = [schema3, 0];
    while (true) {
      if (!index_10.TypeGuard.IsNot(current))
        break;
      current = current.not;
      depth += 1;
    }
    return depth % 2 === 0 ? current : (0, index_5.Unknown)();
  };
  var FromNot8 = function(left, right) {
    return index_10.TypeGuard.IsNot(left) ? Visit17(UnwrapTNot2(left), right) : index_10.TypeGuard.IsNot(right) ? Visit17(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
  };
  var FromNull6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromNumberRight2 = function(left, right) {
    return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult2.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromNumber6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var IsObjectPropertyCount2 = function(schema3, count) {
    return Object.getOwnPropertyNames(schema3.properties).length === count;
  };
  var IsObjectStringLike2 = function(schema3) {
    return IsObjectArrayLike2(schema3);
  };
  var IsObjectSymbolLike2 = function(schema3) {
    return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "description" in schema3.properties && index_10.TypeGuard.IsUnion(schema3.properties.description) && schema3.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema3.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema3.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema3.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema3.properties.description.anyOf[0]));
  };
  var IsObjectNumberLike2 = function(schema3) {
    return IsObjectPropertyCount2(schema3, 0);
  };
  var IsObjectBooleanLike2 = function(schema3) {
    return IsObjectPropertyCount2(schema3, 0);
  };
  var IsObjectBigIntLike2 = function(schema3) {
    return IsObjectPropertyCount2(schema3, 0);
  };
  var IsObjectDateLike2 = function(schema3) {
    return IsObjectPropertyCount2(schema3, 0);
  };
  var IsObjectUint8ArrayLike2 = function(schema3) {
    return IsObjectArrayLike2(schema3);
  };
  var IsObjectFunctionLike2 = function(schema3) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "length" in schema3.properties && IntoBooleanResult2(Visit17(schema3.properties["length"], length)) === ExtendsResult2.True;
  };
  var IsObjectConstructorLike2 = function(schema3) {
    return IsObjectPropertyCount2(schema3, 0);
  };
  var IsObjectArrayLike2 = function(schema3) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "length" in schema3.properties && IntoBooleanResult2(Visit17(schema3.properties["length"], length)) === ExtendsResult2.True;
  };
  var IsObjectPromiseLike2 = function(schema3) {
    const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
    return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "then" in schema3.properties && IntoBooleanResult2(Visit17(schema3.properties["then"], then)) === ExtendsResult2.True;
  };
  var Property2 = function(left, right) {
    return Visit17(left, right) === ExtendsResult2.False ? ExtendsResult2.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
  };
  var FromObjectRight2 = function(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike2(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike2(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike2(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike2(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike2(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike2(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike2(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike2(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike2(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey2(left)) ? (() => {
      return right[index_8.Hint] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
    })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey2(left)) ? (() => {
      return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
    })() : ExtendsResult2.False;
  };
  var FromObject13 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult2.False : (() => {
      for (const key of Object.getOwnPropertyNames(right.properties)) {
        if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult2.False;
        }
        if (index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult2.True;
        }
        if (Property2(left.properties[key], right.properties[key]) === ExtendsResult2.False) {
          return ExtendsResult2.False;
        }
      }
      return ExtendsResult2.True;
    })();
  };
  var FromPromise8 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit17(left.item, right.item));
  };
  var RecordKey2 = function(schema3) {
    return index_7.PatternNumberExact in schema3.patternProperties ? (0, index_3.Number)() : (index_7.PatternStringExact in schema3.patternProperties) ? (0, index_4.String)() : Throw2("Unknown record key pattern");
  };
  var RecordValue2 = function(schema3) {
    return index_7.PatternNumberExact in schema3.patternProperties ? schema3.patternProperties[index_7.PatternNumberExact] : (index_7.PatternStringExact in schema3.patternProperties) ? schema3.patternProperties[index_7.PatternStringExact] : Throw2("Unable to get record value schema");
  };
  var FromRecordRight2 = function(left, right) {
    const [Key, Value] = [RecordKey2(right), RecordValue2(right)];
    return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult2(Visit17(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit17(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
      for (const key of Object.getOwnPropertyNames(left.properties)) {
        if (Property2(Value, left.properties[key]) === ExtendsResult2.False) {
          return ExtendsResult2.False;
        }
      }
      return ExtendsResult2.True;
    })() : ExtendsResult2.False;
  };
  var FromRecord12 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult2.False : Visit17(RecordValue2(left), RecordValue2(right));
  };
  var FromRegExp5 = function(left, right) {
    const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
    const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
    return Visit17(L, R);
  };
  var FromStringRight2 = function(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult2.True : index_10.TypeGuard.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromString6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromSymbol6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromTemplateLiteral7 = function(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit17((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit17(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
  };
  var IsArrayOfTuple2 = function(left, right) {
    return index_10.TypeGuard.IsArray(right) && left.items !== undefined && left.items.every((schema3) => Visit17(schema3, right.items) === ExtendsResult2.True);
  };
  var FromTupleRight2 = function(left, right) {
    return index_10.TypeGuard.IsNever(left) ? ExtendsResult2.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult2.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
  };
  var FromTuple15 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult2.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult2.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema3, index) => Visit17(schema3, right.items[index]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromUint8Array5 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromUndefined6 = function(left, right) {
    return IsStructuralRight2(right) ? StructuralRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight2(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight2(left, right) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromUnionRight2 = function(left, right) {
    return right.anyOf.some((schema3) => Visit17(left, schema3) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromUnion20 = function(left, right) {
    return left.anyOf.every((schema3) => Visit17(schema3, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromUnknownRight2 = function(left, right) {
    return ExtendsResult2.True;
  };
  var FromUnknown5 = function(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight2(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight2(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight2(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight2(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight2(left, right) : index_10.TypeGuard.IsArray(right) ? FromArrayRight2(left, right) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromVoidRight2 = function(left, right) {
    return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult2.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var FromVoid5 = function(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight2(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight2(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight2(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight2(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight2(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
  };
  var Visit17 = function(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral7(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp5(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot8(left, right) : index_10.TypeGuard.IsAny(left) ? FromAny5(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray16(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt6(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean6(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator7(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor8(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate6(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction7(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger6(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect18(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator7(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral7(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever6(left, right) : index_10.TypeGuard.IsNull(left) ? FromNull6(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber6(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject13(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord12(left, right) : index_10.TypeGuard.IsString(left) ? FromString6(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol6(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple15(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise8(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array5(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined6(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion20(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown5(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[index_8.Kind]}'`);
  };
  var ExtendsCheck2 = function(left, right) {
    return Visit17(left, right);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsCheck = exports.ExtendsResult = exports.ExtendsResolverError = undefined;
  var index_1 = require_any2();
  var index_2 = require_function2();
  var index_3 = require_number2();
  var index_4 = require_string2();
  var index_5 = require_unknown2();
  var index_6 = require_template_literal2();
  var index_7 = require_patterns2();
  var index_8 = require_symbols2();
  var index_9 = require_error2();
  var index_10 = require_guard3();

  class ExtendsResolverError2 extends index_9.TypeBoxError {
  }
  exports.ExtendsResolverError = ExtendsResolverError2;
  var ExtendsResult2;
  (function(ExtendsResult3) {
    ExtendsResult3[ExtendsResult3["Union"] = 0] = "Union";
    ExtendsResult3[ExtendsResult3["True"] = 1] = "True";
    ExtendsResult3[ExtendsResult3["False"] = 2] = "False";
  })(ExtendsResult2 || (exports.ExtendsResult = ExtendsResult2 = {}));
  exports.ExtendsCheck = ExtendsCheck2;
});

// node_modules/@sinclair/typebox/build/require/type/extends/extends-from-mapped-result.js
var require_extends_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(P, Right, True, False, options) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, extends_1.Extends)(P[K2], Right, True, False, options) };
    }, {});
  };
  var FromMappedResult13 = function(Left, Right, True, False, options) {
    return FromProperties20(Left.properties, Right, True, False, options);
  };
  var ExtendsFromMappedResult2 = function(Left, Right, True, False, options) {
    const P = FromMappedResult13(Left, Right, True, False, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var extends_1 = require_extends();
  exports.ExtendsFromMappedResult = ExtendsFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/extends/extends.js
var require_extends = __commonJS((exports) => {
  var ExtendsResolve2 = function(left, right, trueType, falseType) {
    const R = (0, extends_check_1.ExtendsCheck)(left, right);
    return R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R === extends_check_1.ExtendsResult.True ? trueType : falseType;
  };
  var Extends2 = function(L, R, T, F, options = {}) {
    return (0, type_2.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) : (0, type_2.IsMappedKey)(L) ? (0, type_1.CloneType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) : (0, type_1.CloneType)(ExtendsResolve2(L, R, T, F), options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extends = undefined;
  var index_1 = require_union2();
  var extends_check_1 = require_extends_check();
  var type_1 = require_type2();
  var extends_from_mapped_key_1 = require_extends_from_mapped_key();
  var extends_from_mapped_result_1 = require_extends_from_mapped_result();
  var type_2 = require_type3();
  exports.Extends = Extends2;
});

// node_modules/@sinclair/typebox/build/require/type/extends/extends-from-mapped-key.js
var require_extends_from_mapped_key = __commonJS((exports) => {
  var FromPropertyKey4 = function(K, U, L, R, options) {
    return {
      [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, options)
    };
  };
  var FromPropertyKeys4 = function(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey4(LK, U, L, R, options) };
    }, {});
  };
  var FromMappedKey5 = function(K, U, L, R, options) {
    return FromPropertyKeys4(K.keys, U, L, R, options);
  };
  var ExtendsFromMappedKey2 = function(T, U, L, R, options) {
    const P = FromMappedKey5(T, U, L, R, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedKey = undefined;
  var index_1 = require_mapped2();
  var index_2 = require_literal2();
  var extends_1 = require_extends();
  exports.ExtendsFromMappedKey = ExtendsFromMappedKey2;
});

// node_modules/@sinclair/typebox/build/require/type/extends/index.js
var require_extends2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extends_check(), exports);
  __exportStar(require_extends_from_mapped_key(), exports);
  __exportStar(require_extends_from_mapped_result(), exports);
  __exportStar(require_extends_undefined(), exports);
  __exportStar(require_extends(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/check/check.js
var require_check = __commonJS((exports) => {
  var IsAnyOrUnknown2 = function(schema3) {
    return schema3[index_4.Kind] === "Any" || schema3[index_4.Kind] === "Unknown";
  };
  var IsDefined3 = function(value15) {
    return value15 !== undefined;
  };
  var FromAny5 = function(schema3, references, value15) {
    return true;
  };
  var FromArray16 = function(schema3, references, value15) {
    if (!(0, index_10.IsArray)(value15))
      return false;
    if (IsDefined3(schema3.minItems) && !(value15.length >= schema3.minItems)) {
      return false;
    }
    if (IsDefined3(schema3.maxItems) && !(value15.length <= schema3.maxItems)) {
      return false;
    }
    if (!value15.every((value16) => Visit17(schema3.items, references, value16))) {
      return false;
    }
    if (schema3.uniqueItems === true && !function() {
      const set2 = new Set;
      for (const element of value15) {
        const hashed = (0, index_3.Hash)(element);
        if (set2.has(hashed)) {
          return false;
        } else {
          set2.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined3(schema3.contains) || (0, index_10.IsNumber)(schema3.minContains) || (0, index_10.IsNumber)(schema3.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined3(schema3.contains) ? schema3.contains : (0, index_9.Never)();
    const containsCount = value15.reduce((acc, value16) => Visit17(containsSchema, references, value16) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema3.minContains) && containsCount < schema3.minContains) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema3.maxContains) && containsCount > schema3.maxContains) {
      return false;
    }
    return true;
  };
  var FromAsyncIterator7 = function(schema3, references, value15) {
    return (0, index_10.IsAsyncIterator)(value15);
  };
  var FromBigInt6 = function(schema3, references, value15) {
    if (!(0, index_10.IsBigInt)(value15))
      return false;
    if (IsDefined3(schema3.exclusiveMaximum) && !(value15 < schema3.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined3(schema3.exclusiveMinimum) && !(value15 > schema3.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined3(schema3.maximum) && !(value15 <= schema3.maximum)) {
      return false;
    }
    if (IsDefined3(schema3.minimum) && !(value15 >= schema3.minimum)) {
      return false;
    }
    if (IsDefined3(schema3.multipleOf) && !(value15 % schema3.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  };
  var FromBoolean6 = function(schema3, references, value15) {
    return (0, index_10.IsBoolean)(value15);
  };
  var FromConstructor8 = function(schema3, references, value15) {
    return Visit17(schema3.returns, references, value15.prototype);
  };
  var FromDate6 = function(schema3, references, value15) {
    if (!(0, index_10.IsDate)(value15))
      return false;
    if (IsDefined3(schema3.exclusiveMaximumTimestamp) && !(value15.getTime() < schema3.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema3.exclusiveMinimumTimestamp) && !(value15.getTime() > schema3.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema3.maximumTimestamp) && !(value15.getTime() <= schema3.maximumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema3.minimumTimestamp) && !(value15.getTime() >= schema3.minimumTimestamp)) {
      return false;
    }
    if (IsDefined3(schema3.multipleOfTimestamp) && !(value15.getTime() % schema3.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  };
  var FromFunction7 = function(schema3, references, value15) {
    return (0, index_10.IsFunction)(value15);
  };
  var FromInteger6 = function(schema3, references, value15) {
    if (!(0, index_10.IsInteger)(value15)) {
      return false;
    }
    if (IsDefined3(schema3.exclusiveMaximum) && !(value15 < schema3.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined3(schema3.exclusiveMinimum) && !(value15 > schema3.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined3(schema3.maximum) && !(value15 <= schema3.maximum)) {
      return false;
    }
    if (IsDefined3(schema3.minimum) && !(value15 >= schema3.minimum)) {
      return false;
    }
    if (IsDefined3(schema3.multipleOf) && !(value15 % schema3.multipleOf === 0)) {
      return false;
    }
    return true;
  };
  var FromIntersect18 = function(schema3, references, value15) {
    const check1 = schema3.allOf.every((schema4) => Visit17(schema4, references, value15));
    if (schema3.unevaluatedProperties === false) {
      const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema3));
      const check22 = Object.getOwnPropertyNames(value15).every((key) => keyPattern.test(key));
      return check1 && check22;
    } else if ((0, type_1.IsSchema)(schema3.unevaluatedProperties)) {
      const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema3));
      const check22 = Object.getOwnPropertyNames(value15).every((key) => keyCheck.test(key) || Visit17(schema3.unevaluatedProperties, references, value15[key]));
      return check1 && check22;
    } else {
      return check1;
    }
  };
  var FromIterator7 = function(schema3, references, value15) {
    return (0, index_10.IsIterator)(value15);
  };
  var FromLiteral7 = function(schema3, references, value15) {
    return value15 === schema3.const;
  };
  var FromNever6 = function(schema3, references, value15) {
    return false;
  };
  var FromNot8 = function(schema3, references, value15) {
    return !Visit17(schema3.not, references, value15);
  };
  var FromNull6 = function(schema3, references, value15) {
    return (0, index_10.IsNull)(value15);
  };
  var FromNumber6 = function(schema3, references, value15) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value15))
      return false;
    if (IsDefined3(schema3.exclusiveMaximum) && !(value15 < schema3.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined3(schema3.exclusiveMinimum) && !(value15 > schema3.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined3(schema3.minimum) && !(value15 >= schema3.minimum)) {
      return false;
    }
    if (IsDefined3(schema3.maximum) && !(value15 <= schema3.maximum)) {
      return false;
    }
    if (IsDefined3(schema3.multipleOf) && !(value15 % schema3.multipleOf === 0)) {
      return false;
    }
    return true;
  };
  var FromObject13 = function(schema3, references, value15) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value15))
      return false;
    if (IsDefined3(schema3.minProperties) && !(Object.getOwnPropertyNames(value15).length >= schema3.minProperties)) {
      return false;
    }
    if (IsDefined3(schema3.maxProperties) && !(Object.getOwnPropertyNames(value15).length <= schema3.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        if (!Visit17(property, references, value15[knownKey])) {
          return false;
        }
        if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown2(property)) && !(knownKey in value15)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value15, knownKey) && !Visit17(property, references, value15[knownKey])) {
          return false;
        }
      }
    }
    if (schema3.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value15);
      if (schema3.required && schema3.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema3.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value15);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit17(schema3.additionalProperties, references, value15[key]));
    } else {
      return true;
    }
  };
  var FromPromise8 = function(schema3, references, value15) {
    return (0, index_10.IsPromise)(value15);
  };
  var FromRecord12 = function(schema3, references, value15) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value15)) {
      return false;
    }
    if (IsDefined3(schema3.minProperties) && !(Object.getOwnPropertyNames(value15).length >= schema3.minProperties)) {
      return false;
    }
    if (IsDefined3(schema3.maxProperties) && !(Object.getOwnPropertyNames(value15).length <= schema3.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const regex2 = new RegExp(patternKey);
    const check1 = Object.entries(value15).every(([key, value16]) => {
      return regex2.test(key) ? Visit17(patternSchema, references, value16) : true;
    });
    const check22 = typeof schema3.additionalProperties === "object" ? Object.entries(value15).every(([key, value16]) => {
      return !regex2.test(key) ? Visit17(schema3.additionalProperties, references, value16) : true;
    }) : true;
    const check32 = schema3.additionalProperties === false ? Object.getOwnPropertyNames(value15).every((key) => {
      return regex2.test(key);
    }) : true;
    return check1 && check22 && check32;
  };
  var FromRef12 = function(schema3, references, value15) {
    return Visit17((0, index_2.Deref)(schema3, references), references, value15);
  };
  var FromRegExp5 = function(schema3, references, value15) {
    const regex2 = new RegExp(schema3.source, schema3.flags);
    if (IsDefined3(schema3.minLength)) {
      if (!(value15.length >= schema3.minLength))
        return false;
    }
    if (IsDefined3(schema3.maxLength)) {
      if (!(value15.length <= schema3.maxLength))
        return false;
    }
    return regex2.test(value15);
  };
  var FromString6 = function(schema3, references, value15) {
    if (!(0, index_10.IsString)(value15)) {
      return false;
    }
    if (IsDefined3(schema3.minLength)) {
      if (!(value15.length >= schema3.minLength))
        return false;
    }
    if (IsDefined3(schema3.maxLength)) {
      if (!(value15.length <= schema3.maxLength))
        return false;
    }
    if (IsDefined3(schema3.pattern)) {
      const regex2 = new RegExp(schema3.pattern);
      if (!regex2.test(value15))
        return false;
    }
    if (IsDefined3(schema3.format)) {
      if (!index_7.FormatRegistry.Has(schema3.format))
        return false;
      const func = index_7.FormatRegistry.Get(schema3.format);
      return func(value15);
    }
    return true;
  };
  var FromSymbol6 = function(schema3, references, value15) {
    return (0, index_10.IsSymbol)(value15);
  };
  var FromTemplateLiteral7 = function(schema3, references, value15) {
    return (0, index_10.IsString)(value15) && new RegExp(schema3.pattern).test(value15);
  };
  var FromThis11 = function(schema3, references, value15) {
    return Visit17((0, index_2.Deref)(schema3, references), references, value15);
  };
  var FromTuple15 = function(schema3, references, value15) {
    if (!(0, index_10.IsArray)(value15)) {
      return false;
    }
    if (schema3.items === undefined && !(value15.length === 0)) {
      return false;
    }
    if (!(value15.length === schema3.maxItems)) {
      return false;
    }
    if (!schema3.items) {
      return true;
    }
    for (let i = 0;i < schema3.items.length; i++) {
      if (!Visit17(schema3.items[i], references, value15[i]))
        return false;
    }
    return true;
  };
  var FromUndefined6 = function(schema3, references, value15) {
    return (0, index_10.IsUndefined)(value15);
  };
  var FromUnion20 = function(schema3, references, value15) {
    return schema3.anyOf.some((inner) => Visit17(inner, references, value15));
  };
  var FromUint8Array5 = function(schema3, references, value15) {
    if (!(0, index_10.IsUint8Array)(value15)) {
      return false;
    }
    if (IsDefined3(schema3.maxByteLength) && !(value15.length <= schema3.maxByteLength)) {
      return false;
    }
    if (IsDefined3(schema3.minByteLength) && !(value15.length >= schema3.minByteLength)) {
      return false;
    }
    return true;
  };
  var FromUnknown5 = function(schema3, references, value15) {
    return true;
  };
  var FromVoid5 = function(schema3, references, value15) {
    return index_1.TypeSystemPolicy.IsVoidLike(value15);
  };
  var FromKind4 = function(schema3, references, value15) {
    if (!index_7.TypeRegistry.Has(schema3[index_4.Kind]))
      return false;
    const func = index_7.TypeRegistry.Get(schema3[index_4.Kind]);
    return func(schema3, value15);
  };
  var Visit17 = function(schema3, references, value15) {
    const references_ = IsDefined3(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema_[index_4.Kind]) {
      case "Any":
        return FromAny5(schema_, references_, value15);
      case "Array":
        return FromArray16(schema_, references_, value15);
      case "AsyncIterator":
        return FromAsyncIterator7(schema_, references_, value15);
      case "BigInt":
        return FromBigInt6(schema_, references_, value15);
      case "Boolean":
        return FromBoolean6(schema_, references_, value15);
      case "Constructor":
        return FromConstructor8(schema_, references_, value15);
      case "Date":
        return FromDate6(schema_, references_, value15);
      case "Function":
        return FromFunction7(schema_, references_, value15);
      case "Integer":
        return FromInteger6(schema_, references_, value15);
      case "Intersect":
        return FromIntersect18(schema_, references_, value15);
      case "Iterator":
        return FromIterator7(schema_, references_, value15);
      case "Literal":
        return FromLiteral7(schema_, references_, value15);
      case "Never":
        return FromNever6(schema_, references_, value15);
      case "Not":
        return FromNot8(schema_, references_, value15);
      case "Null":
        return FromNull6(schema_, references_, value15);
      case "Number":
        return FromNumber6(schema_, references_, value15);
      case "Object":
        return FromObject13(schema_, references_, value15);
      case "Promise":
        return FromPromise8(schema_, references_, value15);
      case "Record":
        return FromRecord12(schema_, references_, value15);
      case "Ref":
        return FromRef12(schema_, references_, value15);
      case "RegExp":
        return FromRegExp5(schema_, references_, value15);
      case "String":
        return FromString6(schema_, references_, value15);
      case "Symbol":
        return FromSymbol6(schema_, references_, value15);
      case "TemplateLiteral":
        return FromTemplateLiteral7(schema_, references_, value15);
      case "This":
        return FromThis11(schema_, references_, value15);
      case "Tuple":
        return FromTuple15(schema_, references_, value15);
      case "Undefined":
        return FromUndefined6(schema_, references_, value15);
      case "Union":
        return FromUnion20(schema_, references_, value15);
      case "Uint8Array":
        return FromUint8Array5(schema_, references_, value15);
      case "Unknown":
        return FromUnknown5(schema_, references_, value15);
      case "Void":
        return FromVoid5(schema_, references_, value15);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
          throw new ValueCheckUnknownTypeError2(schema_);
        return FromKind4(schema_, references_, value15);
    }
  };
  var Check3 = function(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Check = exports.ValueCheckUnknownTypeError = undefined;
  var index_1 = require_system2();
  var index_2 = require_deref2();
  var index_3 = require_hash2();
  var index_4 = require_symbols2();
  var index_5 = require_keyof2();
  var index_6 = require_extends2();
  var index_7 = require_registry();
  var index_8 = require_error2();
  var index_9 = require_never2();
  var index_10 = require_guard2();
  var type_1 = require_type3();

  class ValueCheckUnknownTypeError2 extends index_8.TypeBoxError {
    constructor(schema3) {
      super(`Unknown type`);
      this.schema = schema3;
    }
  }
  exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError2;
  exports.Check = Check3;
});

// node_modules/@sinclair/typebox/build/require/value/check/index.js
var require_check2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_check(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/clone/clone.js
var require_clone = __commonJS((exports) => {
  var ObjectType7 = function(value15) {
    const keys = [...Object.getOwnPropertyNames(value15), ...Object.getOwnPropertySymbols(value15)];
    return keys.reduce((acc, key) => ({ ...acc, [key]: Clone4(value15[key]) }), {});
  };
  var ArrayType7 = function(value15) {
    return value15.map((element) => Clone4(element));
  };
  var TypedArrayType5 = function(value15) {
    return value15.slice();
  };
  var DateType5 = function(value15) {
    return new Date(value15.toISOString());
  };
  var ValueType5 = function(value15) {
    return value15;
  };
  var Clone4 = function(value15) {
    if ((0, index_1.IsArray)(value15))
      return ArrayType7(value15);
    if ((0, index_1.IsDate)(value15))
      return DateType5(value15);
    if ((0, index_1.IsStandardObject)(value15))
      return ObjectType7(value15);
    if ((0, index_1.IsTypedArray)(value15))
      return TypedArrayType5(value15);
    if ((0, index_1.IsValueType)(value15))
      return ValueType5(value15);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = undefined;
  var index_1 = require_guard2();
  exports.Clone = Clone4;
});

// node_modules/@sinclair/typebox/build/require/value/clone/index.js
var require_clone2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/create/create.js
var require_create = __commonJS((exports) => {
  var FromDefault2 = function(value15) {
    return typeof value15 === "function" ? value15 : (0, index_3.Clone)(value15);
  };
  var FromAny5 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return {};
    }
  };
  var FromArray16 = function(schema3, references) {
    if (schema3.uniqueItems === true && !(0, index_1.HasPropertyKey)(schema3, "default")) {
      throw new ValueCreateError2(schema3, "Array with the uniqueItems constraint requires a default value");
    } else if ("contains" in schema3 && !(0, index_1.HasPropertyKey)(schema3, "default")) {
      throw new ValueCreateError2(schema3, "Array with the contains constraint requires a default value");
    } else if ("default" in schema3) {
      return FromDefault2(schema3.default);
    } else if (schema3.minItems !== undefined) {
      return Array.from({ length: schema3.minItems }).map((item) => {
        return Visit17(schema3.items, references);
      });
    } else {
      return [];
    }
  };
  var FromAsyncIterator7 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return async function* () {
      }();
    }
  };
  var FromBigInt6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return BigInt(0);
    }
  };
  var FromBoolean6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return false;
    }
  };
  var FromConstructor8 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      const value15 = Visit17(schema3.returns, references);
      if (typeof value15 === "object" && !Array.isArray(value15)) {
        return class {
          constructor() {
            for (const [key, val] of Object.entries(value15)) {
              const self = this;
              self[key] = val;
            }
          }
        };
      } else {
        return class {
        };
      }
    }
  };
  var FromDate6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else if (schema3.minimumTimestamp !== undefined) {
      return new Date(schema3.minimumTimestamp);
    } else {
      return new Date;
    }
  };
  var FromFunction7 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return () => Visit17(schema3.returns, references);
    }
  };
  var FromInteger6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else if (schema3.minimum !== undefined) {
      return schema3.minimum;
    } else {
      return 0;
    }
  };
  var FromIntersect18 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      const value15 = schema3.allOf.reduce((acc, schema4) => {
        const next = Visit17(schema4, references);
        return typeof next === "object" ? { ...acc, ...next } : next;
      }, {});
      if (!(0, index_2.Check)(schema3, references, value15))
        throw new ValueCreateError2(schema3, "Intersect produced invalid value. Consider using a default value.");
      return value15;
    }
  };
  var FromIterator7 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return function* () {
      }();
    }
  };
  var FromLiteral7 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return schema3.const;
    }
  };
  var FromNever6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      throw new ValueCreateError2(schema3, "Never types cannot be created. Consider using a default value.");
    }
  };
  var FromNot8 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      throw new ValueCreateError2(schema3, "Not types must have a default value");
    }
  };
  var FromNull6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return null;
    }
  };
  var FromNumber6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else if (schema3.minimum !== undefined) {
      return schema3.minimum;
    } else {
      return 0;
    }
  };
  var FromObject13 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      const required5 = new Set(schema3.required);
      return FromDefault2(schema3.default) || Object.entries(schema3.properties).reduce((acc, [key, schema4]) => {
        return required5.has(key) ? { ...acc, [key]: Visit17(schema4, references) } : { ...acc };
      }, {});
    }
  };
  var FromPromise8 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return Promise.resolve(Visit17(schema3.item, references));
    }
  };
  var FromRecord12 = function(schema3, references) {
    const [keyPattern, valueSchema] = Object.entries(schema3.patternProperties)[0];
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else if (!(keyPattern === index_6.PatternStringExact || keyPattern === index_6.PatternNumberExact)) {
      const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
      return propertyKeys.reduce((acc, key) => {
        return { ...acc, [key]: Visit17(valueSchema, references) };
      }, {});
    } else {
      return {};
    }
  };
  var FromRef12 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return Visit17((0, index_4.Deref)(schema3, references), references);
    }
  };
  var FromRegExp5 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      throw new ValueCreateError2(schema3, "RegExp types cannot be created. Consider using a default value.");
    }
  };
  var FromString6 = function(schema3, references) {
    if (schema3.pattern !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema3, "default")) {
        throw new ValueCreateError2(schema3, "String types with patterns must specify a default value");
      } else {
        return FromDefault2(schema3.default);
      }
    } else if (schema3.format !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema3, "default")) {
        throw new ValueCreateError2(schema3, "String types with formats must specify a default value");
      } else {
        return FromDefault2(schema3.default);
      }
    } else {
      if ((0, index_1.HasPropertyKey)(schema3, "default")) {
        return FromDefault2(schema3.default);
      } else if (schema3.minLength !== undefined) {
        return Array.from({ length: schema3.minLength }).map(() => " ").join("");
      } else {
        return "";
      }
    }
  };
  var FromSymbol6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else if ("value" in schema3) {
      return Symbol.for(schema3.value);
    } else {
      return Symbol();
    }
  };
  var FromTemplateLiteral7 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    }
    if (!(0, index_5.IsTemplateLiteralFinite)(schema3))
      throw new ValueCreateError2(schema3, "Can only create template literals that produce a finite variants. Consider using a default value.");
    const generated = (0, index_5.TemplateLiteralGenerate)(schema3);
    return generated[0];
  };
  var FromThis11 = function(schema3, references) {
    if (recursiveDepth2++ > recursiveMaxDepth2)
      throw new ValueCreateError2(schema3, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return Visit17((0, index_4.Deref)(schema3, references), references);
    }
  };
  var FromTuple15 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    }
    if (schema3.items === undefined) {
      return [];
    } else {
      return Array.from({ length: schema3.minItems }).map((_, index) => Visit17(schema3.items[index], references));
    }
  };
  var FromUndefined6 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return;
    }
  };
  var FromUnion20 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else if (schema3.anyOf.length === 0) {
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    } else {
      return Visit17(schema3.anyOf[0], references);
    }
  };
  var FromUint8Array5 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else if (schema3.minByteLength !== undefined) {
      return new Uint8Array(schema3.minByteLength);
    } else {
      return new Uint8Array(0);
    }
  };
  var FromUnknown5 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return {};
    }
  };
  var FromVoid5 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      return;
    }
  };
  var FromKind4 = function(schema3, references) {
    if ((0, index_1.HasPropertyKey)(schema3, "default")) {
      return FromDefault2(schema3.default);
    } else {
      throw new Error("User defined types must specify a default value");
    }
  };
  var Visit17 = function(schema3, references) {
    const references_ = (0, index_1.IsString)(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema_[index_8.Kind]) {
      case "Any":
        return FromAny5(schema_, references_);
      case "Array":
        return FromArray16(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator7(schema_, references_);
      case "BigInt":
        return FromBigInt6(schema_, references_);
      case "Boolean":
        return FromBoolean6(schema_, references_);
      case "Constructor":
        return FromConstructor8(schema_, references_);
      case "Date":
        return FromDate6(schema_, references_);
      case "Function":
        return FromFunction7(schema_, references_);
      case "Integer":
        return FromInteger6(schema_, references_);
      case "Intersect":
        return FromIntersect18(schema_, references_);
      case "Iterator":
        return FromIterator7(schema_, references_);
      case "Literal":
        return FromLiteral7(schema_, references_);
      case "Never":
        return FromNever6(schema_, references_);
      case "Not":
        return FromNot8(schema_, references_);
      case "Null":
        return FromNull6(schema_, references_);
      case "Number":
        return FromNumber6(schema_, references_);
      case "Object":
        return FromObject13(schema_, references_);
      case "Promise":
        return FromPromise8(schema_, references_);
      case "Record":
        return FromRecord12(schema_, references_);
      case "Ref":
        return FromRef12(schema_, references_);
      case "RegExp":
        return FromRegExp5(schema_, references_);
      case "String":
        return FromString6(schema_, references_);
      case "Symbol":
        return FromSymbol6(schema_, references_);
      case "TemplateLiteral":
        return FromTemplateLiteral7(schema_, references_);
      case "This":
        return FromThis11(schema_, references_);
      case "Tuple":
        return FromTuple15(schema_, references_);
      case "Undefined":
        return FromUndefined6(schema_, references_);
      case "Union":
        return FromUnion20(schema_, references_);
      case "Uint8Array":
        return FromUint8Array5(schema_, references_);
      case "Unknown":
        return FromUnknown5(schema_, references_);
      case "Void":
        return FromVoid5(schema_, references_);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_8.Kind]))
          throw new ValueCreateError2(schema_, "Unknown type");
        return FromKind4(schema_, references_);
    }
  };
  var Create4 = function(...args) {
    recursiveDepth2 = 0;
    return args.length === 2 ? Visit17(args[0], args[1]) : Visit17(args[0], []);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Create = exports.ValueCreateError = undefined;
  var index_1 = require_guard2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_template_literal2();
  var index_6 = require_patterns2();
  var index_7 = require_registry();
  var index_8 = require_symbols2();
  var index_9 = require_error2();

  class ValueCreateError2 extends index_9.TypeBoxError {
    constructor(schema3, message) {
      super(message);
      this.schema = schema3;
    }
  }
  exports.ValueCreateError = ValueCreateError2;
  var recursiveMaxDepth2 = 512;
  var recursiveDepth2 = 0;
  exports.Create = Create4;
});

// node_modules/@sinclair/typebox/build/require/value/create/index.js
var require_create2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_create(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/cast/cast.js
var require_cast = __commonJS((exports) => {
  var ScoreUnion2 = function(schema3, references, value15) {
    if (schema3[index_3.Kind] === "Object" && typeof value15 === "object" && !(0, index_1.IsNull)(value15)) {
      const object13 = schema3;
      const keys = Object.getOwnPropertyNames(value15);
      const entries = Object.entries(object13.properties);
      const [point, max] = [1 / entries.length, entries.length];
      return entries.reduce((acc, [key, schema4]) => {
        const literal14 = schema4[index_3.Kind] === "Literal" && schema4.const === value15[key] ? max : 0;
        const checks = (0, index_5.Check)(schema4, references, value15[key]) ? point : 0;
        const exists = keys.includes(key) ? point : 0;
        return acc + (literal14 + checks + exists);
      }, 0);
    } else {
      return (0, index_5.Check)(schema3, references, value15) ? 1 : 0;
    }
  };
  var SelectUnion2 = function(union22, references, value15) {
    let [select, best] = [union22.anyOf[0], 0];
    for (const schema3 of union22.anyOf) {
      const score = ScoreUnion2(schema3, references, value15);
      if (score > best) {
        select = schema3;
        best = score;
      }
    }
    return select;
  };
  var CastUnion2 = function(union22, references, value15) {
    if ("default" in union22) {
      return typeof value15 === "function" ? union22.default : (0, index_6.Clone)(union22.default);
    } else {
      const schema3 = SelectUnion2(union22, references, value15);
      return Cast3(schema3, references, value15);
    }
  };
  var DefaultClone2 = function(schema3, references, value15) {
    return (0, index_5.Check)(schema3, references, value15) ? (0, index_6.Clone)(value15) : (0, index_4.Create)(schema3, references);
  };
  var Default7 = function(schema3, references, value15) {
    return (0, index_5.Check)(schema3, references, value15) ? value15 : (0, index_4.Create)(schema3, references);
  };
  var FromArray16 = function(schema3, references, value15) {
    if ((0, index_5.Check)(schema3, references, value15))
      return (0, index_6.Clone)(value15);
    const created = (0, index_1.IsArray)(value15) ? (0, index_6.Clone)(value15) : (0, index_4.Create)(schema3, references);
    const minimum = (0, index_1.IsNumber)(schema3.minItems) && created.length < schema3.minItems ? [...created, ...Array.from({ length: schema3.minItems - created.length }, () => null)] : created;
    const maximum = (0, index_1.IsNumber)(schema3.maxItems) && minimum.length > schema3.maxItems ? minimum.slice(0, schema3.maxItems) : minimum;
    const casted = maximum.map((value16) => Visit17(schema3.items, references, value16));
    if (schema3.uniqueItems !== true)
      return casted;
    const unique = [...new Set(casted)];
    if (!(0, index_5.Check)(schema3, references, unique))
      throw new ValueCastError2(schema3, "Array cast produced invalid data due to uniqueItems constraint");
    return unique;
  };
  var FromConstructor8 = function(schema3, references, value15) {
    if ((0, index_5.Check)(schema3, references, value15))
      return (0, index_4.Create)(schema3, references);
    const required5 = new Set(schema3.returns.required || []);
    const result = function() {
    };
    for (const [key, property] of Object.entries(schema3.returns.properties)) {
      if (!required5.has(key) && value15.prototype[key] === undefined)
        continue;
      result.prototype[key] = Visit17(property, references, value15.prototype[key]);
    }
    return result;
  };
  var FromIntersect18 = function(schema3, references, value15) {
    const created = (0, index_4.Create)(schema3, references);
    const mapped20 = (0, index_1.IsStandardObject)(created) && (0, index_1.IsStandardObject)(value15) ? { ...created, ...value15 } : value15;
    return (0, index_5.Check)(schema3, references, mapped20) ? mapped20 : (0, index_4.Create)(schema3, references);
  };
  var FromNever6 = function(schema3, references, value15) {
    throw new ValueCastError2(schema3, "Never types cannot be cast");
  };
  var FromObject13 = function(schema3, references, value15) {
    if ((0, index_5.Check)(schema3, references, value15))
      return value15;
    if (value15 === null || typeof value15 !== "object")
      return (0, index_4.Create)(schema3, references);
    const required5 = new Set(schema3.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema3.properties)) {
      if (!required5.has(key) && value15[key] === undefined)
        continue;
      result[key] = Visit17(property, references, value15[key]);
    }
    if (typeof schema3.additionalProperties === "object") {
      const propertyNames = Object.getOwnPropertyNames(schema3.properties);
      for (const propertyName of Object.getOwnPropertyNames(value15)) {
        if (propertyNames.includes(propertyName))
          continue;
        result[propertyName] = Visit17(schema3.additionalProperties, references, value15[propertyName]);
      }
    }
    return result;
  };
  var FromRecord12 = function(schema3, references, value15) {
    if ((0, index_5.Check)(schema3, references, value15))
      return (0, index_6.Clone)(value15);
    if (value15 === null || typeof value15 !== "object" || Array.isArray(value15) || value15 instanceof Date)
      return (0, index_4.Create)(schema3, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema3.patternProperties)[0];
    const subschema = schema3.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value15)) {
      result[propKey] = Visit17(subschema, references, propValue);
    }
    return result;
  };
  var FromRef12 = function(schema3, references, value15) {
    return Visit17((0, index_7.Deref)(schema3, references), references, value15);
  };
  var FromThis11 = function(schema3, references, value15) {
    return Visit17((0, index_7.Deref)(schema3, references), references, value15);
  };
  var FromTuple15 = function(schema3, references, value15) {
    if ((0, index_5.Check)(schema3, references, value15))
      return (0, index_6.Clone)(value15);
    if (!(0, index_1.IsArray)(value15))
      return (0, index_4.Create)(schema3, references);
    if (schema3.items === undefined)
      return [];
    return schema3.items.map((schema4, index) => Visit17(schema4, references, value15[index]));
  };
  var FromUnion20 = function(schema3, references, value15) {
    return (0, index_5.Check)(schema3, references, value15) ? (0, index_6.Clone)(value15) : CastUnion2(schema3, references, value15);
  };
  var Visit17 = function(schema3, references, value15) {
    const references_ = (0, index_1.IsString)(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema3[index_3.Kind]) {
      case "Array":
        return FromArray16(schema_, references_, value15);
      case "Constructor":
        return FromConstructor8(schema_, references_, value15);
      case "Intersect":
        return FromIntersect18(schema_, references_, value15);
      case "Never":
        return FromNever6(schema_, references_, value15);
      case "Object":
        return FromObject13(schema_, references_, value15);
      case "Record":
        return FromRecord12(schema_, references_, value15);
      case "Ref":
        return FromRef12(schema_, references_, value15);
      case "This":
        return FromThis11(schema_, references_, value15);
      case "Tuple":
        return FromTuple15(schema_, references_, value15);
      case "Union":
        return FromUnion20(schema_, references_, value15);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return DefaultClone2(schema3, references, value15);
      default:
        return Default7(schema_, references_, value15);
    }
  };
  var Cast3 = function(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cast = exports.ValueCastError = undefined;
  var index_1 = require_guard2();
  var index_2 = require_error2();
  var index_3 = require_symbols2();
  var index_4 = require_create2();
  var index_5 = require_check2();
  var index_6 = require_clone2();
  var index_7 = require_deref2();

  class ValueCastError2 extends index_2.TypeBoxError {
    constructor(schema3, message) {
      super(message);
      this.schema = schema3;
    }
  }
  exports.ValueCastError = ValueCastError2;
  exports.Cast = Cast3;
});

// node_modules/@sinclair/typebox/build/require/value/cast/index.js
var require_cast2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_cast(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/clean/clean.js
var require_clean = __commonJS((exports) => {
  var IsCheckable3 = function(schema3) {
    return (0, type_1.IsSchema)(schema3) && schema3[index_5.Kind] !== "Unsafe";
  };
  var FromArray16 = function(schema3, references, value15) {
    if (!(0, index_6.IsArray)(value15))
      return value15;
    return value15.map((value16) => Visit17(schema3.items, references, value16));
  };
  var FromIntersect18 = function(schema3, references, value15) {
    const unevaluatedProperties = schema3.unevaluatedProperties;
    const intersections = schema3.allOf.map((schema4) => Visit17(schema4, references, (0, index_3.Clone)(value15)));
    const composite4 = intersections.reduce((acc, value16) => (0, index_6.IsObject)(value16) ? { ...acc, ...value16 } : value16, {});
    if (!(0, index_6.IsObject)(value15) || !(0, index_6.IsObject)(composite4) || !(0, type_1.IsSchema)(unevaluatedProperties))
      return composite4;
    const knownkeys = (0, index_1.KeyOfPropertyKeys)(schema3);
    for (const key of Object.getOwnPropertyNames(value15)) {
      if (knownkeys.includes(key))
        continue;
      if ((0, index_2.Check)(unevaluatedProperties, references, value15[key])) {
        composite4[key] = Visit17(unevaluatedProperties, references, value15[key]);
      }
    }
    return composite4;
  };
  var FromObject13 = function(schema3, references, value15) {
    if (!(0, index_6.IsObject)(value15) || (0, index_6.IsArray)(value15))
      return value15;
    const additionalProperties = schema3.additionalProperties;
    for (const key of Object.getOwnPropertyNames(value15)) {
      if (key in schema3.properties) {
        value15[key] = Visit17(schema3.properties[key], references, value15[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value15[key])) {
        value15[key] = Visit17(additionalProperties, references, value15[key]);
        continue;
      }
      delete value15[key];
    }
    return value15;
  };
  var FromRecord12 = function(schema3, references, value15) {
    if (!(0, index_6.IsObject)(value15))
      return value15;
    const additionalProperties = schema3.additionalProperties;
    const propertyKeys = Object.keys(value15);
    const [propertyKey, propertySchema] = Object.entries(schema3.patternProperties)[0];
    const propertyKeyTest = new RegExp(propertyKey);
    for (const key of propertyKeys) {
      if (propertyKeyTest.test(key)) {
        value15[key] = Visit17(propertySchema, references, value15[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value15[key])) {
        value15[key] = Visit17(additionalProperties, references, value15[key]);
        continue;
      }
      delete value15[key];
    }
    return value15;
  };
  var FromRef12 = function(schema3, references, value15) {
    return Visit17((0, index_4.Deref)(schema3, references), references, value15);
  };
  var FromThis11 = function(schema3, references, value15) {
    return Visit17((0, index_4.Deref)(schema3, references), references, value15);
  };
  var FromTuple15 = function(schema3, references, value15) {
    if (!(0, index_6.IsArray)(value15))
      return value15;
    if ((0, index_6.IsUndefined)(schema3.items))
      return [];
    const length = Math.min(value15.length, schema3.items.length);
    for (let i = 0;i < length; i++) {
      value15[i] = Visit17(schema3.items[i], references, value15[i]);
    }
    return value15.length > length ? value15.slice(0, length) : value15;
  };
  var FromUnion20 = function(schema3, references, value15) {
    for (const inner of schema3.anyOf) {
      if (IsCheckable3(inner) && (0, index_2.Check)(inner, value15)) {
        return Visit17(inner, references, value15);
      }
    }
    return value15;
  };
  var Visit17 = function(schema3, references, value15) {
    const references_ = (0, index_6.IsString)(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema_[index_5.Kind]) {
      case "Array":
        return FromArray16(schema_, references_, value15);
      case "Intersect":
        return FromIntersect18(schema_, references_, value15);
      case "Object":
        return FromObject13(schema_, references_, value15);
      case "Record":
        return FromRecord12(schema_, references_, value15);
      case "Ref":
        return FromRef12(schema_, references_, value15);
      case "This":
        return FromThis11(schema_, references_, value15);
      case "Tuple":
        return FromTuple15(schema_, references_, value15);
      case "Union":
        return FromUnion20(schema_, references_, value15);
      default:
        return value15;
    }
  };
  var Clean3 = function(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clean = undefined;
  var index_1 = require_keyof2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_symbols2();
  var index_6 = require_guard2();
  var type_1 = require_type3();
  exports.Clean = Clean3;
});

// node_modules/@sinclair/typebox/build/require/value/clean/index.js
var require_clean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clean(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/convert/convert.js
var require_convert = __commonJS((exports) => {
  var IsStringNumeric2 = function(value15) {
    return (0, index_5.IsString)(value15) && !isNaN(value15) && !isNaN(parseFloat(value15));
  };
  var IsValueToString2 = function(value15) {
    return (0, index_5.IsBigInt)(value15) || (0, index_5.IsBoolean)(value15) || (0, index_5.IsNumber)(value15);
  };
  var IsValueTrue2 = function(value15) {
    return value15 === true || (0, index_5.IsNumber)(value15) && value15 === 1 || (0, index_5.IsBigInt)(value15) && value15 === BigInt("1") || (0, index_5.IsString)(value15) && (value15.toLowerCase() === "true" || value15 === "1");
  };
  var IsValueFalse2 = function(value15) {
    return value15 === false || (0, index_5.IsNumber)(value15) && (value15 === 0 || Object.is(value15, -0)) || (0, index_5.IsBigInt)(value15) && value15 === BigInt("0") || (0, index_5.IsString)(value15) && (value15.toLowerCase() === "false" || value15 === "0" || value15 === "-0");
  };
  var IsTimeStringWithTimeZone2 = function(value15) {
    return (0, index_5.IsString)(value15) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value15);
  };
  var IsTimeStringWithoutTimeZone2 = function(value15) {
    return (0, index_5.IsString)(value15) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value15);
  };
  var IsDateTimeStringWithTimeZone2 = function(value15) {
    return (0, index_5.IsString)(value15) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value15);
  };
  var IsDateTimeStringWithoutTimeZone2 = function(value15) {
    return (0, index_5.IsString)(value15) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value15);
  };
  var IsDateString2 = function(value15) {
    return (0, index_5.IsString)(value15) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value15);
  };
  var TryConvertLiteralString2 = function(value15, target) {
    const conversion = TryConvertString2(value15);
    return conversion === target ? conversion : value15;
  };
  var TryConvertLiteralNumber2 = function(value15, target) {
    const conversion = TryConvertNumber2(value15);
    return conversion === target ? conversion : value15;
  };
  var TryConvertLiteralBoolean2 = function(value15, target) {
    const conversion = TryConvertBoolean2(value15);
    return conversion === target ? conversion : value15;
  };
  var TryConvertLiteral2 = function(schema3, value15) {
    return (0, index_5.IsString)(schema3.const) ? TryConvertLiteralString2(value15, schema3.const) : (0, index_5.IsNumber)(schema3.const) ? TryConvertLiteralNumber2(value15, schema3.const) : (0, index_5.IsBoolean)(schema3.const) ? TryConvertLiteralBoolean2(value15, schema3.const) : (0, index_1.Clone)(value15);
  };
  var TryConvertBoolean2 = function(value15) {
    return IsValueTrue2(value15) ? true : IsValueFalse2(value15) ? false : value15;
  };
  var TryConvertBigInt2 = function(value15) {
    return IsStringNumeric2(value15) ? BigInt(parseInt(value15)) : (0, index_5.IsNumber)(value15) ? BigInt(value15 | 0) : IsValueFalse2(value15) ? BigInt(0) : IsValueTrue2(value15) ? BigInt(1) : value15;
  };
  var TryConvertString2 = function(value15) {
    return IsValueToString2(value15) ? value15.toString() : (0, index_5.IsSymbol)(value15) && value15.description !== undefined ? value15.description.toString() : value15;
  };
  var TryConvertNumber2 = function(value15) {
    return IsStringNumeric2(value15) ? parseFloat(value15) : IsValueTrue2(value15) ? 1 : IsValueFalse2(value15) ? 0 : value15;
  };
  var TryConvertInteger2 = function(value15) {
    return IsStringNumeric2(value15) ? parseInt(value15) : (0, index_5.IsNumber)(value15) ? value15 | 0 : IsValueTrue2(value15) ? 1 : IsValueFalse2(value15) ? 0 : value15;
  };
  var TryConvertNull2 = function(value15) {
    return (0, index_5.IsString)(value15) && value15.toLowerCase() === "null" ? null : value15;
  };
  var TryConvertUndefined2 = function(value15) {
    return (0, index_5.IsString)(value15) && value15 === "undefined" ? undefined : value15;
  };
  var TryConvertDate2 = function(value15) {
    return (0, index_5.IsDate)(value15) ? value15 : (0, index_5.IsNumber)(value15) ? new Date(value15) : IsValueTrue2(value15) ? new Date(1) : IsValueFalse2(value15) ? new Date(0) : IsStringNumeric2(value15) ? new Date(parseInt(value15)) : IsTimeStringWithoutTimeZone2(value15) ? new Date(`1970-01-01T${value15}.000Z`) : IsTimeStringWithTimeZone2(value15) ? new Date(`1970-01-01T${value15}`) : IsDateTimeStringWithoutTimeZone2(value15) ? new Date(`${value15}.000Z`) : IsDateTimeStringWithTimeZone2(value15) ? new Date(value15) : IsDateString2(value15) ? new Date(`${value15}T00:00:00.000Z`) : value15;
  };
  var Default7 = function(value15) {
    return value15;
  };
  var FromArray16 = function(schema3, references, value15) {
    const elements = (0, index_5.IsArray)(value15) ? value15 : [value15];
    return elements.map((element) => Visit17(schema3.items, references, element));
  };
  var FromBigInt6 = function(schema3, references, value15) {
    return TryConvertBigInt2(value15);
  };
  var FromBoolean6 = function(schema3, references, value15) {
    return TryConvertBoolean2(value15);
  };
  var FromDate6 = function(schema3, references, value15) {
    return TryConvertDate2(value15);
  };
  var FromInteger6 = function(schema3, references, value15) {
    return TryConvertInteger2(value15);
  };
  var FromIntersect18 = function(schema3, references, value15) {
    return schema3.allOf.reduce((value16, schema4) => Visit17(schema4, references, value16), value15);
  };
  var FromLiteral7 = function(schema3, references, value15) {
    return TryConvertLiteral2(schema3, value15);
  };
  var FromNull6 = function(schema3, references, value15) {
    return TryConvertNull2(value15);
  };
  var FromNumber6 = function(schema3, references, value15) {
    return TryConvertNumber2(value15);
  };
  var FromObject13 = function(schema3, references, value15) {
    const isConvertable = (0, index_5.IsObject)(value15);
    if (!isConvertable)
      return value15;
    return Object.getOwnPropertyNames(schema3.properties).reduce((value16, key) => {
      return !(0, index_5.IsUndefined)(value16[key]) ? { ...value16, [key]: Visit17(schema3.properties[key], references, value16[key]) } : { ...value16 };
    }, value15);
  };
  var FromRecord12 = function(schema3, references, value15) {
    const propertyKey = Object.getOwnPropertyNames(schema3.patternProperties)[0];
    const property = schema3.patternProperties[propertyKey];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value15)) {
      result[propKey] = Visit17(property, references, propValue);
    }
    return result;
  };
  var FromRef12 = function(schema3, references, value15) {
    return Visit17((0, index_3.Deref)(schema3, references), references, value15);
  };
  var FromString6 = function(schema3, references, value15) {
    return TryConvertString2(value15);
  };
  var FromSymbol6 = function(schema3, references, value15) {
    return (0, index_5.IsString)(value15) || (0, index_5.IsNumber)(value15) ? Symbol(value15) : value15;
  };
  var FromThis11 = function(schema3, references, value15) {
    return Visit17((0, index_3.Deref)(schema3, references), references, value15);
  };
  var FromTuple15 = function(schema3, references, value15) {
    const isConvertable = (0, index_5.IsArray)(value15) && !(0, index_5.IsUndefined)(schema3.items);
    if (!isConvertable)
      return value15;
    return value15.map((value16, index) => {
      return index < schema3.items.length ? Visit17(schema3.items[index], references, value16) : value16;
    });
  };
  var FromUndefined6 = function(schema3, references, value15) {
    return TryConvertUndefined2(value15);
  };
  var FromUnion20 = function(schema3, references, value15) {
    for (const subschema of schema3.anyOf) {
      const converted = Visit17(subschema, references, value15);
      if (!(0, index_2.Check)(subschema, references, converted))
        continue;
      return converted;
    }
    return value15;
  };
  var Visit17 = function(schema3, references, value15) {
    const references_ = (0, index_5.IsString)(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema3[index_4.Kind]) {
      case "Array":
        return FromArray16(schema_, references_, value15);
      case "BigInt":
        return FromBigInt6(schema_, references_, value15);
      case "Boolean":
        return FromBoolean6(schema_, references_, value15);
      case "Date":
        return FromDate6(schema_, references_, value15);
      case "Integer":
        return FromInteger6(schema_, references_, value15);
      case "Intersect":
        return FromIntersect18(schema_, references_, value15);
      case "Literal":
        return FromLiteral7(schema_, references_, value15);
      case "Null":
        return FromNull6(schema_, references_, value15);
      case "Number":
        return FromNumber6(schema_, references_, value15);
      case "Object":
        return FromObject13(schema_, references_, value15);
      case "Record":
        return FromRecord12(schema_, references_, value15);
      case "Ref":
        return FromRef12(schema_, references_, value15);
      case "String":
        return FromString6(schema_, references_, value15);
      case "Symbol":
        return FromSymbol6(schema_, references_, value15);
      case "This":
        return FromThis11(schema_, references_, value15);
      case "Tuple":
        return FromTuple15(schema_, references_, value15);
      case "Undefined":
        return FromUndefined6(schema_, references_, value15);
      case "Union":
        return FromUnion20(schema_, references_, value15);
      default:
        return Default7(value15);
    }
  };
  var Convert3 = function(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Convert = undefined;
  var index_1 = require_clone2();
  var index_2 = require_check2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  exports.Convert = Convert3;
});

// node_modules/@sinclair/typebox/build/require/value/convert/index.js
var require_convert2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_convert(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/default/default.js
var require_default = __commonJS((exports) => {
  var ValueOrDefault2 = function(schema3, value15) {
    return value15 === undefined && "default" in schema3 ? (0, index_2.Clone)(schema3.default) : value15;
  };
  var IsCheckable3 = function(schema3) {
    return (0, type_1.IsSchema)(schema3) && schema3[index_4.Kind] !== "Unsafe";
  };
  var IsDefaultSchema2 = function(value15) {
    return (0, type_1.IsSchema)(value15) && "default" in value15;
  };
  var FromArray16 = function(schema3, references, value15) {
    const defaulted = ValueOrDefault2(schema3, value15);
    if (!(0, index_5.IsArray)(defaulted))
      return defaulted;
    for (let i = 0;i < defaulted.length; i++) {
      defaulted[i] = Visit17(schema3.items, references, defaulted[i]);
    }
    return defaulted;
  };
  var FromIntersect18 = function(schema3, references, value15) {
    const defaulted = ValueOrDefault2(schema3, value15);
    return schema3.allOf.reduce((acc, schema4) => {
      const next = Visit17(schema4, references, defaulted);
      return (0, index_5.IsObject)(next) ? { ...acc, ...next } : next;
    }, {});
  };
  var FromObject13 = function(schema3, references, value15) {
    const defaulted = ValueOrDefault2(schema3, value15);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema3.additionalProperties;
    const knownPropertyKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const key of knownPropertyKeys) {
      if (!IsDefaultSchema2(schema3.properties[key]))
        continue;
      defaulted[key] = Visit17(schema3.properties[key], references, defaulted[key]);
    }
    if (!IsDefaultSchema2(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKeys.includes(key))
        continue;
      defaulted[key] = Visit17(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  };
  var FromRecord12 = function(schema3, references, value15) {
    const defaulted = ValueOrDefault2(schema3, value15);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema3.additionalProperties;
    const [propertyKeyPattern, propertySchema] = Object.entries(schema3.patternProperties)[0];
    const knownPropertyKey = new RegExp(propertyKeyPattern);
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (!(knownPropertyKey.test(key) && IsDefaultSchema2(propertySchema)))
        continue;
      defaulted[key] = Visit17(propertySchema, references, defaulted[key]);
    }
    if (!IsDefaultSchema2(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKey.test(key))
        continue;
      defaulted[key] = Visit17(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  };
  var FromRef12 = function(schema3, references, value15) {
    return Visit17((0, index_3.Deref)(schema3, references), references, ValueOrDefault2(schema3, value15));
  };
  var FromThis11 = function(schema3, references, value15) {
    return Visit17((0, index_3.Deref)(schema3, references), references, value15);
  };
  var FromTuple15 = function(schema3, references, value15) {
    const defaulted = ValueOrDefault2(schema3, value15);
    if (!(0, index_5.IsArray)(defaulted) || (0, index_5.IsUndefined)(schema3.items))
      return defaulted;
    const [items, max] = [schema3.items, Math.max(schema3.items.length, defaulted.length)];
    for (let i = 0;i < max; i++) {
      if (i < items.length)
        defaulted[i] = Visit17(items[i], references, defaulted[i]);
    }
    return defaulted;
  };
  var FromUnion20 = function(schema3, references, value15) {
    const defaulted = ValueOrDefault2(schema3, value15);
    for (const inner of schema3.anyOf) {
      const result = Visit17(inner, references, defaulted);
      if (IsCheckable3(inner) && (0, index_1.Check)(inner, result)) {
        return result;
      }
    }
    return defaulted;
  };
  var Visit17 = function(schema3, references, value15) {
    const references_ = (0, index_5.IsString)(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema_[index_4.Kind]) {
      case "Array":
        return FromArray16(schema_, references_, value15);
      case "Intersect":
        return FromIntersect18(schema_, references_, value15);
      case "Object":
        return FromObject13(schema_, references_, value15);
      case "Record":
        return FromRecord12(schema_, references_, value15);
      case "Ref":
        return FromRef12(schema_, references_, value15);
      case "This":
        return FromThis11(schema_, references_, value15);
      case "Tuple":
        return FromTuple15(schema_, references_, value15);
      case "Union":
        return FromUnion20(schema_, references_, value15);
      default:
        return ValueOrDefault2(schema_, value15);
    }
  };
  var Default7 = function(...args) {
    return args.length === 3 ? Visit17(args[0], args[1], args[2]) : Visit17(args[0], [], args[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Default = undefined;
  var index_1 = require_check2();
  var index_2 = require_clone2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  var type_1 = require_type3();
  exports.Default = Default7;
});

// node_modules/@sinclair/typebox/build/require/value/default/index.js
var require_default2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_default(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/pointer/pointer.js
var require_pointer = __commonJS((exports) => {
  var Escape3 = function(component) {
    return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
  };
  function* Format2(pointer4) {
    if (pointer4 === "")
      return;
    let [start, end] = [0, 0];
    for (let i = 0;i < pointer4.length; i++) {
      const char = pointer4.charAt(i);
      if (char === "/") {
        if (i === 0) {
          start = i + 1;
        } else {
          end = i;
          yield Escape3(pointer4.slice(start, end));
          start = i + 1;
        }
      } else {
        end = i;
      }
    }
    yield Escape3(pointer4.slice(start));
  }
  var Set5 = function(value15, pointer4, update) {
    if (pointer4 === "")
      throw new ValuePointerRootSetError2(value15, pointer4, update);
    let [owner, next, key] = [null, value15, ""];
    for (const component of Format2(pointer4)) {
      if (next[component] === undefined)
        next[component] = {};
      owner = next;
      next = next[component];
      key = component;
    }
    owner[key] = update;
  };
  var Delete5 = function(value15, pointer4) {
    if (pointer4 === "")
      throw new ValuePointerRootDeleteError2(value15, pointer4);
    let [owner, next, key] = [null, value15, ""];
    for (const component of Format2(pointer4)) {
      if (next[component] === undefined || next[component] === null)
        return;
      owner = next;
      next = next[component];
      key = component;
    }
    if (Array.isArray(owner)) {
      const index = parseInt(key);
      owner.splice(index, 1);
    } else {
      delete owner[key];
    }
  };
  var Has4 = function(value15, pointer4) {
    if (pointer4 === "")
      return true;
    let [owner, next, key] = [null, value15, ""];
    for (const component of Format2(pointer4)) {
      if (next[component] === undefined)
        return false;
      owner = next;
      next = next[component];
      key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
  };
  var Get4 = function(value15, pointer4) {
    if (pointer4 === "")
      return value15;
    let current = value15;
    for (const component of Format2(pointer4)) {
      if (current[component] === undefined)
        return;
      current = current[component];
    }
    return current;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Get = exports.Has = exports.Delete = exports.Set = exports.Format = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = undefined;
  var index_1 = require_error2();

  class ValuePointerRootSetError2 extends index_1.TypeBoxError {
    constructor(value15, path, update) {
      super("Cannot set root value");
      this.value = value15;
      this.path = path;
      this.update = update;
    }
  }
  exports.ValuePointerRootSetError = ValuePointerRootSetError2;

  class ValuePointerRootDeleteError2 extends index_1.TypeBoxError {
    constructor(value15, path) {
      super("Cannot delete root value");
      this.value = value15;
      this.path = path;
    }
  }
  exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError2;
  exports.Format = Format2;
  exports.Set = Set5;
  exports.Delete = Delete5;
  exports.Has = Has4;
  exports.Get = Get4;
});

// node_modules/@sinclair/typebox/build/require/value/pointer/index.js
var require_pointer2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointer = undefined;
  exports.ValuePointer = require_pointer();
});

// node_modules/@sinclair/typebox/build/require/value/delta/delta.js
var require_delta = __commonJS((exports) => {
  var CreateUpdate2 = function(path, value15) {
    return { type: "update", path, value: value15 };
  };
  var CreateInsert2 = function(path, value15) {
    return { type: "insert", path, value: value15 };
  };
  var CreateDelete2 = function(path) {
    return { type: "delete", path };
  };
  function* ObjectType7(path, current, next) {
    if (!(0, index_1.IsStandardObject)(next))
      return yield CreateUpdate2(path, next);
    const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
    const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError2(key);
      if ((0, index_1.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate2(`${path}/${globalThis.String(key)}`, undefined);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsUndefined)(current[key]) || (0, index_1.IsUndefined)(next[key]))
        continue;
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError2(key);
      yield* Visit17(`${path}/${globalThis.String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError2(key);
      if ((0, index_1.IsUndefined)(current[key]))
        yield CreateInsert2(`${path}/${globalThis.String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError2(key);
      if ((0, index_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete2(`${path}/${globalThis.String(key)}`);
    }
  }
  function* ArrayType7(path, current, next) {
    if (!(0, index_1.IsArray)(next))
      return yield CreateUpdate2(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit17(`${path}/${i}`, current[i], next[i]);
    }
    for (let i = 0;i < next.length; i++) {
      if (i < current.length)
        continue;
      yield CreateInsert2(`${path}/${i}`, next[i]);
    }
    for (let i = current.length - 1;i >= 0; i--) {
      if (i < next.length)
        continue;
      yield CreateDelete2(`${path}/${i}`);
    }
  }
  function* TypedArrayType5(path, current, next) {
    if (!(0, index_1.IsTypedArray)(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate2(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit17(`${path}/${i}`, current[i], next[i]);
    }
  }
  function* ValueType5(path, current, next) {
    if (current === next)
      return;
    yield CreateUpdate2(path, next);
  }
  function* Visit17(path, current, next) {
    if ((0, index_1.IsStandardObject)(current))
      return yield* ObjectType7(path, current, next);
    if ((0, index_1.IsArray)(current))
      return yield* ArrayType7(path, current, next);
    if ((0, index_1.IsTypedArray)(current))
      return yield* TypedArrayType5(path, current, next);
    if ((0, index_1.IsValueType)(current))
      return yield* ValueType5(path, current, next);
    throw new ValueDeltaError2(current, "Unable to create diff edits for unknown value");
  }
  var Diff3 = function(current, next) {
    return [...Visit17("", current, next)];
  };
  var IsRootUpdate2 = function(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  };
  var IsIdentity2 = function(edits) {
    return edits.length === 0;
  };
  var Patch3 = function(current, edits) {
    if (IsRootUpdate2(edits)) {
      return (0, index_3.Clone)(edits[0].value);
    }
    if (IsIdentity2(edits)) {
      return (0, index_3.Clone)(current);
    }
    const clone13 = (0, index_3.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          index_2.ValuePointer.Set(clone13, edit.path, edit.value);
          break;
        }
        case "update": {
          index_2.ValuePointer.Set(clone13, edit.path, edit.value);
          break;
        }
        case "delete": {
          index_2.ValuePointer.Delete(clone13, edit.path);
          break;
        }
      }
    }
    return clone13;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Patch = exports.Diff = exports.ValueDeltaSymbolError = exports.ValueDeltaError = exports.Edit = exports.Delete = exports.Update = exports.Insert = undefined;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();
  var index_5 = require_literal2();
  var index_6 = require_object2();
  var index_7 = require_string2();
  var index_8 = require_unknown2();
  var index_9 = require_union2();
  exports.Insert = (0, index_6.Object)({
    type: (0, index_5.Literal)("insert"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Update = (0, index_6.Object)({
    type: (0, index_5.Literal)("update"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Delete = (0, index_6.Object)({
    type: (0, index_5.Literal)("delete"),
    path: (0, index_7.String)()
  });
  exports.Edit = (0, index_9.Union)([exports.Insert, exports.Update, exports.Delete]);

  class ValueDeltaError2 extends index_4.TypeBoxError {
    constructor(value15, message) {
      super(message);
      this.value = value15;
    }
  }
  exports.ValueDeltaError = ValueDeltaError2;

  class ValueDeltaSymbolError2 extends ValueDeltaError2 {
    constructor(value15) {
      super(value15, "Cannot diff objects with symbol keys");
      this.value = value15;
    }
  }
  exports.ValueDeltaSymbolError = ValueDeltaSymbolError2;
  exports.Diff = Diff3;
  exports.Patch = Patch3;
});

// node_modules/@sinclair/typebox/build/require/value/delta/index.js
var require_delta2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_delta(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/equal/equal.js
var require_equal = __commonJS((exports) => {
  var ObjectType7 = function(left, right) {
    if (!(0, index_1.IsStandardObject)(right))
      return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
      return false;
    return leftKeys.every((key) => Equal3(left[key], right[key]));
  };
  var DateType5 = function(left, right) {
    return (0, index_1.IsDate)(right) && left.getTime() === right.getTime();
  };
  var ArrayType7 = function(left, right) {
    if (!(0, index_1.IsArray)(right) || left.length !== right.length)
      return false;
    return left.every((value15, index) => Equal3(value15, right[index]));
  };
  var TypedArrayType5 = function(left, right) {
    if (!(0, index_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
      return false;
    return left.every((value15, index) => Equal3(value15, right[index]));
  };
  var ValueType5 = function(left, right) {
    return left === right;
  };
  var Equal3 = function(left, right) {
    if ((0, index_1.IsStandardObject)(left))
      return ObjectType7(left, right);
    if ((0, index_1.IsDate)(left))
      return DateType5(left, right);
    if ((0, index_1.IsTypedArray)(left))
      return TypedArrayType5(left, right);
    if ((0, index_1.IsArray)(left))
      return ArrayType7(left, right);
    if ((0, index_1.IsValueType)(left))
      return ValueType5(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Equal = undefined;
  var index_1 = require_guard2();
  exports.Equal = Equal3;
});

// node_modules/@sinclair/typebox/build/require/value/equal/index.js
var require_equal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_equal(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/mutate/mutate.js
var require_mutate = __commonJS((exports) => {
  var ObjectType7 = function(root, path, current, next) {
    if (!(0, index_1.IsStandardObject)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      const currentKeys = Object.keys(current);
      const nextKeys = Object.keys(next);
      for (const currentKey of currentKeys) {
        if (!nextKeys.includes(currentKey)) {
          delete current[currentKey];
        }
      }
      for (const nextKey of nextKeys) {
        if (!currentKeys.includes(nextKey)) {
          current[nextKey] = null;
        }
      }
      for (const nextKey of nextKeys) {
        Visit17(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
      }
    }
  };
  var ArrayType7 = function(root, path, current, next) {
    if (!(0, index_1.IsArray)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      for (let index = 0;index < next.length; index++) {
        Visit17(root, `${path}/${index}`, current[index], next[index]);
      }
      current.splice(next.length);
    }
  };
  var TypedArrayType5 = function(root, path, current, next) {
    if ((0, index_1.IsTypedArray)(current) && current.length === next.length) {
      for (let i = 0;i < current.length; i++) {
        current[i] = next[i];
      }
    } else {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    }
  };
  var ValueType5 = function(root, path, current, next) {
    if (current === next)
      return;
    index_2.ValuePointer.Set(root, path, next);
  };
  var Visit17 = function(root, path, current, next) {
    if ((0, index_1.IsArray)(next))
      return ArrayType7(root, path, current, next);
    if ((0, index_1.IsTypedArray)(next))
      return TypedArrayType5(root, path, current, next);
    if ((0, index_1.IsStandardObject)(next))
      return ObjectType7(root, path, current, next);
    if ((0, index_1.IsValueType)(next))
      return ValueType5(root, path, current, next);
  };
  var IsNonMutableValue2 = function(value15) {
    return (0, index_1.IsTypedArray)(value15) || (0, index_1.IsValueType)(value15);
  };
  var IsMismatchedValue2 = function(current, next) {
    return (0, index_1.IsStandardObject)(current) && (0, index_1.IsArray)(next) || (0, index_1.IsArray)(current) && (0, index_1.IsStandardObject)(next);
  };
  var Mutate3 = function(current, next) {
    if (IsNonMutableValue2(current) || IsNonMutableValue2(next))
      throw new ValueMutateError2("Only object and array types can be mutated at the root level");
    if (IsMismatchedValue2(current, next))
      throw new ValueMutateError2("Cannot assign due type mismatch of assignable values");
    Visit17(current, "", current, next);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Mutate = exports.ValueMutateError = undefined;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();

  class ValueMutateError2 extends index_4.TypeBoxError {
    constructor(message) {
      super(message);
    }
  }
  exports.ValueMutateError = ValueMutateError2;
  exports.Mutate = Mutate3;
});

// node_modules/@sinclair/typebox/build/require/value/mutate/index.js
var require_mutate2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mutate(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/transform/decode.js
var require_decode = __commonJS((exports) => {
  var Default7 = function(schema3, path, value15) {
    try {
      return (0, type_1.IsTransform)(schema3) ? schema3[index_1.TransformKind].Decode(value15) : value15;
    } catch (error23) {
      throw new TransformDecodeError2(schema3, path, value15, error23);
    }
  };
  var FromArray16 = function(schema3, references, path, value15) {
    return (0, index_7.IsArray)(value15) ? Default7(schema3, path, value15.map((value16, index) => Visit17(schema3.items, references, `${path}/${index}`, value16))) : Default7(schema3, path, value15);
  };
  var FromIntersect18 = function(schema3, references, path, value15) {
    if (!(0, index_7.IsStandardObject)(value15) || (0, index_7.IsValueType)(value15))
      return Default7(schema3, path, value15);
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema3);
    const knownProperties = knownKeys.reduce((value16, key) => {
      return key in value16 ? { ...value16, [key]: Visit17((0, index_4.Index)(schema3, [key]), references, `${path}/${key}`, value16[key]) } : value16;
    }, value15);
    if (!(0, type_1.IsTransform)(schema3.unevaluatedProperties)) {
      return Default7(schema3, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema3.unevaluatedProperties;
    const unknownProperties = unknownKeys.reduce((value16, key) => {
      return !knownKeys.includes(key) ? { ...value16, [key]: Default7(unevaluatedProperties, `${path}/${key}`, value16[key]) } : value16;
    }, knownProperties);
    return Default7(schema3, path, unknownProperties);
  };
  var FromNot8 = function(schema3, references, path, value15) {
    return Default7(schema3, path, Visit17(schema3.not, references, path, value15));
  };
  var FromObject13 = function(schema3, references, path, value15) {
    if (!(0, index_7.IsStandardObject)(value15))
      return Default7(schema3, path, value15);
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema3);
    const knownProperties = knownKeys.reduce((value16, key) => {
      return key in value16 ? { ...value16, [key]: Visit17(schema3.properties[key], references, `${path}/${key}`, value16[key]) } : value16;
    }, value15);
    if (!(0, type_1.IsSchema)(schema3.additionalProperties)) {
      return Default7(schema3, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema3.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value16, key) => {
      return !knownKeys.includes(key) ? { ...value16, [key]: Default7(additionalProperties, `${path}/${key}`, value16[key]) } : value16;
    }, knownProperties);
    return Default7(schema3, path, unknownProperties);
  };
  var FromRecord12 = function(schema3, references, path, value15) {
    if (!(0, index_7.IsStandardObject)(value15))
      return Default7(schema3, path, value15);
    const pattern3 = Object.getOwnPropertyNames(schema3.patternProperties)[0];
    const knownKeys = new RegExp(pattern3);
    const knownProperties = Object.getOwnPropertyNames(value15).reduce((value16, key) => {
      return knownKeys.test(key) ? { ...value16, [key]: Visit17(schema3.patternProperties[pattern3], references, `${path}/${key}`, value16[key]) } : value16;
    }, value15);
    if (!(0, type_1.IsSchema)(schema3.additionalProperties)) {
      return Default7(schema3, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema3.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value16, key) => {
      return !knownKeys.test(key) ? { ...value16, [key]: Default7(additionalProperties, `${path}/${key}`, value16[key]) } : value16;
    }, knownProperties);
    return Default7(schema3, path, unknownProperties);
  };
  var FromRef12 = function(schema3, references, path, value15) {
    const target = (0, index_5.Deref)(schema3, references);
    return Default7(schema3, path, Visit17(target, references, path, value15));
  };
  var FromThis11 = function(schema3, references, path, value15) {
    const target = (0, index_5.Deref)(schema3, references);
    return Default7(schema3, path, Visit17(target, references, path, value15));
  };
  var FromTuple15 = function(schema3, references, path, value15) {
    return (0, index_7.IsArray)(value15) && (0, index_7.IsArray)(schema3.items) ? Default7(schema3, path, schema3.items.map((schema4, index) => Visit17(schema4, references, `${path}/${index}`, value15[index]))) : Default7(schema3, path, value15);
  };
  var FromUnion20 = function(schema3, references, path, value15) {
    for (const subschema of schema3.anyOf) {
      if (!(0, index_6.Check)(subschema, references, value15))
        continue;
      const decoded = Visit17(subschema, references, path, value15);
      return Default7(schema3, path, decoded);
    }
    return Default7(schema3, path, value15);
  };
  var Visit17 = function(schema3, references, path, value15) {
    const references_ = typeof schema3.$id === "string" ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema3[index_1.Kind]) {
      case "Array":
        return FromArray16(schema_, references_, path, value15);
      case "Intersect":
        return FromIntersect18(schema_, references_, path, value15);
      case "Not":
        return FromNot8(schema_, references_, path, value15);
      case "Object":
        return FromObject13(schema_, references_, path, value15);
      case "Record":
        return FromRecord12(schema_, references_, path, value15);
      case "Ref":
        return FromRef12(schema_, references_, path, value15);
      case "Symbol":
        return Default7(schema_, path, value15);
      case "This":
        return FromThis11(schema_, references_, path, value15);
      case "Tuple":
        return FromTuple15(schema_, references_, path, value15);
      case "Union":
        return FromUnion20(schema_, references_, path, value15);
      default:
        return Default7(schema_, path, value15);
    }
  };
  var TransformDecode2 = function(schema3, references, value15) {
    return Visit17(schema3, references, "", value15);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformDecode = exports.TransformDecodeError = exports.TransformDecodeCheckError = undefined;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_indexed2();
  var index_5 = require_deref2();
  var index_6 = require_check2();
  var index_7 = require_guard2();
  var type_1 = require_type3();

  class TransformDecodeCheckError2 extends index_2.TypeBoxError {
    constructor(schema3, value15, error23) {
      super(`Unable to decode value as it does not match the expected schema`);
      this.schema = schema3;
      this.value = value15;
      this.error = error23;
    }
  }
  exports.TransformDecodeCheckError = TransformDecodeCheckError2;

  class TransformDecodeError2 extends index_2.TypeBoxError {
    constructor(schema3, path, value15, error23) {
      super(error23 instanceof Error ? error23.message : "Unknown error");
      this.schema = schema3;
      this.path = path;
      this.value = value15;
      this.error = error23;
    }
  }
  exports.TransformDecodeError = TransformDecodeError2;
  exports.TransformDecode = TransformDecode2;
});

// node_modules/@sinclair/typebox/build/require/value/transform/encode.js
var require_encode = __commonJS((exports) => {
  var Default7 = function(schema3, path, value15) {
    try {
      return (0, type_1.IsTransform)(schema3) ? schema3[index_1.TransformKind].Encode(value15) : value15;
    } catch (error23) {
      throw new TransformEncodeError2(schema3, path, value15, error23);
    }
  };
  var FromArray16 = function(schema3, references, path, value15) {
    const defaulted = Default7(schema3, path, value15);
    return (0, index_7.IsArray)(defaulted) ? defaulted.map((value16, index) => Visit17(schema3.items, references, `${path}/${index}`, value16)) : defaulted;
  };
  var FromIntersect18 = function(schema3, references, path, value15) {
    const defaulted = Default7(schema3, path, value15);
    if (!(0, index_7.IsStandardObject)(value15) || (0, index_7.IsValueType)(value15))
      return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema3);
    const knownProperties = knownKeys.reduce((value16, key) => {
      return key in defaulted ? { ...value16, [key]: Visit17((0, index_4.Index)(schema3, [key]), references, `${path}/${key}`, value16[key]) } : value16;
    }, defaulted);
    if (!(0, type_1.IsTransform)(schema3.unevaluatedProperties)) {
      return Default7(schema3, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema3.unevaluatedProperties;
    return unknownKeys.reduce((value16, key) => {
      return !knownKeys.includes(key) ? { ...value16, [key]: Default7(unevaluatedProperties, `${path}/${key}`, value16[key]) } : value16;
    }, knownProperties);
  };
  var FromNot8 = function(schema3, references, path, value15) {
    return Default7(schema3.not, path, Default7(schema3, path, value15));
  };
  var FromObject13 = function(schema3, references, path, value15) {
    const defaulted = Default7(schema3, path, value15);
    if (!(0, index_7.IsStandardObject)(value15))
      return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema3);
    const knownProperties = knownKeys.reduce((value16, key) => {
      return key in value16 ? { ...value16, [key]: Visit17(schema3.properties[key], references, `${path}/${key}`, value16[key]) } : value16;
    }, defaulted);
    if (!(0, type_1.IsSchema)(schema3.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema3.additionalProperties;
    return unknownKeys.reduce((value16, key) => {
      return !knownKeys.includes(key) ? { ...value16, [key]: Default7(additionalProperties, `${path}/${key}`, value16[key]) } : value16;
    }, knownProperties);
  };
  var FromRecord12 = function(schema3, references, path, value15) {
    const defaulted = Default7(schema3, path, value15);
    if (!(0, index_7.IsStandardObject)(value15))
      return defaulted;
    const pattern3 = Object.getOwnPropertyNames(schema3.patternProperties)[0];
    const knownKeys = new RegExp(pattern3);
    const knownProperties = Object.getOwnPropertyNames(value15).reduce((value16, key) => {
      return knownKeys.test(key) ? { ...value16, [key]: Visit17(schema3.patternProperties[pattern3], references, `${path}/${key}`, value16[key]) } : value16;
    }, defaulted);
    if (!(0, type_1.IsSchema)(schema3.additionalProperties)) {
      return Default7(schema3, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema3.additionalProperties;
    return unknownKeys.reduce((value16, key) => {
      return !knownKeys.test(key) ? { ...value16, [key]: Default7(additionalProperties, `${path}/${key}`, value16[key]) } : value16;
    }, knownProperties);
  };
  var FromRef12 = function(schema3, references, path, value15) {
    const target = (0, index_5.Deref)(schema3, references);
    const resolved = Visit17(target, references, path, value15);
    return Default7(schema3, path, resolved);
  };
  var FromThis11 = function(schema3, references, path, value15) {
    const target = (0, index_5.Deref)(schema3, references);
    const resolved = Visit17(target, references, path, value15);
    return Default7(schema3, path, resolved);
  };
  var FromTuple15 = function(schema3, references, path, value15) {
    const value1 = Default7(schema3, path, value15);
    return (0, index_7.IsArray)(schema3.items) ? schema3.items.map((schema4, index) => Visit17(schema4, references, `${path}/${index}`, value1[index])) : [];
  };
  var FromUnion20 = function(schema3, references, path, value15) {
    for (const subschema of schema3.anyOf) {
      if (!(0, index_6.Check)(subschema, references, value15))
        continue;
      const value1 = Visit17(subschema, references, path, value15);
      return Default7(schema3, path, value1);
    }
    for (const subschema of schema3.anyOf) {
      const value1 = Visit17(subschema, references, path, value15);
      if (!(0, index_6.Check)(schema3, references, value1))
        continue;
      return Default7(schema3, path, value1);
    }
    return Default7(schema3, path, value15);
  };
  var Visit17 = function(schema3, references, path, value15) {
    const references_ = typeof schema3.$id === "string" ? [...references, schema3] : references;
    const schema_ = schema3;
    switch (schema3[index_1.Kind]) {
      case "Array":
        return FromArray16(schema_, references_, path, value15);
      case "Intersect":
        return FromIntersect18(schema_, references_, path, value15);
      case "Not":
        return FromNot8(schema_, references_, path, value15);
      case "Object":
        return FromObject13(schema_, references_, path, value15);
      case "Record":
        return FromRecord12(schema_, references_, path, value15);
      case "Ref":
        return FromRef12(schema_, references_, path, value15);
      case "This":
        return FromThis11(schema_, references_, path, value15);
      case "Tuple":
        return FromTuple15(schema_, references_, path, value15);
      case "Union":
        return FromUnion20(schema_, references_, path, value15);
      default:
        return Default7(schema_, path, value15);
    }
  };
  var TransformEncode2 = function(schema3, references, value15) {
    return Visit17(schema3, references, "", value15);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformEncode = exports.TransformEncodeError = exports.TransformEncodeCheckError = undefined;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_indexed2();
  var index_5 = require_deref2();
  var index_6 = require_check2();
  var index_7 = require_guard2();
  var type_1 = require_type3();

  class TransformEncodeCheckError2 extends index_2.TypeBoxError {
    constructor(schema3, value15, error23) {
      super(`The encoded value does not match the expected schema`);
      this.schema = schema3;
      this.value = value15;
      this.error = error23;
    }
  }
  exports.TransformEncodeCheckError = TransformEncodeCheckError2;

  class TransformEncodeError2 extends index_2.TypeBoxError {
    constructor(schema3, path, value15, error23) {
      super(`${error23 instanceof Error ? error23.message : "Unknown error"}`);
      this.schema = schema3;
      this.path = path;
      this.value = value15;
      this.error = error23;
    }
  }
  exports.TransformEncodeError = TransformEncodeError2;
  exports.TransformEncode = TransformEncode2;
});

// node_modules/@sinclair/typebox/build/require/value/transform/has.js
var require_has = __commonJS((exports) => {
  var FromArray16 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Visit17(schema3.items, references);
  };
  var FromAsyncIterator7 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Visit17(schema3.items, references);
  };
  var FromConstructor8 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Visit17(schema3.returns, references) || schema3.parameters.some((schema4) => Visit17(schema4, references));
  };
  var FromFunction7 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Visit17(schema3.returns, references) || schema3.parameters.some((schema4) => Visit17(schema4, references));
  };
  var FromIntersect18 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || (0, type_1.IsTransform)(schema3.unevaluatedProperties) || schema3.allOf.some((schema4) => Visit17(schema4, references));
  };
  var FromIterator7 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Visit17(schema3.items, references);
  };
  var FromNot8 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Visit17(schema3.not, references);
  };
  var FromObject13 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Object.values(schema3.properties).some((schema4) => Visit17(schema4, references)) || (0, type_1.IsSchema)(schema3.additionalProperties) && Visit17(schema3.additionalProperties, references);
  };
  var FromPromise8 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || Visit17(schema3.item, references);
  };
  var FromRecord12 = function(schema3, references) {
    const pattern3 = Object.getOwnPropertyNames(schema3.patternProperties)[0];
    const property = schema3.patternProperties[pattern3];
    return (0, type_1.IsTransform)(schema3) || Visit17(property, references) || (0, type_1.IsSchema)(schema3.additionalProperties) && (0, type_1.IsTransform)(schema3.additionalProperties);
  };
  var FromRef12 = function(schema3, references) {
    if ((0, type_1.IsTransform)(schema3))
      return true;
    return Visit17((0, index_1.Deref)(schema3, references), references);
  };
  var FromThis11 = function(schema3, references) {
    if ((0, type_1.IsTransform)(schema3))
      return true;
    return Visit17((0, index_1.Deref)(schema3, references), references);
  };
  var FromTuple15 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || !(0, index_3.IsUndefined)(schema3.items) && schema3.items.some((schema4) => Visit17(schema4, references));
  };
  var FromUnion20 = function(schema3, references) {
    return (0, type_1.IsTransform)(schema3) || schema3.anyOf.some((schema4) => Visit17(schema4, references));
  };
  var Visit17 = function(schema3, references) {
    const references_ = (0, index_3.IsString)(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (schema3.$id && visited2.has(schema3.$id))
      return false;
    if (schema3.$id)
      visited2.add(schema3.$id);
    switch (schema3[index_2.Kind]) {
      case "Array":
        return FromArray16(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator7(schema_, references_);
      case "Constructor":
        return FromConstructor8(schema_, references_);
      case "Function":
        return FromFunction7(schema_, references_);
      case "Intersect":
        return FromIntersect18(schema_, references_);
      case "Iterator":
        return FromIterator7(schema_, references_);
      case "Not":
        return FromNot8(schema_, references_);
      case "Object":
        return FromObject13(schema_, references_);
      case "Promise":
        return FromPromise8(schema_, references_);
      case "Record":
        return FromRecord12(schema_, references_);
      case "Ref":
        return FromRef12(schema_, references_);
      case "This":
        return FromThis11(schema_, references_);
      case "Tuple":
        return FromTuple15(schema_, references_);
      case "Union":
        return FromUnion20(schema_, references_);
      default:
        return (0, type_1.IsTransform)(schema3);
    }
  };
  var HasTransform2 = function(schema3, references) {
    visited2.clear();
    return Visit17(schema3, references);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HasTransform = undefined;
  var index_1 = require_deref2();
  var index_2 = require_symbols2();
  var type_1 = require_type3();
  var index_3 = require_guard2();
  var visited2 = new Set;
  exports.HasTransform = HasTransform2;
});

// node_modules/@sinclair/typebox/build/require/value/transform/index.js
var require_transform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_decode(), exports);
  __exportStar(require_encode(), exports);
  __exportStar(require_has(), exports);
});

// node_modules/@sinclair/typebox/build/require/value/value/value.js
var require_value3 = __commonJS((exports) => {
  var Cast3 = function(...args) {
    return index_5.Cast.apply(index_5.Cast, args);
  };
  var Create4 = function(...args) {
    return index_8.Create.apply(index_8.Create, args);
  };
  var Check3 = function(...args) {
    return index_10.Check.apply(index_10.Check, args);
  };
  var Clean3 = function(...args) {
    return index_9.Clean.apply(index_9.Clean, args);
  };
  var Convert3 = function(...args) {
    return index_7.Convert.apply(index_7.Convert, args);
  };
  var Clone4 = function(value15) {
    return (0, index_6.Clone)(value15);
  };
  var Decode2 = function(...args) {
    const [schema3, references, value15] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!Check3(schema3, references, value15))
      throw new index_1.TransformDecodeCheckError(schema3, value15, Errors3(schema3, references, value15).First());
    return (0, index_1.TransformDecode)(schema3, references, value15);
  };
  var Default7 = function(...args) {
    return index_11.Default.apply(index_11.Default, args);
  };
  var Encode2 = function(...args) {
    const [schema3, references, value15] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = (0, index_1.TransformEncode)(schema3, references, value15);
    if (!Check3(schema3, references, encoded))
      throw new index_1.TransformEncodeCheckError(schema3, encoded, Errors3(schema3, references, encoded).First());
    return encoded;
  };
  var Errors3 = function(...args) {
    return index_13.Errors.apply(index_13.Errors, args);
  };
  var Equal3 = function(left, right) {
    return (0, index_4.Equal)(left, right);
  };
  var Diff3 = function(current, next) {
    return (0, index_12.Diff)(current, next);
  };
  var Hash3 = function(value15) {
    return (0, index_3.Hash)(value15);
  };
  var Patch3 = function(current, edits) {
    return (0, index_12.Patch)(current, edits);
  };
  var Mutate3 = function(current, next) {
    (0, index_2.Mutate)(current, next);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Mutate = exports.Patch = exports.Hash = exports.Diff = exports.Equal = exports.Errors = exports.Encode = exports.Default = exports.Decode = exports.Clone = exports.Convert = exports.Clean = exports.Check = exports.Create = exports.Cast = undefined;
  var index_1 = require_transform();
  var index_2 = require_mutate2();
  var index_3 = require_hash2();
  var index_4 = require_equal2();
  var index_5 = require_cast2();
  var index_6 = require_clone2();
  var index_7 = require_convert2();
  var index_8 = require_create2();
  var index_9 = require_clean2();
  var index_10 = require_check2();
  var index_11 = require_default2();
  var index_12 = require_delta2();
  var index_13 = require_errors2();
  exports.Cast = Cast3;
  exports.Create = Create4;
  exports.Check = Check3;
  exports.Clean = Clean3;
  exports.Convert = Convert3;
  exports.Clone = Clone4;
  exports.Decode = Decode2;
  exports.Default = Default7;
  exports.Encode = Encode2;
  exports.Errors = Errors3;
  exports.Equal = Equal3;
  exports.Diff = Diff3;
  exports.Hash = Hash3;
  exports.Patch = Patch3;
  exports.Mutate = Mutate3;
});

// node_modules/@sinclair/typebox/build/require/value/value/index.js
var require_value4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = undefined;
  exports.Value = require_value3();
});

// node_modules/@sinclair/typebox/build/require/value/index.js
var require_value5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_guard2(), exports);
  __exportStar(require_cast2(), exports);
  __exportStar(require_check2(), exports);
  __exportStar(require_clean2(), exports);
  __exportStar(require_clone2(), exports);
  __exportStar(require_convert2(), exports);
  __exportStar(require_create2(), exports);
  __exportStar(require_default2(), exports);
  __exportStar(require_delta2(), exports);
  __exportStar(require_equal2(), exports);
  __exportStar(require_hash2(), exports);
  __exportStar(require_mutate2(), exports);
  __exportStar(require_pointer2(), exports);
  __exportStar(require_transform(), exports);
  var index_2 = require_value4();
  Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
    return index_2.Value;
  } });
});

// node_modules/@sinclair/typebox/build/require/type/clone/index.js
var require_clone3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_type2(), exports);
  __exportStar(require_value2(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/helpers/helpers.js
var require_helpers = __commonJS((exports) => {
  var Increment = function(T) {
    return (parseInt(T) + 1).toString();
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Increment = undefined;
  exports.Increment = Increment;
});

// node_modules/@sinclair/typebox/build/require/type/helpers/index.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_helpers(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/awaited/awaited.js
var require_awaited = __commonJS((exports) => {
  var FromRest9 = function(T) {
    return T.map((L) => AwaitedResolve2(L));
  };
  var FromIntersect18 = function(T) {
    return (0, index_1.Intersect)(FromRest9(T));
  };
  var FromUnion20 = function(T) {
    return (0, index_2.Union)(FromRest9(T));
  };
  var FromPromise8 = function(T) {
    return AwaitedResolve2(T);
  };
  var AwaitedResolve2 = function(T) {
    return (0, type_2.IsIntersect)(T) ? FromIntersect18(T.allOf) : (0, type_2.IsUnion)(T) ? FromUnion20(T.anyOf) : (0, type_2.IsPromise)(T) ? FromPromise8(T.item) : T;
  };
  var Awaited2 = function(T, options = {}) {
    return (0, type_1.CloneType)(AwaitedResolve2(T), options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Awaited = undefined;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var type_1 = require_type2();
  var type_2 = require_type3();
  exports.Awaited = Awaited2;
});

// node_modules/@sinclair/typebox/build/require/type/awaited/index.js
var require_awaited2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_awaited(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/composite/composite.js
var require_composite = __commonJS((exports) => {
  var CompositeKeys2 = function(T) {
    return (0, index_5.SetDistinct)(T.reduce((Acc, L) => {
      return [...Acc, ...(0, index_3.KeyOfPropertyKeys)(L)];
    }, []));
  };
  var FilterNever2 = function(T) {
    return T.filter((L) => !(0, type_1.IsNever)(L));
  };
  var CompositeProperty2 = function(T, K) {
    return FilterNever2(T.reduce((Acc, L) => {
      return [...Acc, ...(0, index_2.IndexFromPropertyKeys)(L, [K])];
    }, []));
  };
  var CompositeProperties2 = function(T, K) {
    return K.reduce((Acc, L) => {
      return { ...Acc, [L]: (0, index_1.IntersectEvaluated)(CompositeProperty2(T, L)) };
    }, {});
  };
  var Composite2 = function(T, options = {}) {
    const K = CompositeKeys2(T);
    const P = CompositeProperties2(T, K);
    const R = (0, index_4.Object)(P, options);
    return R;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Composite = undefined;
  var index_1 = require_intersect2();
  var index_2 = require_indexed2();
  var index_3 = require_keyof2();
  var index_4 = require_object2();
  var index_5 = require_sets();
  var type_1 = require_type3();
  exports.Composite = Composite2;
});

// node_modules/@sinclair/typebox/build/require/type/composite/index.js
var require_composite2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_composite(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/date/date.js
var require_date = __commonJS((exports) => {
  var Date3 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Date",
      type: "Date"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Date = undefined;
  var index_1 = require_symbols2();
  exports.Date = Date3;
});

// node_modules/@sinclair/typebox/build/require/type/date/index.js
var require_date2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_date(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/null/null.js
var require_null = __commonJS((exports) => {
  var Null2 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Null",
      type: "null"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Null = undefined;
  var index_1 = require_symbols2();
  exports.Null = Null2;
});

// node_modules/@sinclair/typebox/build/require/type/null/index.js
var require_null2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_null(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/symbol/symbol.js
var require_symbol = __commonJS((exports) => {
  var Symbol3 = function(options) {
    return { ...options, [index_1.Kind]: "Symbol", type: "symbol" };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Symbol = undefined;
  var index_1 = require_symbols2();
  exports.Symbol = Symbol3;
});

// node_modules/@sinclair/typebox/build/require/type/symbol/index.js
var require_symbol2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbol(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/undefined/undefined.js
var require_undefined = __commonJS((exports) => {
  var Undefined2 = function(options = {}) {
    return { ...options, [index_1.Kind]: "Undefined", type: "undefined" };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Undefined = undefined;
  var index_1 = require_symbols2();
  exports.Undefined = Undefined2;
});

// node_modules/@sinclair/typebox/build/require/type/undefined/index.js
var require_undefined2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_undefined(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/uint8array/uint8array.js
var require_uint8array = __commonJS((exports) => {
  var Uint8Array3 = function(options = {}) {
    return { ...options, [index_1.Kind]: "Uint8Array", type: "Uint8Array" };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uint8Array = undefined;
  var index_1 = require_symbols2();
  exports.Uint8Array = Uint8Array3;
});

// node_modules/@sinclair/typebox/build/require/type/uint8array/index.js
var require_uint8array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_uint8array(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/const/const.js
var require_const = __commonJS((exports) => {
  var FromArray16 = function(T) {
    return T.map((L) => FromValue2(L, false));
  };
  var FromProperties20 = function(value15) {
    return globalThis.Object.getOwnPropertyNames(value15).reduce((acc, key) => {
      return { ...acc, [key]: (0, index_10.Readonly)(FromValue2(value15[key], false)) };
    }, {});
  };
  var ConditionalReadonly2 = function(T, root) {
    return root === true ? T : (0, index_10.Readonly)(T);
  };
  var FromValue2 = function(value15, root) {
    return (0, value_1.IsAsyncIterator)(value15) ? ConditionalReadonly2((0, index_1.Any)(), root) : (0, value_1.IsIterator)(value15) ? ConditionalReadonly2((0, index_1.Any)(), root) : (0, value_1.IsArray)(value15) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray16(value15))) : (0, value_1.IsUint8Array)(value15) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value15) ? (0, index_3.Date)() : (0, value_1.IsObject)(value15) ? ConditionalReadonly2((0, index_7.Object)(FromProperties20(value15)), root) : (0, value_1.IsFunction)(value15) ? ConditionalReadonly2((0, index_4.Function)([], (0, index_13.Unknown)()), root) : (0, value_1.IsUndefined)(value15) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value15) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value15) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value15) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value15) ? (0, index_5.Literal)(value15) : (0, value_1.IsBoolean)(value15) ? (0, index_5.Literal)(value15) : (0, value_1.IsString)(value15) ? (0, index_5.Literal)(value15) : (0, index_7.Object)({});
  };
  var Const2 = function(T, options = {}) {
    return (0, index_14.CloneType)(FromValue2(T, true), options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Const = undefined;
  var index_1 = require_any2();
  var index_2 = require_bigint2();
  var index_3 = require_date2();
  var index_4 = require_function2();
  var index_5 = require_literal2();
  var index_6 = require_null2();
  var index_7 = require_object2();
  var index_8 = require_symbol2();
  var index_9 = require_tuple2();
  var index_10 = require_readonly2();
  var index_11 = require_undefined2();
  var index_12 = require_uint8array2();
  var index_13 = require_unknown2();
  var index_14 = require_clone3();
  var value_1 = require_value();
  exports.Const = Const2;
});

// node_modules/@sinclair/typebox/build/require/type/const/index.js
var require_const2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_const(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/constructor-parameters/constructor-parameters.js
var require_constructor_parameters = __commonJS((exports) => {
  var ConstructorParameters2 = function(schema3, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema3.parameters), { ...options });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConstructorParameters = undefined;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  exports.ConstructorParameters = ConstructorParameters2;
});

// node_modules/@sinclair/typebox/build/require/type/constructor-parameters/index.js
var require_constructor_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/deref/deref.js
var require_deref3 = __commonJS((exports) => {
  var FromRest9 = function(schema3, references) {
    return schema3.map((schema4) => Deref3(schema4, references));
  };
  var FromProperties20 = function(properties, references) {
    return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
      return { ...acc, [key]: Deref3(properties[key], references) };
    }, {});
  };
  var FromConstructor8 = function(schema3, references) {
    schema3.parameters = FromRest9(schema3.parameters, references);
    schema3.returns = Deref3(schema3.returns, references);
    return schema3;
  };
  var FromFunction7 = function(schema3, references) {
    schema3.parameters = FromRest9(schema3.parameters, references);
    schema3.returns = Deref3(schema3.returns, references);
    return schema3;
  };
  var FromIntersect18 = function(schema3, references) {
    schema3.allOf = FromRest9(schema3.allOf, references);
    return schema3;
  };
  var FromUnion20 = function(schema3, references) {
    schema3.anyOf = FromRest9(schema3.anyOf, references);
    return schema3;
  };
  var FromTuple15 = function(schema3, references) {
    if ((0, value_1.IsUndefined)(schema3.items))
      return schema3;
    schema3.items = FromRest9(schema3.items, references);
    return schema3;
  };
  var FromArray16 = function(schema3, references) {
    schema3.items = Deref3(schema3.items, references);
    return schema3;
  };
  var FromObject13 = function(schema3, references) {
    schema3.properties = FromProperties20(schema3.properties, references);
    return schema3;
  };
  var FromPromise8 = function(schema3, references) {
    schema3.item = Deref3(schema3.item, references);
    return schema3;
  };
  var FromAsyncIterator7 = function(schema3, references) {
    schema3.items = Deref3(schema3.items, references);
    return schema3;
  };
  var FromIterator7 = function(schema3, references) {
    schema3.items = Deref3(schema3.items, references);
    return schema3;
  };
  var FromRef12 = function(schema3, references) {
    const target = references.find((remote) => remote.$id === schema3.$ref);
    if (target === undefined)
      throw Error(`Unable to dereference schema with \$id ${schema3.$ref}`);
    const discard12 = (0, index_1.Discard)(target, ["$id"]);
    return Deref3(discard12, references);
  };
  var DerefResolve2 = function(schema3, references) {
    return (0, type_2.IsConstructor)(schema3) ? FromConstructor8(schema3, references) : (0, type_2.IsFunction)(schema3) ? FromFunction7(schema3, references) : (0, type_2.IsIntersect)(schema3) ? FromIntersect18(schema3, references) : (0, type_2.IsUnion)(schema3) ? FromUnion20(schema3, references) : (0, type_2.IsTuple)(schema3) ? FromTuple15(schema3, references) : (0, type_2.IsArray)(schema3) ? FromArray16(schema3, references) : (0, type_2.IsObject)(schema3) ? FromObject13(schema3, references) : (0, type_2.IsPromise)(schema3) ? FromPromise8(schema3, references) : (0, type_2.IsAsyncIterator)(schema3) ? FromAsyncIterator7(schema3, references) : (0, type_2.IsIterator)(schema3) ? FromIterator7(schema3, references) : (0, type_2.IsRef)(schema3) ? FromRef12(schema3, references) : schema3;
  };
  var Deref3 = function(schema3, references) {
    return DerefResolve2((0, type_1.CloneType)(schema3), (0, type_1.CloneRest)(references));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deref = undefined;
  var type_1 = require_type2();
  var index_1 = require_discard2();
  var value_1 = require_value();
  var type_2 = require_type3();
  exports.Deref = Deref3;
});

// node_modules/@sinclair/typebox/build/require/type/deref/index.js
var require_deref4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deref3(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/enum/enum.js
var require_enum = __commonJS((exports) => {
  var Enum2 = function(item, options = {}) {
    if ((0, value_1.IsUndefined)(item))
      throw new Error("Enum undefined or empty");
    const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value15) => (0, index_1.Literal)(value15));
    return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Enum = undefined;
  var index_1 = require_literal2();
  var index_2 = require_symbols2();
  var index_3 = require_union2();
  var value_1 = require_value();
  exports.Enum = Enum2;
});

// node_modules/@sinclair/typebox/build/require/type/enum/index.js
var require_enum2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_enum(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/exclude/exclude-from-template-literal.js
var require_exclude_from_template_literal = __commonJS((exports) => {
  var ExcludeFromTemplateLiteral2 = function(L, R) {
    return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromTemplateLiteral = undefined;
  var exclude_1 = require_exclude();
  var index_1 = require_template_literal2();
  exports.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral2;
});

// node_modules/@sinclair/typebox/build/require/type/exclude/exclude.js
var require_exclude = __commonJS((exports) => {
  var ExcludeRest2 = function(L, R) {
    const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
  };
  var Exclude2 = function(L, R, options = {}) {
    if ((0, type_2.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
    if ((0, type_2.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, type_2.IsUnion)(L) ? ExcludeRest2(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Exclude = undefined;
  var index_1 = require_union2();
  var index_2 = require_never2();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var exclude_from_mapped_result_1 = require_exclude_from_mapped_result();
  var exclude_from_template_literal_1 = require_exclude_from_template_literal();
  var type_2 = require_type3();
  exports.Exclude = Exclude2;
});

// node_modules/@sinclair/typebox/build/require/type/exclude/exclude-from-mapped-result.js
var require_exclude_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(P, U) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, exclude_1.Exclude)(P[K2], U) };
    }, {});
  };
  var FromMappedResult13 = function(R, T) {
    return FromProperties20(R.properties, T);
  };
  var ExcludeFromMappedResult2 = function(R, T) {
    const P = FromMappedResult13(R, T);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var exclude_1 = require_exclude();
  exports.ExcludeFromMappedResult = ExcludeFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/exclude/index.js
var require_exclude2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_exclude_from_mapped_result(), exports);
  __exportStar(require_exclude_from_template_literal(), exports);
  __exportStar(require_exclude(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/extract/extract-from-template-literal.js
var require_extract_from_template_literal = __commonJS((exports) => {
  var ExtractFromTemplateLiteral2 = function(L, R) {
    return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromTemplateLiteral = undefined;
  var extract_1 = require_extract();
  var index_1 = require_template_literal2();
  exports.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral2;
});

// node_modules/@sinclair/typebox/build/require/type/extract/extract.js
var require_extract = __commonJS((exports) => {
  var ExtractRest2 = function(L, R) {
    const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
  };
  var Extract2 = function(L, R, options = {}) {
    if ((0, type_2.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
    if ((0, type_2.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, type_2.IsUnion)(L) ? ExtractRest2(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extract = undefined;
  var index_1 = require_union2();
  var index_2 = require_never2();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var extract_from_mapped_result_1 = require_extract_from_mapped_result();
  var extract_from_template_literal_1 = require_extract_from_template_literal();
  var type_2 = require_type3();
  exports.Extract = Extract2;
});

// node_modules/@sinclair/typebox/build/require/type/extract/extract-from-mapped-result.js
var require_extract_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(P, T) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, extract_1.Extract)(P[K2], T) };
    }, {});
  };
  var FromMappedResult13 = function(R, T) {
    return FromProperties20(R.properties, T);
  };
  var ExtractFromMappedResult2 = function(R, T) {
    const P = FromMappedResult13(R, T);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var extract_1 = require_extract();
  exports.ExtractFromMappedResult = ExtractFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/extract/index.js
var require_extract2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extract_from_mapped_result(), exports);
  __exportStar(require_extract_from_template_literal(), exports);
  __exportStar(require_extract(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/instance-type/instance-type.js
var require_instance_type = __commonJS((exports) => {
  var InstanceType2 = function(schema3, options = {}) {
    return (0, type_1.CloneType)(schema3.returns, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstanceType = undefined;
  var type_1 = require_type2();
  exports.InstanceType = InstanceType2;
});

// node_modules/@sinclair/typebox/build/require/type/instance-type/index.js
var require_instance_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instance_type(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/integer/integer.js
var require_integer = __commonJS((exports) => {
  var Integer2 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Integer",
      type: "integer"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Integer = undefined;
  var index_1 = require_symbols2();
  exports.Integer = Integer2;
});

// node_modules/@sinclair/typebox/build/require/type/integer/index.js
var require_integer2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_integer(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/intrinsic/intrinsic-from-mapped-key.js
var require_intrinsic_from_mapped_key = __commonJS((exports) => {
  var MappedIntrinsicPropertyKey2 = function(K, M, options) {
    return {
      [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, options)
    };
  };
  var MappedIntrinsicPropertyKeys2 = function(K, M, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIntrinsicPropertyKey2(L, M, options) };
    }, {});
  };
  var MappedIntrinsicProperties2 = function(T, M, options) {
    return MappedIntrinsicPropertyKeys2(T["keys"], M, options);
  };
  var IntrinsicFromMappedKey2 = function(T, M, options) {
    const P = MappedIntrinsicProperties2(T, M, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntrinsicFromMappedKey = undefined;
  var index_1 = require_mapped2();
  var intrinsic_1 = require_intrinsic();
  var index_2 = require_literal2();
  exports.IntrinsicFromMappedKey = IntrinsicFromMappedKey2;
});

// node_modules/@sinclair/typebox/build/require/type/intrinsic/intrinsic.js
var require_intrinsic = __commonJS((exports) => {
  var ApplyUncapitalize2 = function(value15) {
    const [first, rest4] = [value15.slice(0, 1), value15.slice(1)];
    return [first.toLowerCase(), rest4].join("");
  };
  var ApplyCapitalize2 = function(value15) {
    const [first, rest4] = [value15.slice(0, 1), value15.slice(1)];
    return [first.toUpperCase(), rest4].join("");
  };
  var ApplyUppercase2 = function(value15) {
    return value15.toUpperCase();
  };
  var ApplyLowercase2 = function(value15) {
    return value15.toLowerCase();
  };
  var FromTemplateLiteral7 = function(schema3, mode, options) {
    const expression = (0, index_1.TemplateLiteralParseExact)(schema3.pattern);
    const finite3 = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
    if (!finite3)
      return { ...schema3, pattern: FromLiteralValue2(schema3.pattern, mode) };
    const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
    const literals = strings.map((value15) => (0, index_2.Literal)(value15));
    const mapped20 = FromRest9(literals, mode);
    const union22 = (0, index_3.Union)(mapped20);
    return (0, index_1.TemplateLiteral)([union22], options);
  };
  var FromLiteralValue2 = function(value15, mode) {
    return typeof value15 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value15) : mode === "Capitalize" ? ApplyCapitalize2(value15) : mode === "Uppercase" ? ApplyUppercase2(value15) : mode === "Lowercase" ? ApplyLowercase2(value15) : value15 : value15.toString();
  };
  var FromRest9 = function(T, M) {
    return T.map((L) => Intrinsic2(L, M));
  };
  var Intrinsic2 = function(schema3, mode, options = {}) {
    return (0, type_1.IsMappedKey)(schema3) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema3, mode, options) : (0, type_1.IsTemplateLiteral)(schema3) ? FromTemplateLiteral7(schema3, mode, schema3) : (0, type_1.IsUnion)(schema3) ? (0, index_3.Union)(FromRest9(schema3.anyOf, mode), options) : (0, type_1.IsLiteral)(schema3) ? (0, index_2.Literal)(FromLiteralValue2(schema3.const, mode), options) : schema3;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intrinsic = undefined;
  var index_1 = require_template_literal2();
  var intrinsic_from_mapped_key_1 = require_intrinsic_from_mapped_key();
  var index_2 = require_literal2();
  var index_3 = require_union2();
  var type_1 = require_type3();
  exports.Intrinsic = Intrinsic2;
});

// node_modules/@sinclair/typebox/build/require/type/intrinsic/capitalize.js
var require_capitalize = __commonJS((exports) => {
  var Capitalize2 = function(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Capitalize", options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Capitalize = undefined;
  var intrinsic_1 = require_intrinsic();
  exports.Capitalize = Capitalize2;
});

// node_modules/@sinclair/typebox/build/require/type/intrinsic/lowercase.js
var require_lowercase = __commonJS((exports) => {
  var Lowercase2 = function(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Lowercase", options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Lowercase = undefined;
  var intrinsic_1 = require_intrinsic();
  exports.Lowercase = Lowercase2;
});

// node_modules/@sinclair/typebox/build/require/type/intrinsic/uncapitalize.js
var require_uncapitalize = __commonJS((exports) => {
  var Uncapitalize2 = function(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uncapitalize", options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uncapitalize = undefined;
  var intrinsic_1 = require_intrinsic();
  exports.Uncapitalize = Uncapitalize2;
});

// node_modules/@sinclair/typebox/build/require/type/intrinsic/uppercase.js
var require_uppercase = __commonJS((exports) => {
  var Uppercase2 = function(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uppercase", options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uppercase = undefined;
  var intrinsic_1 = require_intrinsic();
  exports.Uppercase = Uppercase2;
});

// node_modules/@sinclair/typebox/build/require/type/intrinsic/index.js
var require_intrinsic2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_capitalize(), exports);
  __exportStar(require_intrinsic_from_mapped_key(), exports);
  __exportStar(require_intrinsic(), exports);
  __exportStar(require_lowercase(), exports);
  __exportStar(require_uncapitalize(), exports);
  __exportStar(require_uppercase(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/not/not.js
var require_not = __commonJS((exports) => {
  var Not3 = function(schema3, options) {
    return {
      ...options,
      [index_1.Kind]: "Not",
      not: (0, type_1.CloneType)(schema3)
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Not = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  exports.Not = Not3;
});

// node_modules/@sinclair/typebox/build/require/type/not/index.js
var require_not2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_not(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/omit/omit-from-mapped-result.js
var require_omit_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(P, K, options) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, omit_1.Omit)(P[K2], K, options) };
    }, {});
  };
  var FromMappedResult13 = function(R, K, options) {
    return FromProperties20(R.properties, K, options);
  };
  var OmitFromMappedResult2 = function(R, K, options) {
    const P = FromMappedResult13(R, K, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  exports.OmitFromMappedResult = OmitFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/omit/omit.js
var require_omit = __commonJS((exports) => {
  var FromIntersect18 = function(T, K) {
    return T.map((T2) => OmitResolve2(T2, K));
  };
  var FromUnion20 = function(T, K) {
    return T.map((T2) => OmitResolve2(T2, K));
  };
  var FromProperty3 = function(T, K) {
    const { [K]: _, ...R } = T;
    return R;
  };
  var FromProperties20 = function(T, K) {
    return K.reduce((T2, K2) => {
      return FromProperty3(T2, K2);
    }, T);
  };
  var OmitResolve2 = function(T, K) {
    return (0, type_2.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect18(T.allOf, K)) : (0, type_2.IsUnion)(T) ? (0, index_2.Union)(FromUnion20(T.anyOf, K)) : (0, type_2.IsObject)(T) ? (0, index_3.Object)(FromProperties20(T.properties, K)) : (0, index_3.Object)({});
  };
  var Omit2 = function(T, K, options = {}) {
    if ((0, type_2.IsMappedKey)(K))
      return (0, omit_from_mapped_key_1.OmitFromMappedKey)(T, K, options);
    if ((0, type_2.IsMappedResult)(T))
      return (0, omit_from_mapped_result_1.OmitFromMappedResult)(T, K, options);
    const I = (0, type_2.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(OmitResolve2(T, I), options);
    return { ...D, ...R };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Omit = undefined;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var omit_from_mapped_key_1 = require_omit_from_mapped_key();
  var omit_from_mapped_result_1 = require_omit_from_mapped_result();
  var type_2 = require_type3();
  exports.Omit = Omit2;
});

// node_modules/@sinclair/typebox/build/require/type/omit/omit-from-mapped-key.js
var require_omit_from_mapped_key = __commonJS((exports) => {
  var FromPropertyKey4 = function(T, K, options) {
    return {
      [K]: (0, omit_1.Omit)(T, [K], options)
    };
  };
  var FromPropertyKeys4 = function(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey4(T, LK, options) };
    }, {});
  };
  var FromMappedKey5 = function(T, K, options) {
    return FromPropertyKeys4(T, K.keys, options);
  };
  var OmitFromMappedKey2 = function(T, K, options) {
    const P = FromMappedKey5(T, K, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedKey = undefined;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  exports.OmitFromMappedKey = OmitFromMappedKey2;
});

// node_modules/@sinclair/typebox/build/require/type/omit/index.js
var require_omit2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_omit_from_mapped_key(), exports);
  __exportStar(require_omit_from_mapped_result(), exports);
  __exportStar(require_omit(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/parameters/parameters.js
var require_parameters = __commonJS((exports) => {
  var Parameters2 = function(schema3, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema3.parameters), { ...options });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parameters = undefined;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  exports.Parameters = Parameters2;
});

// node_modules/@sinclair/typebox/build/require/type/parameters/index.js
var require_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/partial/partial.js
var require_partial = __commonJS((exports) => {
  var FromRest9 = function(T) {
    return T.map((L) => PartialResolve2(L));
  };
  var FromProperties20 = function(T) {
    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
      return { ...Acc, [K]: (0, index_1.Optional)(T[K]) };
    }, {});
  };
  var PartialResolve2 = function(T) {
    return (0, type_2.IsIntersect)(T) ? (0, index_3.Intersect)(FromRest9(T.allOf)) : (0, type_2.IsUnion)(T) ? (0, index_4.Union)(FromRest9(T.anyOf)) : (0, type_2.IsObject)(T) ? (0, index_2.Object)(FromProperties20(T.properties)) : (0, index_2.Object)({});
  };
  var Partial2 = function(T, options = {}) {
    if ((0, type_2.IsMappedResult)(T))
      return (0, partial_from_mapped_result_1.PartialFromMappedResult)(T, options);
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PartialResolve2(T), options);
    return { ...D, ...R };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Partial = undefined;
  var index_1 = require_optional2();
  var index_2 = require_object2();
  var index_3 = require_intersect2();
  var index_4 = require_union2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var partial_from_mapped_result_1 = require_partial_from_mapped_result();
  var type_2 = require_type3();
  exports.Partial = Partial2;
});

// node_modules/@sinclair/typebox/build/require/type/partial/partial-from-mapped-result.js
var require_partial_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(K, options) {
    return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, partial_1.Partial)(K[K2], options) };
    }, {});
  };
  var FromMappedResult13 = function(R, options) {
    return FromProperties20(R.properties, options);
  };
  var PartialFromMappedResult2 = function(R, options) {
    const P = FromMappedResult13(R, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PartialFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var partial_1 = require_partial();
  exports.PartialFromMappedResult = PartialFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/partial/index.js
var require_partial2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_partial_from_mapped_result(), exports);
  __exportStar(require_partial(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/pick/pick-from-mapped-result.js
var require_pick_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(P, K, options) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, pick_1.Pick)(P[K2], K, options) };
    }, {});
  };
  var FromMappedResult13 = function(R, K, options) {
    return FromProperties20(R.properties, K, options);
  };
  var PickFromMappedResult2 = function(R, K, options) {
    const P = FromMappedResult13(R, K, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  exports.PickFromMappedResult = PickFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/pick/pick.js
var require_pick = __commonJS((exports) => {
  var FromIntersect18 = function(T, K) {
    return T.map((T2) => PickResolve2(T2, K));
  };
  var FromUnion20 = function(T, K) {
    return T.map((T2) => PickResolve2(T2, K));
  };
  var FromProperties20 = function(T, K) {
    return K.reduce((Acc, K2) => {
      return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
    }, {});
  };
  var PickResolve2 = function(T, K) {
    return (0, type_2.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect18(T.allOf, K)) : (0, type_2.IsUnion)(T) ? (0, index_2.Union)(FromUnion20(T.anyOf, K)) : (0, type_2.IsObject)(T) ? (0, index_3.Object)(FromProperties20(T.properties, K)) : (0, index_3.Object)({});
  };
  var Pick2 = function(T, K, options = {}) {
    if ((0, type_2.IsMappedKey)(K))
      return (0, pick_from_mapped_key_1.PickFromMappedKey)(T, K, options);
    if ((0, type_2.IsMappedResult)(T))
      return (0, pick_from_mapped_result_1.PickFromMappedResult)(T, K, options);
    const I = (0, type_2.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PickResolve2(T, I), options);
    return { ...D, ...R };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pick = undefined;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var pick_from_mapped_key_1 = require_pick_from_mapped_key();
  var pick_from_mapped_result_1 = require_pick_from_mapped_result();
  var type_2 = require_type3();
  exports.Pick = Pick2;
});

// node_modules/@sinclair/typebox/build/require/type/pick/pick-from-mapped-key.js
var require_pick_from_mapped_key = __commonJS((exports) => {
  var FromPropertyKey4 = function(T, K, options) {
    return {
      [K]: (0, pick_1.Pick)(T, [K], options)
    };
  };
  var FromPropertyKeys4 = function(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey4(T, LK, options) };
    }, {});
  };
  var FromMappedKey5 = function(T, K, options) {
    return FromPropertyKeys4(T, K.keys, options);
  };
  var PickFromMappedKey2 = function(T, K, options) {
    const P = FromMappedKey5(T, K, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedKey = undefined;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  exports.PickFromMappedKey = PickFromMappedKey2;
});

// node_modules/@sinclair/typebox/build/require/type/pick/index.js
var require_pick2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_pick_from_mapped_key(), exports);
  __exportStar(require_pick_from_mapped_result(), exports);
  __exportStar(require_pick(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/readonly-optional/readonly-optional.js
var require_readonly_optional = __commonJS((exports) => {
  var ReadonlyOptional2 = function(schema3) {
    return (0, index_1.Readonly)((0, index_2.Optional)(schema3));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyOptional = undefined;
  var index_1 = require_readonly2();
  var index_2 = require_optional2();
  exports.ReadonlyOptional = ReadonlyOptional2;
});

// node_modules/@sinclair/typebox/build/require/type/readonly-optional/index.js
var require_readonly_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_optional(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/record/record.js
var require_record = __commonJS((exports) => {
  var RecordCreateFromPattern2 = function(pattern3, T, options) {
    return {
      ...options,
      [index_7.Kind]: "Record",
      type: "object",
      patternProperties: { [pattern3]: (0, type_1.CloneType)(T) }
    };
  };
  var RecordCreateFromKeys2 = function(K, T, options) {
    const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: (0, type_1.CloneType)(T) }), {});
    return (0, index_1.Object)(P, { ...options, [index_7.Hint]: "Record" });
  };
  var FromTemplateLiteralKey2 = function(K, T, options) {
    return (0, index_4.IsTemplateLiteralFinite)(K) ? RecordCreateFromKeys2((0, index_6.IndexPropertyKeys)(K), T, options) : RecordCreateFromPattern2(K.pattern, T, options);
  };
  var FromUnionKey2 = function(K, T, options) {
    return RecordCreateFromKeys2((0, index_6.IndexPropertyKeys)((0, index_3.Union)(K)), T, options);
  };
  var FromLiteralKey2 = function(K, T, options) {
    return RecordCreateFromKeys2([K.toString()], T, options);
  };
  var FromRegExpKey2 = function(K, T, options) {
    return RecordCreateFromPattern2(K.source, T, options);
  };
  var FromStringKey2 = function(K, T, options) {
    const pattern3 = (0, value_1.IsUndefined)(K.pattern) ? index_5.PatternStringExact : K.pattern;
    return RecordCreateFromPattern2(pattern3, T, options);
  };
  var FromIntegerKey2 = function(_, T, options) {
    return RecordCreateFromPattern2(index_5.PatternNumberExact, T, options);
  };
  var FromNumberKey2 = function(_, T, options) {
    return RecordCreateFromPattern2(index_5.PatternNumberExact, T, options);
  };
  var Record2 = function(K, T, options = {}) {
    return (0, type_2.IsUnion)(K) ? FromUnionKey2(K.anyOf, T, options) : (0, type_2.IsTemplateLiteral)(K) ? FromTemplateLiteralKey2(K, T, options) : (0, type_2.IsLiteral)(K) ? FromLiteralKey2(K.const, T, options) : (0, type_2.IsInteger)(K) ? FromIntegerKey2(K, T, options) : (0, type_2.IsNumber)(K) ? FromNumberKey2(K, T, options) : (0, type_2.IsRegExp)(K) ? FromRegExpKey2(K, T, options) : (0, type_2.IsString)(K) ? FromStringKey2(K, T, options) : (0, index_2.Never)(options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Record = undefined;
  var index_1 = require_object2();
  var index_2 = require_never2();
  var index_3 = require_union2();
  var index_4 = require_template_literal2();
  var index_5 = require_patterns2();
  var index_6 = require_indexed2();
  var index_7 = require_symbols2();
  var type_1 = require_type2();
  var value_1 = require_value();
  var type_2 = require_type3();
  exports.Record = Record2;
});

// node_modules/@sinclair/typebox/build/require/type/record/index.js
var require_record2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_record(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/recursive/recursive.js
var require_recursive = __commonJS((exports) => {
  var Recursive2 = function(callback, options = {}) {
    if ((0, value_1.IsUndefined)(options.$id))
      options.$id = `T${Ordinal2++}`;
    const thisType = callback({ [index_1.Kind]: "This", $ref: `${options.$id}` });
    thisType.$id = options.$id;
    return (0, type_1.CloneType)({ ...options, [index_1.Hint]: "Recursive", ...thisType });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Recursive = undefined;
  var type_1 = require_type2();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  var Ordinal2 = 0;
  exports.Recursive = Recursive2;
});

// node_modules/@sinclair/typebox/build/require/type/recursive/index.js
var require_recursive2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_recursive(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/ref/ref.js
var require_ref = __commonJS((exports) => {
  var Ref2 = function(unresolved, options = {}) {
    if ((0, value_1.IsString)(unresolved))
      return { ...options, [index_1.Kind]: "Ref", $ref: unresolved };
    if ((0, value_1.IsUndefined)(unresolved.$id))
      throw new Error("Reference target type must specify an $id");
    return {
      ...options,
      [index_1.Kind]: "Ref",
      $ref: unresolved.$id
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ref = undefined;
  var index_1 = require_symbols2();
  var value_1 = require_value();
  exports.Ref = Ref2;
});

// node_modules/@sinclair/typebox/build/require/type/ref/index.js
var require_ref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ref(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/regexp/regexp.js
var require_regexp = __commonJS((exports) => {
  var RegExp3 = function(unresolved, options = {}) {
    const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return { ...options, [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RegExp = undefined;
  var value_1 = require_value();
  var index_1 = require_symbols2();
  exports.RegExp = RegExp3;
});

// node_modules/@sinclair/typebox/build/require/type/regexp/index.js
var require_regexp2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_regexp(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/required/required.js
var require_required = __commonJS((exports) => {
  var FromRest9 = function(T) {
    return T.map((L) => RequiredResolve2(L));
  };
  var FromProperties20 = function(T) {
    return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
      return { ...Acc, [K]: (0, index_5.Discard)(T[K], [index_4.OptionalKind]) };
    }, {});
  };
  var RequiredResolve2 = function(T) {
    return (0, type_2.IsIntersect)(T) ? (0, index_1.Intersect)(FromRest9(T.allOf)) : (0, type_2.IsUnion)(T) ? (0, index_2.Union)(FromRest9(T.anyOf)) : (0, type_2.IsObject)(T) ? (0, index_3.Object)(FromProperties20(T.properties)) : (0, index_3.Object)({});
  };
  var Required2 = function(T, options = {}) {
    if ((0, type_2.IsMappedResult)(T)) {
      return (0, required_from_mapped_result_1.RequiredFromMappedResult)(T, options);
    } else {
      const D = (0, index_5.Discard)(T, [index_4.TransformKind, "$id", "required"]);
      const R = (0, type_1.CloneType)(RequiredResolve2(T), options);
      return { ...D, ...R };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Required = undefined;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_symbols2();
  var type_1 = require_type2();
  var index_5 = require_discard2();
  var required_from_mapped_result_1 = require_required_from_mapped_result();
  var type_2 = require_type3();
  exports.Required = Required2;
});

// node_modules/@sinclair/typebox/build/require/type/required/required-from-mapped-result.js
var require_required_from_mapped_result = __commonJS((exports) => {
  var FromProperties20 = function(P, options) {
    return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
      return { ...Acc, [K2]: (0, required_1.Required)(P[K2], options) };
    }, {});
  };
  var FromMappedResult13 = function(R, options) {
    return FromProperties20(R.properties, options);
  };
  var RequiredFromMappedResult2 = function(R, options) {
    const P = FromMappedResult13(R, options);
    return (0, index_1.MappedResult)(P);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequiredFromMappedResult = undefined;
  var index_1 = require_mapped2();
  var required_1 = require_required();
  exports.RequiredFromMappedResult = RequiredFromMappedResult2;
});

// node_modules/@sinclair/typebox/build/require/type/required/index.js
var require_required2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_required_from_mapped_result(), exports);
  __exportStar(require_required(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/rest/rest.js
var require_rest = __commonJS((exports) => {
  var RestResolve2 = function(T) {
    return (0, type_2.IsIntersect)(T) ? [...T.allOf] : (0, type_2.IsUnion)(T) ? [...T.anyOf] : (0, type_2.IsTuple)(T) ? [...T.items ?? []] : [];
  };
  var Rest2 = function(T) {
    return (0, type_1.CloneRest)(RestResolve2(T));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Rest = undefined;
  var type_1 = require_type2();
  var type_2 = require_type3();
  exports.Rest = Rest2;
});

// node_modules/@sinclair/typebox/build/require/type/rest/index.js
var require_rest2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_rest(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/return-type/return-type.js
var require_return_type = __commonJS((exports) => {
  var ReturnType2 = function(schema3, options = {}) {
    return (0, type_1.CloneType)(schema3.returns, options);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReturnType = undefined;
  var type_1 = require_type2();
  exports.ReturnType = ReturnType2;
});

// node_modules/@sinclair/typebox/build/require/type/return-type/index.js
var require_return_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_return_type(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/schema/anyschema.js
var require_anyschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/require/type/schema/schema.js
var require_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/require/type/schema/index.js
var require_schema2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_anyschema(), exports);
  __exportStar(require_schema(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/static/static.js
var require_static = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/require/type/static/index.js
var require_static2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_static(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/strict/strict.js
var require_strict = __commonJS((exports) => {
  var Strict2 = function(schema3) {
    return JSON.parse(JSON.stringify(schema3));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Strict = undefined;
  exports.Strict = Strict2;
});

// node_modules/@sinclair/typebox/build/require/type/strict/index.js
var require_strict2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_strict(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/transform/transform.js
var require_transform2 = __commonJS((exports) => {
  var Transform2 = function(schema3) {
    return new TransformDecodeBuilder2(schema3);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Transform = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = undefined;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var type_2 = require_type3();

  class TransformDecodeBuilder2 {
    constructor(schema3) {
      this.schema = schema3;
    }
    Decode(decode2) {
      return new TransformEncodeBuilder2(this.schema, decode2);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder2;

  class TransformEncodeBuilder2 {
    constructor(schema3, decode2) {
      this.schema = schema3;
      this.decode = decode2;
    }
    EncodeTransform(encode2, schema3) {
      const Encode2 = (value15) => schema3[index_1.TransformKind].Encode(encode2(value15));
      const Decode2 = (value15) => this.decode(schema3[index_1.TransformKind].Decode(value15));
      const Codec = { Encode: Encode2, Decode: Decode2 };
      return { ...schema3, [index_1.TransformKind]: Codec };
    }
    EncodeSchema(encode2, schema3) {
      const Codec = { Decode: this.decode, Encode: encode2 };
      return { ...schema3, [index_1.TransformKind]: Codec };
    }
    Encode(encode2) {
      const schema3 = (0, type_1.CloneType)(this.schema);
      return (0, type_2.IsTransform)(schema3) ? this.EncodeTransform(encode2, schema3) : this.EncodeSchema(encode2, schema3);
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder2;
  exports.Transform = Transform2;
});

// node_modules/@sinclair/typebox/build/require/type/transform/index.js
var require_transform3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_transform2(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/void/void.js
var require_void = __commonJS((exports) => {
  var Void2 = function(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Void",
      type: "void"
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Void = undefined;
  var index_1 = require_symbols2();
  exports.Void = Void2;
});

// node_modules/@sinclair/typebox/build/require/type/void/index.js
var require_void2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_void(), exports);
});

// node_modules/@sinclair/typebox/build/require/type/type/json.js
var require_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonTypeBuilder = undefined;
  var index_1 = require_any2();
  var index_2 = require_array2();
  var index_3 = require_boolean2();
  var index_4 = require_composite2();
  var index_5 = require_const2();
  var index_6 = require_deref4();
  var index_7 = require_enum2();
  var index_8 = require_exclude2();
  var index_9 = require_extends2();
  var index_10 = require_extract2();
  var index_11 = require_indexed2();
  var index_12 = require_integer2();
  var index_13 = require_intersect2();
  var index_14 = require_intrinsic2();
  var index_15 = require_keyof2();
  var index_16 = require_literal2();
  var index_17 = require_mapped2();
  var index_18 = require_never2();
  var index_19 = require_not2();
  var index_20 = require_null2();
  var index_21 = require_number2();
  var index_22 = require_object2();
  var index_23 = require_omit2();
  var index_24 = require_optional2();
  var index_25 = require_partial2();
  var index_26 = require_pick2();
  var index_27 = require_readonly2();
  var index_28 = require_readonly_optional2();
  var index_29 = require_record2();
  var index_30 = require_recursive2();
  var index_31 = require_ref2();
  var index_32 = require_required2();
  var index_33 = require_rest2();
  var index_34 = require_strict2();
  var index_35 = require_string2();
  var index_36 = require_template_literal2();
  var index_37 = require_transform3();
  var index_38 = require_tuple2();
  var index_39 = require_union2();
  var index_40 = require_unknown2();
  var index_41 = require_unsafe2();

  class JsonTypeBuilder2 {
    Strict(schema3) {
      return (0, index_34.Strict)(schema3);
    }
    ReadonlyOptional(schema3) {
      return (0, index_28.ReadonlyOptional)(schema3);
    }
    Readonly(schema3, enable) {
      return (0, index_27.Readonly)(schema3, enable ?? true);
    }
    Optional(schema3, enable) {
      return (0, index_24.Optional)(schema3, enable ?? true);
    }
    Any(options = {}) {
      return (0, index_1.Any)(options);
    }
    Array(schema3, options = {}) {
      return (0, index_2.Array)(schema3, options);
    }
    Boolean(options = {}) {
      return (0, index_3.Boolean)(options);
    }
    Capitalize(schema3, options = {}) {
      return (0, index_14.Capitalize)(schema3, options);
    }
    Composite(schemas, options) {
      return (0, index_4.Composite)(schemas, options);
    }
    Const(value15, options = {}) {
      return (0, index_5.Const)(value15, options);
    }
    Deref(schema3, references) {
      return (0, index_6.Deref)(schema3, references);
    }
    Enum(item, options = {}) {
      return (0, index_7.Enum)(item, options);
    }
    Exclude(unionType, excludedMembers, options = {}) {
      return (0, index_8.Exclude)(unionType, excludedMembers, options);
    }
    Extends(L, R, T, F, options = {}) {
      return (0, index_9.Extends)(L, R, T, F, options);
    }
    Extract(type74, union22, options = {}) {
      return (0, index_10.Extract)(type74, union22, options);
    }
    Index(schema3, unresolved, options = {}) {
      return (0, index_11.Index)(schema3, unresolved, options);
    }
    Integer(options = {}) {
      return (0, index_12.Integer)(options);
    }
    Intersect(T, options = {}) {
      return (0, index_13.Intersect)(T, options);
    }
    KeyOf(schema3, options = {}) {
      return (0, index_15.KeyOf)(schema3, options);
    }
    Literal(value15, options = {}) {
      return (0, index_16.Literal)(value15, options);
    }
    Lowercase(schema3, options = {}) {
      return (0, index_14.Lowercase)(schema3, options);
    }
    Mapped(key, map3, options = {}) {
      return (0, index_17.Mapped)(key, map3, options);
    }
    Never(options = {}) {
      return (0, index_18.Never)(options);
    }
    Not(schema3, options) {
      return (0, index_19.Not)(schema3, options);
    }
    Null(options = {}) {
      return (0, index_20.Null)(options);
    }
    Number(options = {}) {
      return (0, index_21.Number)(options);
    }
    Object(properties, options = {}) {
      return (0, index_22.Object)(properties, options);
    }
    Omit(schema3, unresolved, options = {}) {
      return (0, index_23.Omit)(schema3, unresolved, options);
    }
    Partial(schema3, options = {}) {
      return (0, index_25.Partial)(schema3, options);
    }
    Pick(schema3, unresolved, options = {}) {
      return (0, index_26.Pick)(schema3, unresolved, options);
    }
    Record(key, schema3, options = {}) {
      return (0, index_29.Record)(key, schema3, options);
    }
    Recursive(callback, options = {}) {
      return (0, index_30.Recursive)(callback, options);
    }
    Ref(unresolved, options = {}) {
      return (0, index_31.Ref)(unresolved, options);
    }
    Required(schema3, options = {}) {
      return (0, index_32.Required)(schema3, options);
    }
    Rest(schema3) {
      return (0, index_33.Rest)(schema3);
    }
    String(options = {}) {
      return (0, index_35.String)(options);
    }
    TemplateLiteral(unresolved, options = {}) {
      return (0, index_36.TemplateLiteral)(unresolved, options);
    }
    Transform(schema3) {
      return (0, index_37.Transform)(schema3);
    }
    Tuple(items, options = {}) {
      return (0, index_38.Tuple)(items, options);
    }
    Uncapitalize(schema3, options = {}) {
      return (0, index_14.Uncapitalize)(schema3, options);
    }
    Union(schemas, options = {}) {
      return (0, index_39.Union)(schemas, options);
    }
    Unknown(options = {}) {
      return (0, index_40.Unknown)(options);
    }
    Unsafe(options = {}) {
      return (0, index_41.Unsafe)(options);
    }
    Uppercase(schema3, options = {}) {
      return (0, index_14.Uppercase)(schema3, options);
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder2;
});

// node_modules/@sinclair/typebox/build/require/type/type/type.js
var require_type4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Strict = exports.ReturnType = exports.Rest = exports.Required = exports.RegExp = exports.Ref = exports.Recursive = exports.Record = exports.ReadonlyOptional = exports.Readonly = exports.Promise = exports.Pick = exports.Partial = exports.Parameters = exports.Optional = exports.Omit = exports.Object = exports.Number = exports.Null = exports.Not = exports.Never = exports.Mapped = exports.Literal = exports.KeyOf = exports.Iterator = exports.Uppercase = exports.Lowercase = exports.Uncapitalize = exports.Capitalize = exports.Intersect = exports.Integer = exports.InstanceType = exports.Index = exports.Function = exports.Extract = exports.Extends = exports.Exclude = exports.Enum = exports.Deref = exports.Date = exports.ConstructorParameters = exports.Constructor = exports.Const = exports.Composite = exports.Boolean = exports.BigInt = exports.Awaited = exports.AsyncIterator = exports.Array = exports.Any = undefined;
  exports.Void = exports.Unsafe = exports.Unknown = exports.Union = exports.Undefined = exports.Uint8Array = exports.Tuple = exports.Transform = exports.TemplateLiteral = exports.Symbol = exports.String = undefined;
  var index_1 = require_any2();
  Object.defineProperty(exports, "Any", { enumerable: true, get: function() {
    return index_1.Any;
  } });
  var index_2 = require_array2();
  Object.defineProperty(exports, "Array", { enumerable: true, get: function() {
    return index_2.Array;
  } });
  var index_3 = require_async_iterator2();
  Object.defineProperty(exports, "AsyncIterator", { enumerable: true, get: function() {
    return index_3.AsyncIterator;
  } });
  var index_4 = require_awaited2();
  Object.defineProperty(exports, "Awaited", { enumerable: true, get: function() {
    return index_4.Awaited;
  } });
  var index_5 = require_bigint2();
  Object.defineProperty(exports, "BigInt", { enumerable: true, get: function() {
    return index_5.BigInt;
  } });
  var index_6 = require_boolean2();
  Object.defineProperty(exports, "Boolean", { enumerable: true, get: function() {
    return index_6.Boolean;
  } });
  var index_7 = require_composite2();
  Object.defineProperty(exports, "Composite", { enumerable: true, get: function() {
    return index_7.Composite;
  } });
  var index_8 = require_const2();
  Object.defineProperty(exports, "Const", { enumerable: true, get: function() {
    return index_8.Const;
  } });
  var index_9 = require_constructor2();
  Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
    return index_9.Constructor;
  } });
  var index_10 = require_constructor_parameters2();
  Object.defineProperty(exports, "ConstructorParameters", { enumerable: true, get: function() {
    return index_10.ConstructorParameters;
  } });
  var index_11 = require_date2();
  Object.defineProperty(exports, "Date", { enumerable: true, get: function() {
    return index_11.Date;
  } });
  var index_12 = require_deref4();
  Object.defineProperty(exports, "Deref", { enumerable: true, get: function() {
    return index_12.Deref;
  } });
  var index_13 = require_enum2();
  Object.defineProperty(exports, "Enum", { enumerable: true, get: function() {
    return index_13.Enum;
  } });
  var index_14 = require_exclude2();
  Object.defineProperty(exports, "Exclude", { enumerable: true, get: function() {
    return index_14.Exclude;
  } });
  var index_15 = require_extends2();
  Object.defineProperty(exports, "Extends", { enumerable: true, get: function() {
    return index_15.Extends;
  } });
  var index_16 = require_extract2();
  Object.defineProperty(exports, "Extract", { enumerable: true, get: function() {
    return index_16.Extract;
  } });
  var index_17 = require_function2();
  Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
    return index_17.Function;
  } });
  var index_18 = require_indexed2();
  Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
    return index_18.Index;
  } });
  var index_19 = require_instance_type2();
  Object.defineProperty(exports, "InstanceType", { enumerable: true, get: function() {
    return index_19.InstanceType;
  } });
  var index_20 = require_integer2();
  Object.defineProperty(exports, "Integer", { enumerable: true, get: function() {
    return index_20.Integer;
  } });
  var index_21 = require_intersect2();
  Object.defineProperty(exports, "Intersect", { enumerable: true, get: function() {
    return index_21.Intersect;
  } });
  var index_22 = require_intrinsic2();
  Object.defineProperty(exports, "Capitalize", { enumerable: true, get: function() {
    return index_22.Capitalize;
  } });
  Object.defineProperty(exports, "Uncapitalize", { enumerable: true, get: function() {
    return index_22.Uncapitalize;
  } });
  Object.defineProperty(exports, "Lowercase", { enumerable: true, get: function() {
    return index_22.Lowercase;
  } });
  Object.defineProperty(exports, "Uppercase", { enumerable: true, get: function() {
    return index_22.Uppercase;
  } });
  var index_23 = require_iterator2();
  Object.defineProperty(exports, "Iterator", { enumerable: true, get: function() {
    return index_23.Iterator;
  } });
  var index_24 = require_keyof2();
  Object.defineProperty(exports, "KeyOf", { enumerable: true, get: function() {
    return index_24.KeyOf;
  } });
  var index_25 = require_literal2();
  Object.defineProperty(exports, "Literal", { enumerable: true, get: function() {
    return index_25.Literal;
  } });
  var index_26 = require_mapped2();
  Object.defineProperty(exports, "Mapped", { enumerable: true, get: function() {
    return index_26.Mapped;
  } });
  var index_27 = require_never2();
  Object.defineProperty(exports, "Never", { enumerable: true, get: function() {
    return index_27.Never;
  } });
  var index_28 = require_not2();
  Object.defineProperty(exports, "Not", { enumerable: true, get: function() {
    return index_28.Not;
  } });
  var index_29 = require_null2();
  Object.defineProperty(exports, "Null", { enumerable: true, get: function() {
    return index_29.Null;
  } });
  var index_30 = require_number2();
  Object.defineProperty(exports, "Number", { enumerable: true, get: function() {
    return index_30.Number;
  } });
  var index_31 = require_object2();
  Object.defineProperty(exports, "Object", { enumerable: true, get: function() {
    return index_31.Object;
  } });
  var index_32 = require_omit2();
  Object.defineProperty(exports, "Omit", { enumerable: true, get: function() {
    return index_32.Omit;
  } });
  var index_33 = require_optional2();
  Object.defineProperty(exports, "Optional", { enumerable: true, get: function() {
    return index_33.Optional;
  } });
  var index_34 = require_parameters2();
  Object.defineProperty(exports, "Parameters", { enumerable: true, get: function() {
    return index_34.Parameters;
  } });
  var index_35 = require_partial2();
  Object.defineProperty(exports, "Partial", { enumerable: true, get: function() {
    return index_35.Partial;
  } });
  var index_36 = require_pick2();
  Object.defineProperty(exports, "Pick", { enumerable: true, get: function() {
    return index_36.Pick;
  } });
  var index_37 = require_promise2();
  Object.defineProperty(exports, "Promise", { enumerable: true, get: function() {
    return index_37.Promise;
  } });
  var index_38 = require_readonly2();
  Object.defineProperty(exports, "Readonly", { enumerable: true, get: function() {
    return index_38.Readonly;
  } });
  var index_39 = require_readonly_optional2();
  Object.defineProperty(exports, "ReadonlyOptional", { enumerable: true, get: function() {
    return index_39.ReadonlyOptional;
  } });
  var index_40 = require_record2();
  Object.defineProperty(exports, "Record", { enumerable: true, get: function() {
    return index_40.Record;
  } });
  var index_41 = require_recursive2();
  Object.defineProperty(exports, "Recursive", { enumerable: true, get: function() {
    return index_41.Recursive;
  } });
  var index_42 = require_ref2();
  Object.defineProperty(exports, "Ref", { enumerable: true, get: function() {
    return index_42.Ref;
  } });
  var index_43 = require_regexp2();
  Object.defineProperty(exports, "RegExp", { enumerable: true, get: function() {
    return index_43.RegExp;
  } });
  var index_44 = require_required2();
  Object.defineProperty(exports, "Required", { enumerable: true, get: function() {
    return index_44.Required;
  } });
  var index_45 = require_rest2();
  Object.defineProperty(exports, "Rest", { enumerable: true, get: function() {
    return index_45.Rest;
  } });
  var index_46 = require_return_type2();
  Object.defineProperty(exports, "ReturnType", { enumerable: true, get: function() {
    return index_46.ReturnType;
  } });
  var index_47 = require_strict2();
  Object.defineProperty(exports, "Strict", { enumerable: true, get: function() {
    return index_47.Strict;
  } });
  var index_48 = require_string2();
  Object.defineProperty(exports, "String", { enumerable: true, get: function() {
    return index_48.String;
  } });
  var index_49 = require_symbol2();
  Object.defineProperty(exports, "Symbol", { enumerable: true, get: function() {
    return index_49.Symbol;
  } });
  var index_50 = require_template_literal2();
  Object.defineProperty(exports, "TemplateLiteral", { enumerable: true, get: function() {
    return index_50.TemplateLiteral;
  } });
  var index_51 = require_transform3();
  Object.defineProperty(exports, "Transform", { enumerable: true, get: function() {
    return index_51.Transform;
  } });
  var index_52 = require_tuple2();
  Object.defineProperty(exports, "Tuple", { enumerable: true, get: function() {
    return index_52.Tuple;
  } });
  var index_53 = require_uint8array2();
  Object.defineProperty(exports, "Uint8Array", { enumerable: true, get: function() {
    return index_53.Uint8Array;
  } });
  var index_54 = require_undefined2();
  Object.defineProperty(exports, "Undefined", { enumerable: true, get: function() {
    return index_54.Undefined;
  } });
  var index_55 = require_union2();
  Object.defineProperty(exports, "Union", { enumerable: true, get: function() {
    return index_55.Union;
  } });
  var index_56 = require_unknown2();
  Object.defineProperty(exports, "Unknown", { enumerable: true, get: function() {
    return index_56.Unknown;
  } });
  var index_57 = require_unsafe2();
  Object.defineProperty(exports, "Unsafe", { enumerable: true, get: function() {
    return index_57.Unsafe;
  } });
  var index_58 = require_void2();
  Object.defineProperty(exports, "Void", { enumerable: true, get: function() {
    return index_58.Void;
  } });
});

// node_modules/@sinclair/typebox/build/require/type/type/javascript.js
var require_javascript = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JavaScriptTypeBuilder = undefined;
  var json_1 = require_json();
  var index_1 = require_async_iterator2();
  var index_2 = require_awaited2();
  var index_3 = require_bigint2();
  var index_4 = require_constructor2();
  var index_5 = require_constructor_parameters2();
  var index_6 = require_date2();
  var index_7 = require_function2();
  var index_8 = require_instance_type2();
  var index_9 = require_iterator2();
  var index_10 = require_parameters2();
  var index_11 = require_promise2();
  var index_12 = require_regexp2();
  var index_13 = require_return_type2();
  var index_14 = require_symbol2();
  var index_15 = require_uint8array2();
  var index_16 = require_undefined2();
  var index_17 = require_void2();

  class JavaScriptTypeBuilder2 extends json_1.JsonTypeBuilder {
    AsyncIterator(items, options = {}) {
      return (0, index_1.AsyncIterator)(items, options);
    }
    Awaited(schema3, options = {}) {
      return (0, index_2.Awaited)(schema3, options);
    }
    BigInt(options = {}) {
      return (0, index_3.BigInt)(options);
    }
    ConstructorParameters(schema3, options = {}) {
      return (0, index_5.ConstructorParameters)(schema3, options);
    }
    Constructor(parameters4, returns, options) {
      return (0, index_4.Constructor)(parameters4, returns, options);
    }
    Date(options = {}) {
      return (0, index_6.Date)(options);
    }
    Function(parameters4, returns, options) {
      return (0, index_7.Function)(parameters4, returns, options);
    }
    InstanceType(schema3, options = {}) {
      return (0, index_8.InstanceType)(schema3, options);
    }
    Iterator(items, options = {}) {
      return (0, index_9.Iterator)(items, options);
    }
    Parameters(schema3, options = {}) {
      return (0, index_10.Parameters)(schema3, options);
    }
    Promise(item, options = {}) {
      return (0, index_11.Promise)(item, options);
    }
    RegExp(unresolved, options = {}) {
      return (0, index_12.RegExp)(unresolved, options);
    }
    ReturnType(schema3, options = {}) {
      return (0, index_13.ReturnType)(schema3, options);
    }
    Symbol(options) {
      return (0, index_14.Symbol)(options);
    }
    Undefined(options = {}) {
      return (0, index_16.Undefined)(options);
    }
    Uint8Array(options = {}) {
      return (0, index_15.Uint8Array)(options);
    }
    Void(options = {}) {
      return (0, index_17.Void)(options);
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder2;
});

// node_modules/@sinclair/typebox/build/require/type/type/index.js
var require_type5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = undefined;
  var json_1 = require_json();
  Object.defineProperty(exports, "JsonTypeBuilder", { enumerable: true, get: function() {
    return json_1.JsonTypeBuilder;
  } });
  var TypeBuilder = require_type4();
  var javascript_1 = require_javascript();
  Object.defineProperty(exports, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
    return javascript_1.JavaScriptTypeBuilder;
  } });
  var Type2 = TypeBuilder;
  exports.Type = Type2;
});

// node_modules/@sinclair/typebox/build/require/index.js
var require_require = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone3(), exports);
  __exportStar(require_error2(), exports);
  __exportStar(require_guard3(), exports);
  __exportStar(require_helpers2(), exports);
  __exportStar(require_patterns2(), exports);
  __exportStar(require_registry(), exports);
  __exportStar(require_sets(), exports);
  __exportStar(require_symbols2(), exports);
  __exportStar(require_any2(), exports);
  __exportStar(require_array2(), exports);
  __exportStar(require_async_iterator2(), exports);
  __exportStar(require_awaited2(), exports);
  __exportStar(require_bigint2(), exports);
  __exportStar(require_boolean2(), exports);
  __exportStar(require_composite2(), exports);
  __exportStar(require_const2(), exports);
  __exportStar(require_constructor2(), exports);
  __exportStar(require_constructor_parameters2(), exports);
  __exportStar(require_date2(), exports);
  __exportStar(require_deref4(), exports);
  __exportStar(require_enum2(), exports);
  __exportStar(require_exclude2(), exports);
  __exportStar(require_extends2(), exports);
  __exportStar(require_extract2(), exports);
  __exportStar(require_function2(), exports);
  __exportStar(require_indexed2(), exports);
  __exportStar(require_instance_type2(), exports);
  __exportStar(require_integer2(), exports);
  __exportStar(require_intersect2(), exports);
  __exportStar(require_iterator2(), exports);
  __exportStar(require_intrinsic2(), exports);
  __exportStar(require_keyof2(), exports);
  __exportStar(require_literal2(), exports);
  __exportStar(require_mapped2(), exports);
  __exportStar(require_never2(), exports);
  __exportStar(require_not2(), exports);
  __exportStar(require_null2(), exports);
  __exportStar(require_number2(), exports);
  __exportStar(require_object2(), exports);
  __exportStar(require_omit2(), exports);
  __exportStar(require_optional2(), exports);
  __exportStar(require_parameters2(), exports);
  __exportStar(require_partial2(), exports);
  __exportStar(require_pick2(), exports);
  __exportStar(require_promise2(), exports);
  __exportStar(require_readonly2(), exports);
  __exportStar(require_readonly_optional2(), exports);
  __exportStar(require_record2(), exports);
  __exportStar(require_recursive2(), exports);
  __exportStar(require_ref2(), exports);
  __exportStar(require_regexp2(), exports);
  __exportStar(require_required2(), exports);
  __exportStar(require_rest2(), exports);
  __exportStar(require_return_type2(), exports);
  __exportStar(require_schema2(), exports);
  __exportStar(require_static2(), exports);
  __exportStar(require_strict2(), exports);
  __exportStar(require_string2(), exports);
  __exportStar(require_symbol2(), exports);
  __exportStar(require_template_literal2(), exports);
  __exportStar(require_transform3(), exports);
  __exportStar(require_tuple2(), exports);
  __exportStar(require_uint8array2(), exports);
  __exportStar(require_undefined2(), exports);
  __exportStar(require_union2(), exports);
  __exportStar(require_unknown2(), exports);
  __exportStar(require_unsafe2(), exports);
  __exportStar(require_void2(), exports);
  __exportStar(require_type5(), exports);
});

// node_modules/@sinclair/typebox/build/require/compiler/compiler.js
var require_compiler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = undefined;
  var index_1 = require_transform();
  var index_2 = require_errors2();
  var index_3 = require_system2();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_symbols2();
  var index_8 = require_registry();
  var index_9 = require_keyof2();
  var extends_undefined_1 = require_extends_undefined();
  var index_10 = require_never2();
  var index_11 = require_guard2();
  var type_1 = require_type3();

  class TypeCheck2 {
    constructor(schema3, references, checkFunc, code) {
      this.schema = schema3;
      this.references = references;
      this.checkFunc = checkFunc;
      this.code = code;
      this.hasTransform = (0, index_1.HasTransform)(schema3, references);
    }
    Code() {
      return this.code;
    }
    Errors(value15) {
      return (0, index_2.Errors)(this.schema, this.references, value15);
    }
    Check(value15) {
      return this.checkFunc(value15);
    }
    Decode(value15) {
      if (!this.checkFunc(value15))
        throw new index_1.TransformDecodeCheckError(this.schema, value15, this.Errors(value15).First());
      return this.hasTransform ? (0, index_1.TransformDecode)(this.schema, this.references, value15) : value15;
    }
    Encode(value15) {
      const encoded = this.hasTransform ? (0, index_1.TransformEncode)(this.schema, this.references, value15) : value15;
      if (!this.checkFunc(encoded))
        throw new index_1.TransformEncodeCheckError(this.schema, value15, this.Errors(value15).First());
      return encoded;
    }
  }
  exports.TypeCheck = TypeCheck2;
  var Character2;
  (function(Character3) {
    function DollarSign(code) {
      return code === 36;
    }
    Character3.DollarSign = DollarSign;
    function IsUnderscore(code) {
      return code === 95;
    }
    Character3.IsUnderscore = IsUnderscore;
    function IsAlpha(code) {
      return code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
    Character3.IsAlpha = IsAlpha;
    function IsNumeric(code) {
      return code >= 48 && code <= 57;
    }
    Character3.IsNumeric = IsNumeric;
  })(Character2 || (Character2 = {}));
  var MemberExpression2;
  (function(MemberExpression3) {
    function IsFirstCharacterNumeric(value15) {
      if (value15.length === 0)
        return false;
      return Character2.IsNumeric(value15.charCodeAt(0));
    }
    function IsAccessor(value15) {
      if (IsFirstCharacterNumeric(value15))
        return false;
      for (let i = 0;i < value15.length; i++) {
        const code = value15.charCodeAt(i);
        const check11 = Character2.IsAlpha(code) || Character2.IsNumeric(code) || Character2.DollarSign(code) || Character2.IsUnderscore(code);
        if (!check11)
          return false;
      }
      return true;
    }
    function EscapeHyphen(key) {
      return key.replace(/'/g, "\\'");
    }
    function Encode2(object13, key) {
      return IsAccessor(key) ? `${object13}.${key}` : `${object13}['${EscapeHyphen(key)}']`;
    }
    MemberExpression3.Encode = Encode2;
  })(MemberExpression2 || (MemberExpression2 = {}));
  var Identifier2;
  (function(Identifier3) {
    function Encode2($id) {
      const buffer = [];
      for (let i = 0;i < $id.length; i++) {
        const code = $id.charCodeAt(i);
        if (Character2.IsNumeric(code) || Character2.IsAlpha(code)) {
          buffer.push($id.charAt(i));
        } else {
          buffer.push(`_${code}_`);
        }
      }
      return buffer.join("").replace(/__/g, "_");
    }
    Identifier3.Encode = Encode2;
  })(Identifier2 || (Identifier2 = {}));
  var LiteralString2;
  (function(LiteralString3) {
    function Escape3(content) {
      return content.replace(/'/g, "\\'");
    }
    LiteralString3.Escape = Escape3;
  })(LiteralString2 || (LiteralString2 = {}));

  class TypeCompilerUnknownTypeError2 extends index_4.TypeBoxError {
    constructor(schema3) {
      super("Unknown type");
      this.schema = schema3;
    }
  }
  exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError2;

  class TypeCompilerTypeGuardError2 extends index_4.TypeBoxError {
    constructor(schema3) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = schema3;
    }
  }
  exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError2;
  var Policy2;
  (function(Policy3) {
    function IsExactOptionalProperty(value15, key, expression) {
      return index_3.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value15} ? ${expression} : true)` : `(${MemberExpression2.Encode(value15, key)} !== undefined ? ${expression} : true)`;
    }
    Policy3.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value15) {
      return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value15} === 'object' && ${value15} !== null && !Array.isArray(${value15}))` : `(typeof ${value15} === 'object' && ${value15} !== null)`;
    }
    Policy3.IsObjectLike = IsObjectLike;
    function IsRecordLike(value15) {
      return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value15} === 'object' && ${value15} !== null && !Array.isArray(${value15}) && !(${value15} instanceof Date) && !(${value15} instanceof Uint8Array))` : `(typeof ${value15} === 'object' && ${value15} !== null && !(${value15} instanceof Date) && !(${value15} instanceof Uint8Array))`;
    }
    Policy3.IsRecordLike = IsRecordLike;
    function IsNumberLike(value15) {
      return !index_3.TypeSystemPolicy.AllowNaN ? `(typeof ${value15} === 'number' && Number.isFinite(${value15}))` : `typeof ${value15} === 'number'`;
    }
    Policy3.IsNumberLike = IsNumberLike;
    function IsVoidLike(value15) {
      return index_3.TypeSystemPolicy.AllowNullVoid ? `(${value15} === undefined || ${value15} === null)` : `${value15} === undefined`;
    }
    Policy3.IsVoidLike = IsVoidLike;
  })(Policy2 || (exports.Policy = Policy2 = {}));
  var TypeCompiler2;
  (function(TypeCompiler3) {
    function IsAnyOrUnknown2(schema3) {
      return schema3[index_7.Kind] === "Any" || schema3[index_7.Kind] === "Unknown";
    }
    function* FromAny5(schema3, references, value15) {
      yield "true";
    }
    function* FromArray16(schema3, references, value15) {
      yield `Array.isArray(${value15})`;
      const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
      if ((0, index_11.IsNumber)(schema3.maxItems))
        yield `${value15}.length <= ${schema3.maxItems}`;
      if ((0, index_11.IsNumber)(schema3.minItems))
        yield `${value15}.length >= ${schema3.minItems}`;
      const elementExpression = CreateExpression(schema3.items, references, "value");
      yield `${value15}.every((${parameter}) => ${elementExpression})`;
      if ((0, type_1.IsSchema)(schema3.contains) || (0, index_11.IsNumber)(schema3.minContains) || (0, index_11.IsNumber)(schema3.maxContains)) {
        const containsSchema = (0, type_1.IsSchema)(schema3.contains) ? schema3.contains : (0, index_10.Never)();
        const checkExpression = CreateExpression(containsSchema, references, "value");
        const checkMinContains = (0, index_11.IsNumber)(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
        const checkMaxContains = (0, index_11.IsNumber)(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
        const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
        const check11 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
        yield `((${parameter}) => { ${checkCount}; return ${check11}})(${value15})`;
      }
      if (schema3.uniqueItems === true) {
        const check11 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
        const block = `const set = new Set(); for(const element of value) { ${check11} }`;
        yield `((${parameter}) => { ${block} )(${value15})`;
      }
    }
    function* FromAsyncIterator7(schema3, references, value15) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${value15})`;
    }
    function* FromBigInt6(schema3, references, value15) {
      yield `(typeof ${value15} === 'bigint')`;
      if ((0, index_11.IsBigInt)(schema3.exclusiveMaximum))
        yield `${value15} < BigInt(${schema3.exclusiveMaximum})`;
      if ((0, index_11.IsBigInt)(schema3.exclusiveMinimum))
        yield `${value15} > BigInt(${schema3.exclusiveMinimum})`;
      if ((0, index_11.IsBigInt)(schema3.maximum))
        yield `${value15} <= BigInt(${schema3.maximum})`;
      if ((0, index_11.IsBigInt)(schema3.minimum))
        yield `${value15} >= BigInt(${schema3.minimum})`;
      if ((0, index_11.IsBigInt)(schema3.multipleOf))
        yield `(${value15} % BigInt(${schema3.multipleOf})) === 0`;
    }
    function* FromBoolean6(schema3, references, value15) {
      yield `(typeof ${value15} === 'boolean')`;
    }
    function* FromConstructor8(schema3, references, value15) {
      yield* Visit17(schema3.returns, references, `${value15}.prototype`);
    }
    function* FromDate6(schema3, references, value15) {
      yield `(${value15} instanceof Date) && Number.isFinite(${value15}.getTime())`;
      if ((0, index_11.IsNumber)(schema3.exclusiveMaximumTimestamp))
        yield `${value15}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
      if ((0, index_11.IsNumber)(schema3.exclusiveMinimumTimestamp))
        yield `${value15}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
      if ((0, index_11.IsNumber)(schema3.maximumTimestamp))
        yield `${value15}.getTime() <= ${schema3.maximumTimestamp}`;
      if ((0, index_11.IsNumber)(schema3.minimumTimestamp))
        yield `${value15}.getTime() >= ${schema3.minimumTimestamp}`;
      if ((0, index_11.IsNumber)(schema3.multipleOfTimestamp))
        yield `(${value15}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
    }
    function* FromFunction7(schema3, references, value15) {
      yield `(typeof ${value15} === 'function')`;
    }
    function* FromInteger6(schema3, references, value15) {
      yield `(typeof ${value15} === 'number' && Number.isInteger(${value15}))`;
      if ((0, index_11.IsNumber)(schema3.exclusiveMaximum))
        yield `${value15} < ${schema3.exclusiveMaximum}`;
      if ((0, index_11.IsNumber)(schema3.exclusiveMinimum))
        yield `${value15} > ${schema3.exclusiveMinimum}`;
      if ((0, index_11.IsNumber)(schema3.maximum))
        yield `${value15} <= ${schema3.maximum}`;
      if ((0, index_11.IsNumber)(schema3.minimum))
        yield `${value15} >= ${schema3.minimum}`;
      if ((0, index_11.IsNumber)(schema3.multipleOf))
        yield `(${value15} % ${schema3.multipleOf}) === 0`;
    }
    function* FromIntersect18(schema3, references, value15) {
      const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value15)).join(" && ");
      if (schema3.unevaluatedProperties === false) {
        const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema3))};`);
        const check22 = `Object.getOwnPropertyNames(${value15}).every(key => ${keyCheck}.test(key))`;
        yield `(${check1} && ${check22})`;
      } else if ((0, type_1.IsSchema)(schema3.unevaluatedProperties)) {
        const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema3))};`);
        const check22 = `Object.getOwnPropertyNames(${value15}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value15}[key]`)})`;
        yield `(${check1} && ${check22})`;
      } else {
        yield `(${check1})`;
      }
    }
    function* FromIterator7(schema3, references, value15) {
      yield `(typeof value === 'object' && Symbol.iterator in ${value15})`;
    }
    function* FromLiteral7(schema3, references, value15) {
      if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
        yield `(${value15} === ${schema3.const})`;
      } else {
        yield `(${value15} === '${LiteralString2.Escape(schema3.const)}')`;
      }
    }
    function* FromNever6(schema3, references, value15) {
      yield `false`;
    }
    function* FromNot8(schema3, references, value15) {
      const expression = CreateExpression(schema3.not, references, value15);
      yield `(!${expression})`;
    }
    function* FromNull6(schema3, references, value15) {
      yield `(${value15} === null)`;
    }
    function* FromNumber6(schema3, references, value15) {
      yield Policy2.IsNumberLike(value15);
      if ((0, index_11.IsNumber)(schema3.exclusiveMaximum))
        yield `${value15} < ${schema3.exclusiveMaximum}`;
      if ((0, index_11.IsNumber)(schema3.exclusiveMinimum))
        yield `${value15} > ${schema3.exclusiveMinimum}`;
      if ((0, index_11.IsNumber)(schema3.maximum))
        yield `${value15} <= ${schema3.maximum}`;
      if ((0, index_11.IsNumber)(schema3.minimum))
        yield `${value15} >= ${schema3.minimum}`;
      if ((0, index_11.IsNumber)(schema3.multipleOf))
        yield `(${value15} % ${schema3.multipleOf}) === 0`;
    }
    function* FromObject13(schema3, references, value15) {
      yield Policy2.IsObjectLike(value15);
      if ((0, index_11.IsNumber)(schema3.minProperties))
        yield `Object.getOwnPropertyNames(${value15}).length >= ${schema3.minProperties}`;
      if ((0, index_11.IsNumber)(schema3.maxProperties))
        yield `Object.getOwnPropertyNames(${value15}).length <= ${schema3.maxProperties}`;
      const knownKeys = Object.getOwnPropertyNames(schema3.properties);
      for (const knownKey of knownKeys) {
        const memberExpression = MemberExpression2.Encode(value15, knownKey);
        const property = schema3.properties[knownKey];
        if (schema3.required && schema3.required.includes(knownKey)) {
          yield* Visit17(property, references, memberExpression);
          if ((0, extends_undefined_1.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown2(property))
            yield `('${knownKey}' in ${value15})`;
        } else {
          const expression = CreateExpression(property, references, memberExpression);
          yield Policy2.IsExactOptionalProperty(value15, knownKey, expression);
        }
      }
      if (schema3.additionalProperties === false) {
        if (schema3.required && schema3.required.length === knownKeys.length) {
          yield `Object.getOwnPropertyNames(${value15}).length === ${knownKeys.length}`;
        } else {
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${value15}).every(key => ${keys}.includes(key))`;
        }
      }
      if (typeof schema3.additionalProperties === "object") {
        const expression = CreateExpression(schema3.additionalProperties, references, `${value15}[key]`);
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${value15}).every(key => ${keys}.includes(key) || ${expression}))`;
      }
    }
    function* FromPromise8(schema3, references, value15) {
      yield `(typeof value === 'object' && typeof ${value15}.then === 'function')`;
    }
    function* FromRecord12(schema3, references, value15) {
      yield Policy2.IsRecordLike(value15);
      if ((0, index_11.IsNumber)(schema3.minProperties))
        yield `Object.getOwnPropertyNames(${value15}).length >= ${schema3.minProperties}`;
      if ((0, index_11.IsNumber)(schema3.maxProperties))
        yield `Object.getOwnPropertyNames(${value15}).length <= ${schema3.maxProperties}`;
      const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
      const variable = CreateVariable(`${new RegExp(patternKey)}`);
      const check1 = CreateExpression(patternSchema, references, "value");
      const check22 = (0, type_1.IsSchema)(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value15) : schema3.additionalProperties === false ? "false" : "true";
      const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
      yield `(Object.entries(${value15}).every(([key, value]) => ${expression}))`;
    }
    function* FromRef12(schema3, references, value15) {
      const target = (0, index_5.Deref)(schema3, references);
      if (state.functions.has(schema3.$ref))
        return yield `${CreateFunctionName(schema3.$ref)}(${value15})`;
      yield* Visit17(target, references, value15);
    }
    function* FromRegExp5(schema3, references, value15) {
      const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
      yield `(typeof ${value15} === 'string')`;
      if ((0, index_11.IsNumber)(schema3.maxLength))
        yield `${value15}.length <= ${schema3.maxLength}`;
      if ((0, index_11.IsNumber)(schema3.minLength))
        yield `${value15}.length >= ${schema3.minLength}`;
      yield `${variable}.test(${value15})`;
    }
    function* FromString6(schema3, references, value15) {
      yield `(typeof ${value15} === 'string')`;
      if ((0, index_11.IsNumber)(schema3.maxLength))
        yield `${value15}.length <= ${schema3.maxLength}`;
      if ((0, index_11.IsNumber)(schema3.minLength))
        yield `${value15}.length >= ${schema3.minLength}`;
      if (schema3.pattern !== undefined) {
        const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
        yield `${variable}.test(${value15})`;
      }
      if (schema3.format !== undefined) {
        yield `format('${schema3.format}', ${value15})`;
      }
    }
    function* FromSymbol6(schema3, references, value15) {
      yield `(typeof ${value15} === 'symbol')`;
    }
    function* FromTemplateLiteral7(schema3, references, value15) {
      yield `(typeof ${value15} === 'string')`;
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value15})`;
    }
    function* FromThis11(schema3, references, value15) {
      yield `${CreateFunctionName(schema3.$ref)}(${value15})`;
    }
    function* FromTuple15(schema3, references, value15) {
      yield `Array.isArray(${value15})`;
      if (schema3.items === undefined)
        return yield `${value15}.length === 0`;
      yield `(${value15}.length === ${schema3.maxItems})`;
      for (let i = 0;i < schema3.items.length; i++) {
        const expression = CreateExpression(schema3.items[i], references, `${value15}[${i}]`);
        yield `${expression}`;
      }
    }
    function* FromUndefined6(schema3, references, value15) {
      yield `${value15} === undefined`;
    }
    function* FromUnion20(schema3, references, value15) {
      const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value15));
      yield `(${expressions.join(" || ")})`;
    }
    function* FromUint8Array5(schema3, references, value15) {
      yield `${value15} instanceof Uint8Array`;
      if ((0, index_11.IsNumber)(schema3.maxByteLength))
        yield `(${value15}.length <= ${schema3.maxByteLength})`;
      if ((0, index_11.IsNumber)(schema3.minByteLength))
        yield `(${value15}.length >= ${schema3.minByteLength})`;
    }
    function* FromUnknown5(schema3, references, value15) {
      yield "true";
    }
    function* FromVoid5(schema3, references, value15) {
      yield Policy2.IsVoidLike(value15);
    }
    function* FromKind4(schema3, references, value15) {
      const instance = state.instances.size;
      state.instances.set(instance, schema3);
      yield `kind('${schema3[index_7.Kind]}', ${instance}, ${value15})`;
    }
    function* Visit17(schema3, references, value15, useHoisting = true) {
      const references_ = (0, index_11.IsString)(schema3.$id) ? [...references, schema3] : references;
      const schema_ = schema3;
      if (useHoisting && (0, index_11.IsString)(schema3.$id)) {
        const functionName = CreateFunctionName(schema3.$id);
        if (state.functions.has(functionName)) {
          return yield `${functionName}(${value15})`;
        } else {
          const functionCode = CreateFunction(functionName, schema3, references, "value", false);
          state.functions.set(functionName, functionCode);
          return yield `${functionName}(${value15})`;
        }
      }
      switch (schema_[index_7.Kind]) {
        case "Any":
          return yield* FromAny5(schema_, references_, value15);
        case "Array":
          return yield* FromArray16(schema_, references_, value15);
        case "AsyncIterator":
          return yield* FromAsyncIterator7(schema_, references_, value15);
        case "BigInt":
          return yield* FromBigInt6(schema_, references_, value15);
        case "Boolean":
          return yield* FromBoolean6(schema_, references_, value15);
        case "Constructor":
          return yield* FromConstructor8(schema_, references_, value15);
        case "Date":
          return yield* FromDate6(schema_, references_, value15);
        case "Function":
          return yield* FromFunction7(schema_, references_, value15);
        case "Integer":
          return yield* FromInteger6(schema_, references_, value15);
        case "Intersect":
          return yield* FromIntersect18(schema_, references_, value15);
        case "Iterator":
          return yield* FromIterator7(schema_, references_, value15);
        case "Literal":
          return yield* FromLiteral7(schema_, references_, value15);
        case "Never":
          return yield* FromNever6(schema_, references_, value15);
        case "Not":
          return yield* FromNot8(schema_, references_, value15);
        case "Null":
          return yield* FromNull6(schema_, references_, value15);
        case "Number":
          return yield* FromNumber6(schema_, references_, value15);
        case "Object":
          return yield* FromObject13(schema_, references_, value15);
        case "Promise":
          return yield* FromPromise8(schema_, references_, value15);
        case "Record":
          return yield* FromRecord12(schema_, references_, value15);
        case "Ref":
          return yield* FromRef12(schema_, references_, value15);
        case "RegExp":
          return yield* FromRegExp5(schema_, references_, value15);
        case "String":
          return yield* FromString6(schema_, references_, value15);
        case "Symbol":
          return yield* FromSymbol6(schema_, references_, value15);
        case "TemplateLiteral":
          return yield* FromTemplateLiteral7(schema_, references_, value15);
        case "This":
          return yield* FromThis11(schema_, references_, value15);
        case "Tuple":
          return yield* FromTuple15(schema_, references_, value15);
        case "Undefined":
          return yield* FromUndefined6(schema_, references_, value15);
        case "Union":
          return yield* FromUnion20(schema_, references_, value15);
        case "Uint8Array":
          return yield* FromUint8Array5(schema_, references_, value15);
        case "Unknown":
          return yield* FromUnknown5(schema_, references_, value15);
        case "Void":
          return yield* FromVoid5(schema_, references_, value15);
        default:
          if (!index_8.TypeRegistry.Has(schema_[index_7.Kind]))
            throw new TypeCompilerUnknownTypeError2(schema3);
          return yield* FromKind4(schema_, references_, value15);
      }
    }
    const state = {
      language: "javascript",
      functions: new Map,
      variables: new Map,
      instances: new Map
    };
    function CreateExpression(schema3, references, value15, useHoisting = true) {
      return `(${[...Visit17(schema3, references, value15, useHoisting)].join(" && ")})`;
    }
    function CreateFunctionName($id) {
      return `check_${Identifier2.Encode($id)}`;
    }
    function CreateVariable(expression) {
      const variableName = `local_${state.variables.size}`;
      state.variables.set(variableName, `const ${variableName} = ${expression}`);
      return variableName;
    }
    function CreateFunction(name, schema3, references, value15, useHoisting = true) {
      const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const expression = [...Visit17(schema3, references, value15, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
      return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
    }
    function CreateParameter(name, type74) {
      const annotation = state.language === "typescript" ? `: ${type74}` : "";
      return `${name}${annotation}`;
    }
    function CreateReturns(type74) {
      return state.language === "typescript" ? `: ${type74}` : "";
    }
    function Build(schema3, references, options) {
      const functionCode = CreateFunction("check", schema3, references, "value");
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const functions = [...state.functions.values()];
      const variables = [...state.variables.values()];
      const checkFunction = (0, index_11.IsString)(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
      return [...variables, ...functions, checkFunction].join("\n");
    }
    function Code(...args) {
      const defaults = { language: "javascript" };
      const [schema3, references, options] = args.length === 2 && (0, index_11.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, index_11.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
      state.language = options.language;
      state.variables.clear();
      state.functions.clear();
      state.instances.clear();
      if (!(0, type_1.IsSchema)(schema3))
        throw new TypeCompilerTypeGuardError2(schema3);
      for (const schema4 of references)
        if (!(0, type_1.IsSchema)(schema4))
          throw new TypeCompilerTypeGuardError2(schema4);
      return Build(schema3, references, options);
    }
    TypeCompiler3.Code = Code;
    function Compile(schema3, references = []) {
      const generatedCode = Code(schema3, references, { language: "javascript" });
      const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
      const instances = new Map(state.instances);
      function typeRegistryFunction(kind, instance, value15) {
        if (!index_8.TypeRegistry.Has(kind) || !instances.has(instance))
          return false;
        const checkFunc = index_8.TypeRegistry.Get(kind);
        const schema4 = instances.get(instance);
        return checkFunc(schema4, value15);
      }
      function formatRegistryFunction(format, value15) {
        if (!index_8.FormatRegistry.Has(format))
          return false;
        const checkFunc = index_8.FormatRegistry.Get(format);
        return checkFunc(value15);
      }
      function hashFunction(value15) {
        return (0, index_6.Hash)(value15);
      }
      const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
      return new TypeCheck2(schema3, references, checkFunction, generatedCode);
    }
    TypeCompiler3.Compile = Compile;
  })(TypeCompiler2 || (exports.TypeCompiler = TypeCompiler2 = {}));
});

// node_modules/@sinclair/typebox/build/require/compiler/index.js
var require_compiler2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_compiler(), exports);
});

// node_modules/elysia/dist/cjs/index.js
var require_cjs = __commonJS((exports, module) => {
  var removeTrailingEquals2 = function(digest) {
    let trimmedDigest = digest;
    while (trimmedDigest.endsWith("=")) {
      trimmedDigest = trimmedDigest.slice(0, -1);
    }
    return trimmedDigest;
  };
  var isLeapYear2 = function(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var date6 = function(str) {
    const matches = DATE2.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear2(year) ? 29 : DAYS2[month]);
  };
  var getTime2 = function(strictTimeZone) {
    return function time(str) {
      const matches = TIME2.exec(str);
      if (!matches)
        return false;
      const hr = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tz = matches[4];
      const tzSign = matches[5] === "-" ? -1 : 1;
      const tzH = +(matches[6] || 0);
      const tzM = +(matches[7] || 0);
      if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
        return false;
      if (hr <= 23 && min <= 59 && sec < 60)
        return true;
      const utcMin = min - tzM * tzSign;
      const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
      return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
    };
  };
  var getDateTime2 = function(strictTimeZone) {
    const time = getTime2(strictTimeZone);
    return function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR2);
      return dateTime.length === 2 && date6(dateTime[0]) && time(dateTime[1]);
    };
  };
  var uri2 = function(str) {
    return NOT_URI_FRAGMENT2.test(str) && URI2.test(str);
  };
  var byte2 = function(str) {
    BYTE2.lastIndex = 0;
    return BYTE2.test(str);
  };
  var validateInt322 = function(value15) {
    return Number.isInteger(value15) && value15 <= MAX_INT322 && value15 >= MIN_INT322;
  };
  var validateInt642 = function(value15) {
    return Number.isInteger(value15);
  };
  var validateNumber2 = function() {
    return true;
  };
  var regex2 = function(str) {
    if (Z_ANCHOR2.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e22) {
      return false;
    }
  };
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Cookie: () => Cookie2,
    ELYSIA_RESPONSE: () => ELYSIA_RESPONSE2,
    ERROR_CODE: () => ERROR_CODE2,
    Elysia: () => Elysia2,
    InternalServerError: () => InternalServerError2,
    InvalidCookieSignature: () => InvalidCookieSignature2,
    InvertedStatusMap: () => InvertedStatusMap2,
    NotFoundError: () => NotFoundError2,
    ParseError: () => ParseError2,
    StatusMap: () => StatusMap2,
    ValidationError: () => ValidationError2,
    default: () => Elysia2,
    error: () => error23,
    getResponseSchemaValidator: () => getResponseSchemaValidator2,
    getSchemaValidator: () => getSchemaValidator2,
    mapCompactResponse: () => mapCompactResponse2,
    mapEarlyResponse: () => mapEarlyResponse2,
    mapResponse: () => mapResponse2,
    mergeHook: () => mergeHook2,
    mergeObjectArray: () => mergeObjectArray2,
    redirect: () => redirect2,
    t: () => t22
  });
  module.exports = __toCommonJS(src_exports);
  var e2 = (e22, t32) => ({ part: e22, store: null, inert: t32 !== undefined ? new Map(t32.map((e3) => [e3.part.charCodeAt(0), e3])) : null, params: null, wildcardStore: null });
  var t3 = (e22, t32) => ({ ...e22, part: t32 });
  var r2 = (e22) => ({ paramName: e22, store: null, inert: null });
  var Memoirist2 = class _Memoirist2 {
    root = {};
    history = [];
    static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
    add(a22, l, i) {
      let s;
      if (typeof l != "string")
        throw TypeError("Route path must be a string");
      l === "" ? l = "/" : l[0] !== "/" && (l = `/${l}`), this.history.push([a22, l, i]);
      let n = l[l.length - 1] === "*";
      n && (l = l.slice(0, -1));
      let o = l.split(_Memoirist2.regex.static), u = l.match(_Memoirist2.regex.params) || [];
      o[o.length - 1] === "" && o.pop(), s = this.root[a22] ? this.root[a22] : this.root[a22] = e2("/");
      let p = 0;
      for (let a3 = 0;a3 < o.length; ++a3) {
        let i2 = o[a3];
        if (a3 > 0) {
          let t32 = u[p++].slice(1);
          if (s.params === null)
            s.params = r2(t32);
          else if (s.params.paramName !== t32)
            throw Error(`Cannot create route "${l}" with parameter "${t32}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
          let a4 = s.params;
          if (a4.inert === null) {
            s = a4.inert = e2(i2);
            continue;
          }
          s = a4.inert;
        }
        for (let r22 = 0;; ) {
          if (r22 === i2.length) {
            if (r22 < s.part.length) {
              let a4 = t3(s, s.part.slice(r22));
              Object.assign(s, e2(i2, [a4]));
            }
            break;
          }
          if (r22 === s.part.length) {
            if (s.inert === null)
              s.inert = new Map;
            else if (s.inert.has(i2.charCodeAt(r22))) {
              s = s.inert.get(i2.charCodeAt(r22)), i2 = i2.slice(r22), r22 = 0;
              continue;
            }
            let t32 = e2(i2.slice(r22));
            s.inert.set(i2.charCodeAt(r22), t32), s = t32;
            break;
          }
          if (i2[r22] !== s.part[r22]) {
            let a4 = t3(s, s.part.slice(r22)), l2 = e2(i2.slice(r22));
            Object.assign(s, e2(s.part.slice(0, r22), [a4, l2])), s = l2;
            break;
          }
          ++r22;
        }
      }
      if (p < u.length) {
        let e22 = u[p], t32 = e22.slice(1);
        if (s.params === null)
          s.params = r2(t32);
        else if (s.params.paramName !== t32)
          throw Error(`Cannot create route "${l}" with parameter "${t32}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
        return s.params.store === null && (s.params.store = i), s.params.store;
      }
      return n ? (s.wildcardStore === null && (s.wildcardStore = i), s.wildcardStore) : (s.store === null && (s.store = i), s.store);
    }
    find(e22, t32) {
      let r22 = this.root[e22];
      return r22 ? a2(t32, t32.length, r22, 0) : null;
    }
  };
  var a2 = (e22, t32, r22, l) => {
    let i = r22?.part, s = l + i.length;
    if (i.length > 1) {
      if (s > t32)
        return null;
      if (i.length < 15) {
        for (let t4 = 1, r3 = l + 1;t4 < i.length; ++t4, ++r3)
          if (i.charCodeAt(t4) !== e22.charCodeAt(r3))
            return null;
      } else if (e22.substring(l, s) !== i)
        return null;
    }
    if (s === t32)
      return r22.store !== null ? { store: r22.store, params: {} } : r22.wildcardStore !== null ? { store: r22.wildcardStore, params: { "*": "" } } : null;
    if (r22.inert !== null) {
      let l2 = r22.inert.get(e22.charCodeAt(s));
      if (l2 !== undefined) {
        let r3 = a2(e22, t32, l2, s);
        if (r3 !== null)
          return r3;
      }
    }
    if (r22.params !== null) {
      let l2 = r22.params, i2 = e22.indexOf("/", s);
      if (i2 !== s) {
        if (i2 === -1 || i2 >= t32) {
          if (l2.store !== null) {
            let r3 = {};
            return r3[l2.paramName] = e22.substring(s, t32), { store: l2.store, params: r3 };
          }
        } else if (l2.inert !== null) {
          let r3 = a2(e22, t32, l2.inert, i2);
          if (r3 !== null)
            return r3.params[l2.paramName] = e22.substring(s, i2), r3;
        }
      }
    }
    return r22.wildcardStore !== null ? { store: r22.wildcardStore, params: { "*": e22.substring(s, t32) } } : null;
  };
  var import_eventemitter32 = __toESM2(require_eventemitter3());
  var resolver2 = () => {
    let resolve;
    const promise5 = new Promise((r22) => {
      resolve = r22;
    });
    return [promise5, resolve];
  };
  var createSignal2 = () => {
    const [start, resolveStart] = resolver2();
    const [end, resolveEnd] = resolver2();
    const children = [];
    const resolvers = [];
    return {
      signal: start,
      consume: (trace) => {
        switch (trace.type) {
          case "begin":
            if (trace.unit && children.length === 0)
              for (let i = 0;i < trace.unit; i++) {
                const [start2, resolveStart2] = resolver2();
                const [end2, resolveEnd2] = resolver2();
                children.push(start2);
                resolvers.push([
                  (trace2) => {
                    resolveStart2({
                      children: [],
                      end: end2,
                      name: trace2.name ?? "",
                      skip: false,
                      time: trace2.time
                    });
                  },
                  (time) => {
                    resolveEnd2(time);
                  }
                ]);
              }
            resolveStart({
              children,
              end,
              name: trace.name ?? "",
              skip: false,
              time: trace.time
            });
            break;
          case "end":
            resolveEnd(trace.time);
            break;
        }
      },
      consumeChild(trace) {
        switch (trace.type) {
          case "begin":
            if (!resolvers[0])
              return;
            const [resolveStart2] = resolvers[0];
            resolveStart2({
              children: [],
              end,
              name: trace.name ?? "",
              skip: false,
              time: trace.time
            });
            break;
          case "end":
            const child = resolvers.shift();
            if (!child)
              return;
            child[1](trace.time);
        }
      },
      resolve() {
        resolveStart({
          children: [],
          end: new Promise((resolve) => resolve(0)),
          name: "",
          skip: true,
          time: 0
        });
        for (const [resolveStart2, resolveEnd2] of resolvers) {
          resolveStart2({
            children: [],
            end: new Promise((resolve) => resolve(0)),
            name: "",
            skip: true,
            time: 0
          });
          resolveEnd2(0);
        }
        resolveEnd(0);
      }
    };
  };
  var createTraceListener2 = (getReporter, totalListener, handler) => {
    if (typeof handler === "object")
      handler = handler.fn;
    return async function trace(trace) {
      if (trace.event !== "request" || trace.type !== "begin")
        return;
      const id = trace.id;
      const reporter = getReporter();
      const request = createSignal2();
      const parse22 = createSignal2();
      const transform7 = createSignal2();
      const beforeHandle = createSignal2();
      const handle = createSignal2();
      const afterHandle = createSignal2();
      const error24 = createSignal2();
      const response = createSignal2();
      request.consume(trace);
      const reducer = (event) => {
        if (event.id === id)
          switch (event.event) {
            case "request":
              request.consume(event);
              break;
            case "request.unit":
              request.consumeChild(event);
              break;
            case "parse":
              parse22.consume(event);
              break;
            case "parse.unit":
              parse22.consumeChild(event);
              break;
            case "transform":
              transform7.consume(event);
              break;
            case "transform.unit":
              transform7.consumeChild(event);
              break;
            case "beforeHandle":
              beforeHandle.consume(event);
              break;
            case "beforeHandle.unit":
              beforeHandle.consumeChild(event);
              break;
            case "handle":
              handle.consume(event);
              break;
            case "afterHandle":
              afterHandle.consume(event);
              break;
            case "afterHandle.unit":
              afterHandle.consumeChild(event);
              break;
            case "error":
              error24.consume(event);
              break;
            case "error.unit":
              error24.consumeChild(event);
              break;
            case "response":
              if (event.type === "begin") {
                request.resolve();
                parse22.resolve();
                transform7.resolve();
                beforeHandle.resolve();
                handle.resolve();
                afterHandle.resolve();
                error24.resolve();
              } else
                reporter.off("event", reducer);
              response.consume(event);
              break;
            case "response.unit":
              response.consumeChild(event);
              break;
            case "exit":
              request.resolve();
              parse22.resolve();
              transform7.resolve();
              beforeHandle.resolve();
              handle.resolve();
              afterHandle.resolve();
              error24.resolve();
              break;
          }
      };
      reporter.on("event", reducer);
      await handler({
        id,
        context: trace.ctx,
        set: trace.ctx?.set,
        store: trace.ctx?.store,
        time: trace.time,
        request: request.signal,
        parse: parse22.signal,
        transform: transform7.signal,
        beforeHandle: beforeHandle.signal,
        handle: handle.signal,
        afterHandle: afterHandle.signal,
        error: error24.signal,
        response: response.signal
      });
      reporter.emit(`res${id}.${totalListener}`, undefined);
    };
  };
  var separateFunction2 = (code) => {
    if (code.startsWith("async"))
      code = code.slice(6);
    let index = -1;
    if (code.charCodeAt(0) === 40) {
      index = code.indexOf(") => {\n");
      if (index !== -1)
        return [
          code.slice(1, index),
          code.slice(index + 5),
          { isArrowReturn: false }
        ];
      index = code.indexOf(") => ");
      if (index !== -1)
        return [
          code.slice(1, index),
          code.slice(index + 5),
          { isArrowReturn: true }
        ];
    }
    if (code.startsWith("function")) {
      index = code.indexOf("(");
      const end = code.indexOf(")");
      return [
        code.slice(index + 1, end),
        code.slice(end + 2),
        {
          isArrowReturn: false
        }
      ];
    }
    const start = code.indexOf("(");
    if (start !== -1) {
      const [parameter, body] = code.split("\n", 2);
      const end = parameter.lastIndexOf(")") + 1;
      return [
        parameter.slice(start, end),
        "{" + body,
        {
          isArrowReturn: false
        }
      ];
    }
    const x = code.split("\n", 2);
    return [x[0], x[1], { isArrowReturn: false }];
  };
  var bracketPairRange2 = (parameter) => {
    const start = parameter.indexOf("{");
    if (start === -1)
      return [-1, 0];
    let end = start + 1;
    let deep = 1;
    for (;end < parameter.length; end++) {
      const char = parameter.charCodeAt(end);
      if (char === 123)
        deep++;
      else if (char === 125)
        deep--;
      if (deep === 0)
        break;
    }
    if (deep !== 0)
      return [0, parameter.length];
    return [start, end + 1];
  };
  var bracketPairRangeReverse2 = (parameter) => {
    const end = parameter.lastIndexOf("}");
    if (end === -1)
      return [-1, 0];
    let start = end - 1;
    let deep = 1;
    for (;start >= 0; start--) {
      const char = parameter.charCodeAt(start);
      if (char === 125)
        deep++;
      else if (char === 123)
        deep--;
      if (deep === 0)
        break;
    }
    if (deep !== 0)
      return [-1, 0];
    return [start, end + 1];
  };
  var retrieveRootParamters2 = (parameter) => {
    if (parameter.charCodeAt(0) === 40)
      parameter = parameter.slice(1, -1);
    if (parameter.charCodeAt(0) === 123)
      parameter = parameter.slice(2, -2);
    while (true) {
      const [start, end] = bracketPairRange2(parameter);
      if (start === -1)
        break;
      parameter = parameter.slice(0, start - 2) + parameter.slice(end + 1);
    }
    return parameter.replace(/:/g, "").trim();
  };
  var findParameterReference2 = (parameter, inference) => {
    const root = retrieveRootParamters2(parameter);
    if (!inference.query && root.includes("query"))
      inference.query = true;
    if (!inference.headers && root.includes("headers"))
      inference.headers = true;
    if (!inference.body && root.includes("body"))
      inference.body = true;
    if (!inference.cookie && root.includes("cookie"))
      inference.cookie = true;
    if (!inference.set && root.includes("set"))
      inference.set = true;
    return root;
  };
  var findTraceParameterReference2 = (parameter, inference) => {
    const root = retrieveRootParamters2(parameter);
    if (!inference.request && root.includes("request"))
      inference.request = true;
    if (!inference.parse && root.includes("parse"))
      inference.parse = true;
    if (!inference.transform && root.includes("transform"))
      inference.transform = true;
    if (!inference.handle && root.includes("handle"))
      inference.handle = true;
    if (!inference.beforeHandle && root.includes("beforeHandle"))
      inference.beforeHandle = true;
    if (!inference.afterHandle && root.includes("afterHandle"))
      inference.afterHandle = true;
    if (!inference.error && root.includes("error"))
      inference.error = true;
    if (!inference.context && root.includes("context"))
      inference.context = true;
    if (!inference.store && root.includes("store"))
      inference.store = true;
    if (!inference.set && root.includes("set"))
      inference.set = true;
    return root;
  };
  var findEndIndex2 = (type74, content, index) => {
    const newLineIndex = content.indexOf(type74 + "\n", index);
    const newTabIndex = content.indexOf(type74 + "	", index);
    const commaIndex = content.indexOf(type74 + ",", index);
    const semicolonIndex = content.indexOf(type74 + ";", index);
    const emptyIndex = content.indexOf(type74 + " ", index);
    return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a22, b) => a22 - b)[0] || -1;
  };
  var findAlias2 = (type74, body, depth = 0) => {
    if (depth > 5)
      return [];
    const aliases = [];
    let content = body;
    while (true) {
      let index = findEndIndex2(" = " + type74, content);
      if (index === -1) {
        const lastIndex = content.indexOf(" = " + type74);
        if (lastIndex + 3 + type74.length !== content.length)
          break;
        index = lastIndex;
      }
      const part = content.slice(0, index);
      let variable = part.slice(part.lastIndexOf(" ") + 1);
      if (variable === "}") {
        const [start, end] = bracketPairRangeReverse2(part);
        aliases.push(content.slice(start, end));
        content = content.slice(index + 3 + type74.length);
        continue;
      }
      while (variable.charCodeAt(0) === 44)
        variable = variable.slice(1);
      while (variable.charCodeAt(0) === 9)
        variable = variable.slice(1);
      aliases.push(variable);
      content = content.slice(index + 3 + type74.length);
    }
    for (const alias of aliases) {
      if (alias.charCodeAt(0) === 123)
        continue;
      const deepAlias = findAlias2(alias, body);
      if (deepAlias.length > 0)
        aliases.push(...deepAlias);
    }
    return aliases;
  };
  var extractMainParameter2 = (parameter) => {
    if (!parameter)
      return;
    const hasComma = parameter.includes(",");
    if (!hasComma) {
      if (parameter.includes("..."))
        return parameter.slice(parameter.indexOf("...") + 3);
      return parameter;
    }
    const spreadIndex = parameter.indexOf("...");
    if (spreadIndex === -1)
      return;
    return parameter.slice(spreadIndex + 3).trimEnd();
  };
  var inferBodyReference2 = (code, aliases, inference) => {
    const access = (type74, alias) => code.includes(alias + "." + type74) || code.includes(alias + '["' + type74 + '"]') || code.includes(alias + "['" + type74 + "']");
    for (let alias of aliases) {
      if (!alias)
        continue;
      if (alias.charCodeAt(0) === 123) {
        alias = retrieveRootParamters2(alias);
        if (!inference.query && alias.includes("query"))
          inference.query = true;
        if (!inference.headers && alias.includes("headers"))
          inference.headers = true;
        if (!inference.body && alias.includes("body"))
          inference.body = true;
        if (!inference.cookie && alias.includes("cookie"))
          inference.cookie = true;
        if (!inference.set && alias.includes("set"))
          inference.set = true;
        continue;
      }
      if (code.includes("(" + alias + ")")) {
        inference.query = true;
        inference.headers = true;
        inference.body = true;
        inference.cookie = true;
        inference.set = true;
        inference.queries = [];
        inference.unknownQueries = true;
        break;
      }
      if (!inference.query && access("query", alias))
        inference.query = true;
      if (code.includes("return " + alias) || code.includes("return " + alias + ".query")) {
        inference.query = true;
        inference.unknownQueries = true;
        inference.queries = [];
      }
      if (!inference.unknownQueries && inference.query) {
        let keyword = alias + ".";
        if (code.includes(keyword + "query"))
          keyword = alias + ".query";
        while (true) {
          let start = code.indexOf(keyword);
          if (start === -1 && code.indexOf(alias + "[") !== -1) {
            inference.queries = [];
            inference.unknownQueries = true;
            break;
          }
          if (start !== -1) {
            let end = findEndIndex2("", code, start + keyword.length + 1);
            if (end === -1)
              end = undefined;
            const index = start + alias.length + 1;
            code = code.slice(start + alias.length + 1);
            let query = code.slice(0, end ? end - index : end).trimEnd();
            while (start !== -1) {
              start = query.indexOf(".");
              if (start !== -1)
                query = query.slice(start + 1);
            }
            if (query.charCodeAt(query.length - 1) === 59)
              query = query.slice(0, -1);
            if (query.charCodeAt(query.length - 1) === 44)
              query = query.slice(0, -1);
            if (query.charCodeAt(query.length - 1) === 93)
              query = query.slice(0, -1);
            if (query.charCodeAt(query.length - 1) === 41)
              query = query.slice(0, -1);
            if (query && !inference.queries.includes(query)) {
              inference.queries.push(query);
              continue;
            }
          }
          break;
        }
      }
      if (!inference.headers && access("headers", alias))
        inference.headers = true;
      if (!inference.body && access("body", alias))
        inference.body = true;
      if (!inference.cookie && access("cookie", alias))
        inference.cookie = true;
      if (!inference.set && access("set", alias))
        inference.set = true;
      if (inference.query && inference.headers && inference.body && inference.cookie && inference.set)
        break;
    }
    return aliases;
  };
  var removeDefaultParameter2 = (parameter) => {
    while (true) {
      const index = parameter.indexOf("=");
      if (index === -1)
        break;
      const commaIndex = parameter.indexOf(",", index);
      const bracketIndex = parameter.indexOf("}", index);
      const end = [commaIndex, bracketIndex].filter((i) => i > 0).sort((a22, b) => a22 - b)[0] || -1;
      if (end === -1) {
        parameter = parameter.slice(0, index);
        break;
      }
      parameter = parameter.slice(0, index) + parameter.slice(end);
    }
    return parameter.split(",").map((i) => i.trim()).join(", ");
  };
  var validateInferencedQueries2 = (queries) => {
    for (const query of queries) {
      if (query.charCodeAt(0) === 123)
        return false;
      if (query.indexOf("'") !== -1)
        return false;
      if (query.indexOf('"') !== -1)
        return false;
      if (query.indexOf("\n") !== -1)
        return false;
      if (query.indexOf("	") !== -1)
        return false;
    }
    return true;
  };
  var inferTraceBodyReference2 = (code, aliases, inference) => {
    const access = (type74, alias) => code.includes(type74 + "." + alias) || code.includes(type74 + '["' + alias + '"]') || code.includes(type74 + "['" + alias + "']");
    for (let alias of aliases) {
      if (alias.charCodeAt(0) === 123) {
        alias = retrieveRootParamters2(alias);
        if (!inference.request && alias.includes("request"))
          inference.request = true;
        if (!inference.parse && alias.includes("parse"))
          inference.parse = true;
        if (!inference.transform && alias.includes("transform"))
          inference.transform = true;
        if (!inference.handle && alias.includes("handle"))
          inference.handle = true;
        if (!inference.beforeHandle && alias.includes("beforeHandle"))
          inference.beforeHandle = true;
        if (!inference.afterHandle && alias.includes("afterHandle"))
          inference.afterHandle = true;
        if (!inference.error && alias.includes("error"))
          inference.error = true;
        if (!inference.context && alias.includes("context"))
          inference.context = true;
        if (!inference.store && alias.includes("store"))
          inference.store = true;
        if (!inference.set && alias.includes("set"))
          inference.set = true;
        continue;
      }
      if (code.includes("(" + alias + ")")) {
        inference.request = true;
        inference.parse = true;
        inference.transform = true;
        inference.handle = true;
        inference.beforeHandle = true;
        inference.afterHandle = true;
        inference.error = true;
        inference.context = true;
        inference.store = true;
        inference.set = true;
        break;
      }
      if (!inference.request && access("request", alias))
        inference.request = true;
      if (!inference.parse && access("parse", alias))
        inference.parse = true;
      if (!inference.transform && access("transform", alias))
        inference.transform = true;
      if (!inference.handle && access("handle", alias))
        inference.handle = true;
      if (!inference.beforeHandle && access("beforeHandle", alias))
        inference.beforeHandle = true;
      if (!inference.afterHandle && access("afterHandle", alias))
        inference.afterHandle = true;
      if (!inference.error && access("error", alias))
        inference.error = true;
      if (!inference.context && access("context", alias))
        inference.context = true;
      if (!inference.store && access("store", alias))
        inference.store = true;
      if (!inference.set && access("set", alias))
        inference.set = true;
      if (inference.request && inference.parse && inference.transform && inference.handle && inference.beforeHandle && inference.afterHandle && inference.error && inference.context && inference.store && inference.set)
        break;
    }
    return aliases;
  };
  var sucrose2 = (lifeCycle, inference = {
    queries: [],
    query: false,
    headers: false,
    body: false,
    cookie: false,
    set: false,
    unknownQueries: false
  }) => {
    const events = [];
    if (lifeCycle.handler && typeof lifeCycle.handler === "function")
      events.push(lifeCycle.handler);
    if (lifeCycle.beforeHandle?.length)
      events.push(...lifeCycle.beforeHandle);
    if (lifeCycle.parse?.length)
      events.push(...lifeCycle.parse);
    if (lifeCycle.error?.length)
      events.push(...lifeCycle.error);
    if (lifeCycle.transform?.length)
      events.push(...lifeCycle.transform);
    if (lifeCycle.afterHandle?.length)
      events.push(...lifeCycle.afterHandle);
    if (lifeCycle.mapResponse?.length)
      events.push(...lifeCycle.mapResponse);
    if (lifeCycle.request?.length)
      events.push(...lifeCycle.request);
    if (lifeCycle.onResponse?.length)
      events.push(...lifeCycle.onResponse);
    for (const e22 of events) {
      if (!e22)
        continue;
      const event = "fn" in e22 ? e22.fn : e22;
      const [parameter, body, { isArrowReturn }] = separateFunction2(event.toString());
      const rootParameters = findParameterReference2(parameter, inference);
      const mainParameter = extractMainParameter2(rootParameters);
      if (isArrowReturn && (body === "query" || rootParameters && body.startsWith(rootParameters + ".query"))) {
        inference.query = true;
        inference.unknownQueries = true;
        inference.queries = [];
      }
      if (mainParameter) {
        const aliases = findAlias2(mainParameter, body);
        aliases.splice(0, -1, mainParameter);
        inferBodyReference2(body, aliases, inference);
      }
      const context = rootParameters || mainParameter;
      if (context && body.includes("return " + context + ".query")) {
        inference.query = true;
        inference.unknownQueries = true;
        inference.queries = [];
      }
      if (inference.query) {
        inferBodyReference2(body, ["query"], inference);
        const queryIndex = parameter.indexOf("query: {");
        if (queryIndex !== -1) {
          const part = parameter.slice(queryIndex + 7);
          const [start, end] = bracketPairRange2(part);
          const queryBracket = removeDefaultParameter2(part.slice(start, end));
          for (let query of queryBracket.slice(1, -1).split(",")) {
            const index = query.indexOf(":");
            if (index !== -1)
              query = query.slice(0, index);
            query = query.trim();
            if (query && !inference.queries.includes(query))
              inference.queries.push(query.trim());
          }
        }
      }
      if (inference.query && inference.headers && inference.body && inference.cookie && inference.set)
        break;
    }
    if (!validateInferencedQueries2(inference.queries)) {
      inference.unknownQueries = true;
      inference.queries = [];
    }
    return inference;
  };
  var sucroseTrace2 = (traces, inference = {
    request: false,
    parse: false,
    transform: false,
    handle: false,
    beforeHandle: false,
    afterHandle: false,
    error: false,
    context: false,
    store: false,
    set: false
  }) => {
    for (const handler of traces) {
      const [parameter, body] = separateFunction2(handler.toString());
      const rootParameters = findTraceParameterReference2(parameter, inference);
      const mainParameter = extractMainParameter2(rootParameters);
      if (mainParameter) {
        const aliases = findAlias2(mainParameter, body);
        aliases.splice(0, -1, mainParameter);
        inferTraceBodyReference2(body, aliases, inference);
        continue;
      }
      if (inference.request && inference.parse && inference.transform && inference.handle && inference.beforeHandle && inference.afterHandle && inference.error && inference.context && inference.store && inference.set)
        break;
    }
    return inference;
  };
  var import_value2 = require_value5();
  var import_typebox = require_require();
  var import_value3 = require_value5();
  var import_compiler = require_compiler2();
  var import_cookie22 = require_cookie();
  var import_cookie3 = require_cookie();
  var import_fast_decode_uri_component3 = __toESM2(require_fast_decode_uri_component());
  var Cookie2 = class {
    constructor(name, jar, initial = {}) {
      this.name = name;
      this.jar = jar;
      this.initial = initial;
    }
    get cookie() {
      if (!(this.name in this.jar))
        return this.initial;
      return this.jar[this.name];
    }
    set cookie(jar) {
      if (!(this.name in this.jar))
        this.jar[this.name] = this.initial;
      this.jar[this.name] = jar;
    }
    get value() {
      return this.cookie.value;
    }
    set value(value15) {
      if (!(this.name in this.jar))
        this.jar[this.name] = this.initial;
      this.jar[this.name].value = value15;
    }
    get expires() {
      return this.cookie.expires;
    }
    set expires(expires) {
      this.cookie.expires = expires;
    }
    get maxAge() {
      return this.cookie.maxAge;
    }
    set maxAge(maxAge) {
      this.cookie.maxAge = maxAge;
    }
    get domain() {
      return this.cookie.domain;
    }
    set domain(domain) {
      this.cookie.domain = domain;
    }
    get path() {
      return this.cookie.path;
    }
    set path(path) {
      this.cookie.path = path;
    }
    get secure() {
      return this.cookie.secure;
    }
    set secure(secure) {
      this.cookie.secure = secure;
    }
    get httpOnly() {
      return this.cookie.httpOnly;
    }
    set httpOnly(httpOnly) {
      this.cookie.httpOnly = httpOnly;
    }
    get sameSite() {
      return this.cookie.sameSite;
    }
    set sameSite(sameSite) {
      this.cookie.sameSite = sameSite;
    }
    get priority() {
      return this.cookie.priority;
    }
    set priority(priority) {
      this.cookie.priority = priority;
    }
    get partitioned() {
      return this.cookie.partitioned;
    }
    set partitioned(partitioned) {
      this.cookie.partitioned = partitioned;
    }
    get secrets() {
      return this.cookie.secrets;
    }
    set secrets(secrets) {
      this.cookie.secrets = secrets;
    }
    update(config) {
      this.cookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config);
      return this;
    }
    set(config) {
      this.cookie = Object.assign({
        ...this.initial,
        value: this.value
      }, typeof config === "function" ? config(this.cookie) : config);
      return this;
    }
    remove() {
      if (this.value === undefined)
        return;
      this.set({
        expires: new Date(0),
        maxAge: 0,
        value: ""
      });
      return this;
    }
    toString() {
      return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
    }
  };
  var createCookieJar2 = (set2, store, initial) => {
    if (!set2.cookie)
      set2.cookie = {};
    return new Proxy(store, {
      get(_, key) {
        if (key in store)
          return new Cookie2(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
        return new Cookie2(key, set2.cookie, Object.assign({}, initial));
      }
    });
  };
  var parseCookie2 = async (set2, cookieString, {
    secrets,
    sign,
    ...initial
  } = {}) => {
    if (!cookieString)
      return createCookieJar2(set2, {}, initial);
    const isStringKey = typeof secrets === "string";
    if (sign && sign !== true && !Array.isArray(sign))
      sign = [sign];
    const jar = {};
    const cookies = (0, import_cookie3.parse)(cookieString);
    for (const [name, v] of Object.entries(cookies)) {
      let value15 = (0, import_fast_decode_uri_component3.default)(v);
      if (sign === true || sign?.includes(name)) {
        if (!secrets)
          throw new Error("No secret is provided to cookie plugin");
        if (isStringKey) {
          const temp = await unsignCookie2(value15, secrets);
          if (temp === false)
            throw new InvalidCookieSignature2(name);
          value15 = temp;
        } else {
          let decoded = true;
          for (let i = 0;i < secrets.length; i++) {
            const temp = await unsignCookie2(value15, secrets[i]);
            if (temp !== false) {
              decoded = true;
              value15 = temp;
              break;
            }
          }
          if (!decoded)
            throw new InvalidCookieSignature2(name);
        }
      }
      const start = value15.charCodeAt(0);
      if (start === 123 || start === 91)
        try {
          jar[name] = {
            value: JSON.parse(value15)
          };
          continue;
        } catch {
        }
      if (isNumericString2(value15)) {
        jar[name] = {
          value: parseInt(value15)
        };
        continue;
      }
      if (value15 === "true") {
        jar[name] = {
          value: true
        };
        continue;
      }
      if (value15 === "false") {
        jar[name] = {
          value: false
        };
        continue;
      }
      jar[name] = {
        value: value15
      };
    }
    return createCookieJar2(set2, jar, initial);
  };
  var hasHeaderShorthand2 = "toJSON" in new Headers;
  var isNotEmpty2 = (obj) => {
    if (!obj)
      return false;
    for (const x in obj)
      return true;
    return false;
  };
  var handleFile2 = (response, set2) => {
    const size = response.size;
    if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
      if (set2) {
        if (set2.headers instanceof Headers) {
          if (hasHeaderShorthand2)
            set2.headers = set2.headers.toJSON();
          else
            for (const [key, value15] of set2.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value15;
        }
        return new Response(response, {
          status: set2.status,
          headers: Object.assign({
            "accept-ranges": "bytes",
            "content-range": `bytes 0-${size - 1}/${size}`
          }, set2.headers)
        });
      }
      return new Response(response, {
        headers: {
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`
        }
      });
    }
    return new Response(response);
  };
  var parseSetCookies2 = (headers, setCookie) => {
    if (!headers)
      return headers;
    headers.delete("Set-Cookie");
    for (let i = 0;i < setCookie.length; i++) {
      const index = setCookie[i].indexOf("=");
      headers.append("Set-Cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
    }
    return headers;
  };
  var serializeCookie2 = (cookies) => {
    if (!cookies || !isNotEmpty2(cookies))
      return;
    const set2 = [];
    for (const [key, property] of Object.entries(cookies)) {
      if (!key || !property)
        continue;
      const value15 = property.value;
      if (value15 === undefined || value15 === null)
        continue;
      set2.push((0, import_cookie22.serialize)(key, typeof value15 === "object" ? JSON.stringify(value15) : value15 + "", property));
    }
    if (set2.length === 0)
      return;
    if (set2.length === 1)
      return set2[0];
    return set2;
  };
  var mapResponse2 = (response, set2, request) => {
    if (response?.$passthrough)
      response = response?.[response.$passthrough];
    if (response?.[ELYSIA_RESPONSE2]) {
      set2.status = response[ELYSIA_RESPONSE2];
      response = response.response;
    }
    if (isNotEmpty2(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
      if (typeof set2.status === "string")
        set2.status = StatusMap2[set2.status];
      if (set2.redirect) {
        set2.headers.Location = set2.redirect;
        if (!set2.status || set2.status < 300 || set2.status >= 400)
          set2.status = 302;
      }
      if (set2.cookie && isNotEmpty2(set2.cookie))
        set2.headers["Set-Cookie"] = serializeCookie2(set2.cookie);
      if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"])) {
        set2.headers = parseSetCookies2(new Headers(set2.headers), set2.headers["Set-Cookie"]);
      }
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response, set2);
        case "Blob":
          return handleFile2(response, set2);
        case "Object":
        case "Array":
          return Response.json(response, set2);
        case "ReadableStream":
          if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
            set2.headers["content-type"] = "text/event-stream; charset=utf-8";
          request?.signal.addEventListener("abort", {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          }, {
            once: true
          });
          return new Response(response, set2);
        case undefined:
          if (!response)
            return new Response("", set2);
          return Response.json(response, set2);
        case "Response":
          let isCookieSet = false;
          if (set2.headers instanceof Headers)
            for (const key of set2.headers.keys()) {
              if (key === "set-cookie") {
                if (isCookieSet)
                  continue;
                isCookieSet = true;
                for (const cookie of set2.headers.getSetCookie()) {
                  response.headers.append("set-cookie", cookie);
                }
              } else
                response.headers.append(key, set2.headers?.get(key) ?? "");
            }
          else
            for (const key in set2.headers)
              response.headers.append(key, set2.headers[key]);
          if (response.status !== set2.status)
            set2.status = response.status;
          return response;
        case "Error":
          return errorToResponse2(response, set2);
        case "Promise":
          return response.then((x) => mapResponse2(x, set2));
        case "Function":
          return mapResponse2(response(), set2);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set2);
        case "Cookie":
          if (response instanceof Cookie2)
            return new Response(response.value, set2);
          return new Response(response?.toString(), set2);
        default:
          if (response instanceof Response) {
            let isCookieSet2 = false;
            if (set2.headers instanceof Headers)
              for (const key of set2.headers.keys()) {
                if (key === "set-cookie") {
                  if (isCookieSet2)
                    continue;
                  isCookieSet2 = true;
                  for (const cookie of set2.headers.getSetCookie()) {
                    response.headers.append("set-cookie", cookie);
                  }
                } else
                  response.headers.append(key, set2.headers?.get(key) ?? "");
              }
            else
              for (const key in set2.headers)
                response.headers.append(key, set2.headers[key]);
            if (hasHeaderShorthand2)
              set2.headers = response.headers.toJSON();
            else
              for (const [key, value15] of response.headers.entries())
                if (key in set2.headers)
                  set2.headers[key] = value15;
            return response;
          }
          if (response instanceof Promise)
            return response.then((x) => mapResponse2(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91) {
              if (!set2.headers["Content-Type"])
                set2.headers["Content-Type"] = "application/json";
              return new Response(JSON.stringify(response), set2);
            }
          }
          return new Response(response, set2);
      }
    } else
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response);
        case "Blob":
          return handleFile2(response, set2);
        case "Object":
        case "Array":
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "ReadableStream":
          request?.signal.addEventListener("abort", {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          }, {
            once: true
          });
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          return response;
        case "Error":
          return errorToResponse2(response, set2);
        case "Promise":
          return response.then((x) => {
            const r22 = mapCompactResponse2(x);
            if (r22 !== undefined)
              return r22;
            return new Response("");
          });
        case "Function":
          return mapCompactResponse2(response());
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          if (response instanceof Cookie2)
            return new Response(response.value, set2);
          return new Response(response?.toString(), set2);
        default:
          if (response instanceof Response)
            return new Response(response.body, {
              headers: {
                "Content-Type": "application/json"
              }
            });
          if (response instanceof Promise)
            return response.then((x) => mapResponse2(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91) {
              if (!set2.headers["Content-Type"])
                set2.headers["Content-Type"] = "application/json";
              return new Response(JSON.stringify(response), set2);
            }
          }
          return new Response(response);
      }
  };
  var mapEarlyResponse2 = (response, set2, request) => {
    if (response === undefined || response === null)
      return;
    if (response?.$passthrough)
      response = response?.[response.$passthrough];
    if (response?.[ELYSIA_RESPONSE2]) {
      set2.status = response[ELYSIA_RESPONSE2];
      response = response.response;
    }
    if (isNotEmpty2(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
      if (typeof set2.status === "string")
        set2.status = StatusMap2[set2.status];
      if (set2.redirect) {
        set2.headers.Location = set2.redirect;
        if (!set2.status || set2.status < 300 || set2.status >= 400)
          set2.status = 302;
      }
      if (set2.cookie && isNotEmpty2(set2.cookie))
        set2.headers["Set-Cookie"] = serializeCookie2(set2.cookie);
      if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
        set2.headers = parseSetCookies2(new Headers(set2.headers), set2.headers["Set-Cookie"]);
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response, set2);
        case "Blob":
          return handleFile2(response, set2);
        case "Object":
        case "Array":
          return Response.json(response, set2);
        case "ReadableStream":
          if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
            set2.headers["content-type"] = "text/event-stream; charset=utf-8";
          request?.signal.addEventListener("abort", {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          }, {
            once: true
          });
          return new Response(response, set2);
        case undefined:
          if (!response)
            return;
          return Response.json(response, set2);
        case "Response":
          let isCookieSet = false;
          if (set2.headers instanceof Headers)
            for (const key of set2.headers.keys()) {
              if (key === "set-cookie") {
                if (isCookieSet)
                  continue;
                isCookieSet = true;
                for (const cookie of set2.headers.getSetCookie()) {
                  response.headers.append("set-cookie", cookie);
                }
              } else
                response.headers.append(key, set2.headers?.get(key) ?? "");
            }
          else
            for (const key in set2.headers)
              response.headers.append(key, set2.headers[key]);
          if (response.status !== set2.status)
            set2.status = response.status;
          return response;
        case "Promise":
          return response.then((x) => {
            const r22 = mapEarlyResponse2(x, set2);
            if (r22 !== undefined)
              return r22;
          });
        case "Error":
          return errorToResponse2(response, set2);
        case "Function":
          return mapEarlyResponse2(response(), set2);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set2);
        case "Cookie":
          if (response instanceof Cookie2)
            return new Response(response.value, set2);
          return new Response(response?.toString(), set2);
        default:
          if (response instanceof Response) {
            let isCookieSet2 = false;
            if (set2.headers instanceof Headers)
              for (const key of set2.headers.keys()) {
                if (key === "set-cookie") {
                  if (isCookieSet2)
                    continue;
                  isCookieSet2 = true;
                  for (const cookie of set2.headers.getSetCookie()) {
                    response.headers.append("set-cookie", cookie);
                  }
                } else
                  response.headers.append(key, set2.headers?.get(key) ?? "");
              }
            else
              for (const key in set2.headers)
                response.headers.append(key, set2.headers[key]);
            if (response.status !== set2.status)
              set2.status = response.status;
            return response;
          }
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse2(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91) {
              if (!set2.headers["Content-Type"])
                set2.headers["Content-Type"] = "application/json";
              return new Response(JSON.stringify(response), set2);
            }
          }
          return new Response(response, set2);
      }
    } else
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response);
        case "Blob":
          return handleFile2(response, set2);
        case "Object":
        case "Array":
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "ReadableStream":
          request?.signal.addEventListener("abort", {
            handleEvent() {
              if (!request?.signal.aborted)
                response.cancel(request);
            }
          }, {
            once: true
          });
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          return response;
        case "Promise":
          return response.then((x) => {
            const r22 = mapEarlyResponse2(x, set2);
            if (r22 !== undefined)
              return r22;
          });
        case "Error":
          return errorToResponse2(response, set2);
        case "Function":
          return mapCompactResponse2(response());
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          if (response instanceof Cookie2)
            return new Response(response.value, set2);
          return new Response(response?.toString(), set2);
        default:
          if (response instanceof Response)
            return new Response(response.body, {
              headers: {
                "Content-Type": "application/json"
              }
            });
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse2(x, set2));
          if (response instanceof Error)
            return errorToResponse2(response, set2);
          if ("charCodeAt" in response) {
            const code = response.charCodeAt(0);
            if (code === 123 || code === 91) {
              if (!set2.headers["Content-Type"])
                set2.headers["Content-Type"] = "application/json";
              return new Response(JSON.stringify(response), set2);
            }
          }
          return new Response(response);
      }
  };
  var mapCompactResponse2 = (response, request) => {
    if (response?.$passthrough)
      response = response?.[response.$passthrough];
    if (response?.[ELYSIA_RESPONSE2])
      return mapResponse2(response.response, {
        status: response[ELYSIA_RESPONSE2],
        headers: {}
      });
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile2(response);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return errorToResponse2(response);
      case "Promise":
        return response.then(mapCompactResponse2);
      case "Function":
        return mapCompactResponse2(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then(mapCompactResponse2);
        if (response instanceof Error)
          return errorToResponse2(response);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            return new Response(JSON.stringify(response), {
              headers: {
                "Content-Type": "application/json"
              }
            });
          }
        }
        return new Response(response);
    }
  };
  var errorToResponse2 = (error24, set2) => new Response(JSON.stringify({
    name: error24?.name,
    message: error24?.message,
    cause: error24?.cause
  }), {
    status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
    headers: set2?.headers
  });
  var replaceUrlPath2 = (url, pathname) => {
    const urlObject = new URL(url);
    urlObject.pathname = pathname;
    return urlObject.toString();
  };
  var isClass2 = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") || isNotEmpty2(Object.getPrototypeOf(v));
  var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
  var mergeDeep2 = (target, source, {
    skipKeys
  } = {}) => {
    if (isObject2(target) && isObject2(source))
      for (const [key, value15] of Object.entries(source)) {
        if (skipKeys?.includes(key))
          continue;
        if (!isObject2(value15) || !(key in target) || isClass2(value15)) {
          target[key] = value15;
          continue;
        }
        target[key] = mergeDeep2(target[key], value15);
      }
    return target;
  };
  var mergeCookie2 = (a22, b) => {
    const { properties: _, ...target } = a22 ?? {};
    const { properties: __, ...source } = b ?? {};
    return mergeDeep2(target, source);
  };
  var mergeObjectArray2 = (a22 = [], b = []) => {
    if (!a22)
      return [];
    if (!b)
      return a22;
    const array5 = [];
    const checksums = [];
    if (!Array.isArray(a22))
      a22 = [a22];
    if (!Array.isArray(b))
      b = [b];
    for (const item of a22) {
      array5.push(item);
      if (item.checksum)
        checksums.push(item.checksum);
    }
    for (const item of b)
      if (!checksums.includes(item.checksum))
        array5.push(item);
    return array5;
  };
  var primitiveHooks2 = [
    "start",
    "request",
    "parse",
    "transform",
    "resolve",
    "beforeHandle",
    "afterHandle",
    "onResponse",
    "mapResponse",
    "trace",
    "error",
    "stop",
    "body",
    "headers",
    "params",
    "query",
    "response",
    "type",
    "detail"
  ];
  var primitiveHookMap2 = primitiveHooks2.reduce((acc, x) => (acc[x] = true, acc), {});
  var mergeResponse2 = (a22, b) => {
    const isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString2);
    if (isRecordNumber(a22) && isRecordNumber(b))
      return { ...a22, ...b };
    return b ?? a22;
  };
  var mergeHook2 = (a22, b, { allowMacro = false } = {}) => {
    const rest4 = allowMacro ? {
      ...a22,
      ...b
    } : undefined;
    return {
      ...rest4,
      body: b?.body ?? a22?.body,
      headers: b?.headers ?? a22?.headers,
      params: b?.params ?? a22?.params,
      query: b?.query ?? a22?.query,
      response: mergeResponse2(a22?.response, b?.response),
      type: a22?.type || b?.type,
      detail: mergeDeep2(b?.detail ?? {}, a22?.detail ?? {}),
      parse: mergeObjectArray2(a22?.parse, b?.parse),
      transform: mergeObjectArray2(a22?.transform, b?.transform),
      beforeHandle: mergeObjectArray2(a22?.beforeHandle, b?.beforeHandle),
      afterHandle: mergeObjectArray2(a22?.afterHandle, b?.afterHandle),
      onResponse: mergeObjectArray2(a22?.onResponse, b?.onResponse),
      mapResponse: mergeObjectArray2(a22?.mapResponse, b?.mapResponse),
      trace: mergeObjectArray2(a22?.trace, b?.trace),
      error: mergeObjectArray2(a22?.error, b?.error)
    };
  };
  var getSchemaValidator2 = (s, {
    models = {},
    dynamic = false,
    normalize = false,
    additionalProperties = normalize
  }) => {
    if (!s)
      return;
    if (typeof s === "string" && !(s in models))
      return;
    const schema3 = typeof s === "string" ? models[s] : s;
    if (schema3.type === "object" && "additionalProperties" in schema3 === false)
      schema3.additionalProperties = additionalProperties;
    const cleaner = (value15) => import_value3.Value.Clean(schema3, value15);
    if (dynamic) {
      const validator = {
        schema: schema3,
        references: "",
        checkFunc: () => {
        },
        code: "",
        Check: (value15) => import_value3.Value.Check(schema3, value15),
        Errors: (value15) => import_value3.Value.Errors(schema3, value15),
        Code: () => ""
      };
      if (normalize && schema3.additionalProperties === true)
        validator.Clean = cleaner;
      if (schema3.config) {
        validator.config = schema3.config;
        if (validator?.schema?.config)
          delete validator.schema.config;
      }
      return validator;
    }
    const compiled = import_compiler.TypeCompiler.Compile(schema3, Object.values(models));
    compiled.Clean = cleaner;
    if (schema3.config) {
      compiled.config = schema3.config;
      if (compiled?.schema?.config)
        delete compiled.schema.config;
    }
    return compiled;
  };
  var getResponseSchemaValidator2 = (s, {
    models = {},
    dynamic = false,
    normalize = false,
    additionalProperties = normalize
  }) => {
    if (!s)
      return;
    if (typeof s === "string" && !(s in models))
      return;
    const maybeSchemaOrRecord = typeof s === "string" ? models[s] : s;
    const compile = (schema3, references) => {
      const cleaner = (value15) => import_value3.Value.Clean(schema3, value15);
      if (dynamic)
        return {
          schema: schema3,
          references: "",
          checkFunc: () => {
          },
          code: "",
          Check: (value15) => import_value3.Value.Check(schema3, value15),
          Errors: (value15) => import_value3.Value.Errors(schema3, value15),
          Code: () => ""
        };
      const compiledValidator = import_compiler.TypeCompiler.Compile(schema3, references);
      if (normalize && schema3.additionalProperties === true)
        compiledValidator.Clean = cleaner;
      return compiledValidator;
    };
    if (import_typebox.Kind in maybeSchemaOrRecord) {
      if ("additionalProperties" in maybeSchemaOrRecord === false)
        maybeSchemaOrRecord.additionalProperties = additionalProperties;
      return {
        200: compile(maybeSchemaOrRecord, Object.values(models))
      };
    }
    const record4 = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
      const maybeNameOrSchema = maybeSchemaOrRecord[+status];
      if (typeof maybeNameOrSchema === "string") {
        if (maybeNameOrSchema in models) {
          const schema3 = models[maybeNameOrSchema];
          schema3.type === "object" && "additionalProperties" in schema3;
          record4[+status] = import_typebox.Kind in schema3 ? compile(schema3, Object.values(models)) : schema3;
        }
        return;
      }
      if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
        maybeNameOrSchema.additionalProperties = additionalProperties;
      record4[+status] = import_typebox.Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
    });
    return record4;
  };
  var isBun2 = typeof Bun !== "undefined";
  var hasHash2 = isBun2 && typeof Bun.hash === "function";
  var checksum2 = (s) => {
    if (hasHash2)
      return Bun.hash(s);
    let h = 9;
    for (let i = 0;i < s.length; )
      h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
    return h = h ^ h >>> 9;
  };
  var getCookieValidator2 = ({
    validator,
    defaultConfig = {},
    config,
    dynamic,
    models
  }) => {
    let cookieValidator = getSchemaValidator2(validator, {
      dynamic,
      models,
      additionalProperties: true
    });
    if (isNotEmpty2(defaultConfig)) {
      if (cookieValidator) {
        cookieValidator.config = mergeCookie2(cookieValidator.config, config);
      } else {
        cookieValidator = getSchemaValidator2(t22.Cookie({}), {
          dynamic,
          models,
          additionalProperties: true
        });
        cookieValidator.config = defaultConfig;
      }
    }
    return cookieValidator;
  };
  var mergeLifeCycle2 = (a22, b, checksum22) => {
    const injectChecksum = (x) => {
      if (!x)
        return;
      if (!Array.isArray(x)) {
        const fn = x;
        if (checksum22 && !fn.checksum)
          fn.checksum = checksum22;
        if (fn.scope === "scoped")
          fn.scope = "local";
        return fn;
      }
      const fns = [...x];
      for (const fn of fns) {
        if (checksum22 && !fn.checksum)
          fn.checksum = checksum22;
        if (fn.scope === "scoped")
          fn.scope = "local";
      }
      return fns;
    };
    return {
      start: mergeObjectArray2(a22.start, injectChecksum(b?.start)),
      request: mergeObjectArray2(a22.request, injectChecksum(b?.request)),
      parse: mergeObjectArray2(a22.parse, injectChecksum(b?.parse)),
      transform: mergeObjectArray2(a22.transform, injectChecksum(b?.transform)),
      beforeHandle: mergeObjectArray2(a22.beforeHandle, injectChecksum(b?.beforeHandle)),
      afterHandle: mergeObjectArray2(a22.afterHandle, injectChecksum(b?.afterHandle)),
      mapResponse: mergeObjectArray2(a22.mapResponse, injectChecksum(b?.mapResponse)),
      onResponse: mergeObjectArray2(a22.onResponse, injectChecksum(b?.onResponse)),
      trace: a22.trace,
      error: mergeObjectArray2(a22.error, injectChecksum(b?.error)),
      stop: mergeObjectArray2(a22.stop, injectChecksum(b?.stop))
    };
  };
  var asHookType2 = (fn, inject, { skipIfHasType = false } = {}) => {
    if (!fn)
      return fn;
    if (!Array.isArray(fn)) {
      if (skipIfHasType)
        fn.scope ??= inject;
      else
        fn.scope = inject;
      return fn;
    }
    for (const x of fn)
      if (skipIfHasType)
        x.scope ??= inject;
      else
        x.scope = inject;
    return fn;
  };
  var filterGlobal2 = (fn) => {
    if (!fn)
      return fn;
    if (!Array.isArray(fn))
      switch (fn.scope) {
        case "global":
        case "scoped":
          return { ...fn };
        default:
          return { fn };
      }
    const array5 = [];
    for (const x of fn)
      switch (x.scope) {
        case "global":
        case "scoped":
          array5.push({
            ...x
          });
          break;
      }
    return array5;
  };
  var filterGlobalHook2 = (hook) => {
    return {
      ...hook,
      type: hook?.type,
      detail: hook?.detail,
      parse: filterGlobal2(hook?.parse),
      transform: filterGlobal2(hook?.transform),
      beforeHandle: filterGlobal2(hook?.beforeHandle),
      afterHandle: filterGlobal2(hook?.afterHandle),
      onResponse: filterGlobal2(hook?.onResponse),
      error: filterGlobal2(hook?.error),
      mapResponse: filterGlobal2(hook?.mapResponse)
    };
  };
  var StatusMap2 = {
    Continue: 100,
    "Switching Protocols": 101,
    Processing: 102,
    "Early Hints": 103,
    OK: 200,
    Created: 201,
    Accepted: 202,
    "Non-Authoritative Information": 203,
    "No Content": 204,
    "Reset Content": 205,
    "Partial Content": 206,
    "Multi-Status": 207,
    "Already Reported": 208,
    "Multiple Choices": 300,
    "Moved Permanently": 301,
    Found: 302,
    "See Other": 303,
    "Not Modified": 304,
    "Temporary Redirect": 307,
    "Permanent Redirect": 308,
    "Bad Request": 400,
    Unauthorized: 401,
    "Payment Required": 402,
    Forbidden: 403,
    "Not Found": 404,
    "Method Not Allowed": 405,
    "Not Acceptable": 406,
    "Proxy Authentication Required": 407,
    "Request Timeout": 408,
    Conflict: 409,
    Gone: 410,
    "Length Required": 411,
    "Precondition Failed": 412,
    "Payload Too Large": 413,
    "URI Too Long": 414,
    "Unsupported Media Type": 415,
    "Range Not Satisfiable": 416,
    "Expectation Failed": 417,
    "I'm a teapot": 418,
    "Misdirected Request": 421,
    "Unprocessable Content": 422,
    Locked: 423,
    "Failed Dependency": 424,
    "Too Early": 425,
    "Upgrade Required": 426,
    "Precondition Required": 428,
    "Too Many Requests": 429,
    "Request Header Fields Too Large": 431,
    "Unavailable For Legal Reasons": 451,
    "Internal Server Error": 500,
    "Not Implemented": 501,
    "Bad Gateway": 502,
    "Service Unavailable": 503,
    "Gateway Timeout": 504,
    "HTTP Version Not Supported": 505,
    "Variant Also Negotiates": 506,
    "Insufficient Storage": 507,
    "Loop Detected": 508,
    "Not Extended": 510,
    "Network Authentication Required": 511
  };
  var InvertedStatusMap2 = Object.fromEntries(Object.entries(StatusMap2).map(([k, v]) => [v, k]));
  var encoder2 = new TextEncoder;
  var signCookie2 = async (val, secret) => {
    if (typeof val !== "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const secretKey = await crypto.subtle.importKey("raw", encoder2.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder2.encode(val));
    return val + "." + removeTrailingEquals2(Buffer.from(hmacBuffer).toString("base64"));
  };
  var unsignCookie2 = async (input, secret) => {
    if (typeof input !== "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const tentativeValue = input.slice(0, input.lastIndexOf("."));
    const expectedInput = await signCookie2(tentativeValue, secret);
    return expectedInput === input ? tentativeValue : false;
  };
  var traceBackMacro2 = (extension, property, hooks = property) => {
    if (!extension || typeof extension !== "object" || !property)
      return;
    for (const [key, value15] of Object.entries(property)) {
      if (key in primitiveHookMap2 || !(key in extension))
        continue;
      const v = extension[key];
      if (typeof v === "function") {
        v(value15);
      } else if (typeof v === "object")
        traceBackMacro2(v, value15, hooks);
    }
  };
  var createMacroManager2 = ({
    globalHook,
    localHook
  }) => (stackName) => (type74, fn) => {
    if (typeof type74 === "function")
      type74 = {
        fn: type74
      };
    if ("fn" in type74 || Array.isArray(type74)) {
      if (!localHook[stackName])
        localHook[stackName] = [];
      if (typeof localHook[stackName] === "function")
        localHook[stackName] = [localHook[stackName]];
      if (Array.isArray(type74))
        localHook[stackName] = localHook[stackName].concat(type74);
      else
        localHook[stackName].push(type74);
      return;
    }
    const { insert = "after", stack = "local" } = type74;
    if (typeof fn === "function")
      fn = { fn };
    if (stack === "global") {
      if (!Array.isArray(fn)) {
        if (insert === "before") {
          globalHook[stackName].unshift(fn);
        } else {
          globalHook[stackName].push(fn);
        }
      } else {
        if (insert === "before") {
          globalHook[stackName] = fn.concat(globalHook[stackName]);
        } else {
          globalHook[stackName] = globalHook[stackName].concat(fn);
        }
      }
    } else {
      if (!localHook[stackName])
        localHook[stackName] = [];
      if (typeof localHook[stackName] === "function")
        localHook[stackName] = [localHook[stackName]];
      if (!Array.isArray(fn)) {
        if (insert === "before") {
          localHook[stackName].unshift(fn);
        } else {
          localHook[stackName].push(fn);
        }
      } else {
        if (insert === "before") {
          localHook[stackName] = fn.concat(localHook[stackName]);
        } else {
          localHook[stackName] = localHook[stackName].concat(fn);
        }
      }
    }
  };
  var isNumericString2 = (message) => {
    if (message.length < 16)
      return message.trim().length !== 0 && !Number.isNaN(Number(message));
    if (message.length === 16) {
      const numVal = Number(message);
      if (numVal.toString() === message)
        return message.trim().length !== 0 && !Number.isNaN(numVal);
    }
    return false;
  };
  var PromiseGroup2 = class {
    constructor(onError = console.error) {
      this.onError = onError;
      this.root = null;
      this.promises = [];
    }
    get size() {
      return this.promises.length;
    }
    add(promise5) {
      this.promises.push(promise5);
      this.root ||= this.drain();
      return promise5;
    }
    async drain() {
      while (this.promises.length > 0) {
        try {
          await this.promises[0];
        } catch (error24) {
          this.onError(error24);
        }
        this.promises.shift();
      }
      this.root = null;
    }
    then(onfulfilled, onrejected) {
      return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
    }
  };
  var fnToContainer2 = (fn) => {
    if (!fn)
      return fn;
    if (!Array.isArray(fn)) {
      if (typeof fn === "function")
        return { fn };
      else if ("fn" in fn)
        return fn;
    }
    const fns = [];
    for (const x of fn) {
      if (typeof x === "function")
        fns.push({ fn: x });
      else if ("fn" in x)
        fns.push(x);
    }
    return fns;
  };
  var localHookToLifeCycleStore2 = (a22) => {
    return {
      ...a22,
      start: fnToContainer2(a22?.start),
      request: fnToContainer2(a22?.request),
      parse: fnToContainer2(a22?.parse),
      transform: fnToContainer2(a22?.transform),
      beforeHandle: fnToContainer2(a22?.beforeHandle),
      afterHandle: fnToContainer2(a22?.afterHandle),
      onResponse: fnToContainer2(a22?.onResponse),
      mapResponse: fnToContainer2(a22?.mapResponse),
      trace: fnToContainer2(a22?.trace),
      error: fnToContainer2(a22?.error),
      stop: fnToContainer2(a22?.stop)
    };
  };
  var lifeCycleToFn2 = (a22) => {
    return {
      ...a22,
      start: a22.start?.map((x) => x.fn),
      request: a22.request?.map((x) => x.fn),
      parse: a22.parse?.map((x) => x.fn),
      transform: a22.transform?.map((x) => x.fn),
      beforeHandle: a22.beforeHandle?.map((x) => x.fn),
      afterHandle: a22.afterHandle?.map((x) => x.fn),
      onResponse: a22.onResponse?.map((x) => x.fn),
      mapResponse: a22.mapResponse?.map((x) => x.fn),
      trace: a22.trace?.map((x) => x.fn),
      error: a22.error?.map((x) => x.fn),
      stop: a22.stop?.map((x) => x.fn)
    };
  };
  var cloneInference2 = (inference) => ({
    event: {
      body: inference.event.body,
      cookie: inference.event.cookie,
      headers: inference.event.headers,
      queries: [...inference.event.queries],
      query: inference.event.query,
      set: inference.event.set,
      unknownQueries: inference.event.unknownQueries
    },
    trace: {
      request: inference.trace.request,
      parse: inference.trace.parse,
      transform: inference.trace.transform,
      handle: inference.trace.handle,
      beforeHandle: inference.trace.beforeHandle,
      afterHandle: inference.trace.afterHandle,
      error: inference.trace.error,
      context: inference.trace.context,
      store: inference.trace.store,
      set: inference.trace.set
    }
  });
  var redirect2 = (url, status = 301) => new Response(null, {
    status,
    headers: {
      Location: url
    }
  });
  var env2 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
  var ERROR_CODE2 = Symbol("ElysiaErrorCode");
  var ELYSIA_RESPONSE2 = Symbol("ElysiaResponse");
  var isProduction2 = (env2?.NODE_ENV ?? env2?.ENV) === "production";
  var error23 = (code, response) => ({
    [ELYSIA_RESPONSE2]: StatusMap2[code] ?? code,
    response: response ?? (code in InvertedStatusMap2 ? InvertedStatusMap2[code] : code),
    _type: undefined
  });
  var InternalServerError2 = class extends Error {
    constructor(message) {
      super(message ?? "INTERNAL_SERVER_ERROR");
      this.code = "INTERNAL_SERVER_ERROR";
      this.status = 500;
    }
  };
  var NotFoundError2 = class extends Error {
    constructor(message) {
      super(message ?? "NOT_FOUND");
      this.code = "NOT_FOUND";
      this.status = 404;
    }
  };
  var ParseError2 = class extends Error {
    constructor(message, body) {
      super(message ?? "PARSE");
      this.body = body;
      this.code = "PARSE";
      this.status = 400;
    }
  };
  var InvalidCookieSignature2 = class extends Error {
    constructor(key, message) {
      super(message ?? `"${key}" has invalid cookie signature`);
      this.key = key;
      this.code = "INVALID_COOKIE_SIGNATURE";
      this.status = 400;
    }
  };
  var ValidationError2 = class _ValidationError2 extends Error {
    constructor(type74, validator, value15) {
      if (typeof value15 === "object" && ELYSIA_RESPONSE2 in value15)
        value15 = value15.response;
      const error24 = isProduction2 ? undefined : ("Errors" in validator) ? validator.Errors(value15).First() : import_value2.Value.Errors(validator, value15).First();
      const customError = error24?.schema.error ? typeof error24.schema.error === "function" ? error24.schema.error(type74, validator, value15) : error24.schema.error : undefined;
      const accessor = error24?.path || "root";
      let message = "";
      if (customError) {
        message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
      } else if (isProduction2) {
        message = JSON.stringify({
          type: "validation",
          on: type74,
          message: error24?.message,
          found: value15
        });
      } else {
        const schema3 = validator?.schema ?? validator;
        const errors5 = "Errors" in validator ? [...validator.Errors(value15)] : [...import_value2.Value.Errors(validator, value15)];
        let expected;
        try {
          expected = import_value2.Value.Create(schema3);
        } catch (error32) {
          expected = {
            type: "Could not create expected value",
            message: error32?.message,
            error: error32
          };
        }
        message = JSON.stringify({
          type: "validation",
          on: type74,
          property: accessor,
          message: error24?.message,
          expected,
          found: value15,
          errors: errors5
        }, null, 2);
      }
      super(message);
      this.type = type74;
      this.validator = validator;
      this.value = value15;
      this.code = "VALIDATION";
      this.status = 422;
      Object.setPrototypeOf(this, _ValidationError2.prototype);
    }
    get all() {
      return [...this.validator.Errors(this.value)];
    }
    static simplifyModel(validator) {
      const model = "schema" in validator ? validator.schema : validator;
      try {
        return import_value2.Value.Create(model);
      } catch {
        return model;
      }
    }
    get model() {
      return _ValidationError2.simplifyModel(this.validator);
    }
    toResponse(headers) {
      return new Response(this.message, {
        status: 400,
        headers: {
          ...headers,
          "content-type": "application/json"
        }
      });
    }
  };
  var websocket2 = {
    open(ws) {
      ws.data.open?.(ws);
    },
    message(ws, message) {
      ws.data.message?.(ws, message);
    },
    drain(ws) {
      ws.data.drain?.(ws);
    },
    close(ws, code, reason) {
      ws.data.close?.(ws, code, reason);
    }
  };
  var ElysiaWS2 = class {
    constructor(raw, data) {
      this.raw = raw;
      this.data = data;
      this.validator = raw.data.validator;
      if (raw.data.id) {
        this.id = raw.data.id;
      } else {
        const array5 = new Uint32Array(1);
        crypto.getRandomValues(array5);
        this.id = array5[0].toString();
      }
    }
    get id() {
      return this.raw.data.id;
    }
    set id(newID) {
      this.raw.data.id = newID;
    }
    get publish() {
      return (topic, data = undefined, compress) => {
        if (this.validator?.Check(data) === false)
          throw new ValidationError2("message", this.validator, data);
        if (typeof data === "object")
          data = JSON.stringify(data);
        this.raw.publish(topic, data, compress);
        return this;
      };
    }
    get send() {
      return (data) => {
        if (this.validator?.Check(data) === false)
          throw new ValidationError2("message", this.validator, data);
        if (Buffer.isBuffer(data)) {
          this.raw.send(data);
          return this;
        }
        if (typeof data === "object")
          data = JSON.stringify(data);
        this.raw.send(data);
        return this;
      };
    }
    get subscribe() {
      return (room) => {
        this.raw.subscribe(room);
        return this;
      };
    }
    get unsubscribe() {
      return (room) => {
        this.raw.unsubscribe(room);
        return this;
      };
    }
    get cork() {
      return (callback) => {
        this.raw.cork(callback);
        return this;
      };
    }
    get close() {
      return () => {
        this.raw.close();
        return this;
      };
    }
    get terminate() {
      return this.raw.terminate.bind(this.raw);
    }
    get isSubscribed() {
      return this.raw.isSubscribed.bind(this.raw);
    }
    get remoteAddress() {
      return this.raw.remoteAddress;
    }
  };
  var import_value32 = require_value5();
  var import_fast_querystring3 = require_lib();
  var import_fast_decode_uri_component22 = __toESM2(require_fast_decode_uri_component());
  var headersHasToJSON2 = new Headers().toJSON;
  var requestId2 = { value: 0 };
  var createReport2 = ({
    hasTrace,
    hasTraceSet = false,
    addFn,
    condition = {}
  }) => {
    if (hasTrace) {
      addFn(`
const reporter = getReporter()
`);
      return (event, {
        name,
        attribute = "",
        unit = 0
      } = {}) => {
        const dotIndex = event.indexOf(".");
        const isGroup = dotIndex === -1;
        if (event !== "request" && event !== "response" && !condition[isGroup ? event : event.slice(0, dotIndex)])
          return () => {
            if (hasTraceSet && event === "afterHandle")
              addFn(`
await traceDone
`);
          };
        if (isGroup)
          name ||= event;
        else
          name ||= "anonymous";
        addFn("\n" + `reporter.emit('event', {
					id,
					event: '${event}',
					type: 'begin',
					name: '${name}',
					time: performance.now(),
					${isGroup ? `unit: ${unit},` : ""}
					${attribute}
				})`.replace(/(\t| |\n)/g, "") + "\n");
        return () => {
          addFn("\n" + `reporter.emit('event', {
							id,
							event: '${event}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n");
          if (hasTraceSet && event === "afterHandle")
            addFn(`
await traceDone
`);
        };
      };
    } else {
      return () => () => {
      };
    }
  };
  var hasReturn2 = (fnLiteral) => {
    const parenthesisEnd = fnLiteral.indexOf(")");
    if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
      return true;
    }
    return fnLiteral.includes("return");
  };
  var composeValidationFactory2 = (hasErrorHandler, {
    injectResponse = "",
    normalize = false
  } = {}) => ({
    composeValidation: (type74, value15 = `c.${type74}`) => hasErrorHandler ? `c.set.status = 422; throw new ValidationError('${type74}', ${type74}, ${value15})` : `c.set.status = 422; return new ValidationError('${type74}', ${type74}, ${value15}).toResponse(c.set.headers)`,
    composeResponseValidation: (name = "r") => {
      const returnError = hasErrorHandler ? `throw new ValidationError('response', response[c.set.status], ${name})` : `return new ValidationError('response', response[c.set.status], ${name}).toResponse(c.set.headers)`;
      let code = "\n" + injectResponse + "\n";
      code += `let er

		if(${name} && typeof ${name} === "object" && ELYSIA_RESPONSE in ${name})
			er = ${name}[ELYSIA_RESPONSE]
`;
      if (normalize)
        code += `
			if(!er && response[c.set.status]?.Clean)
				${name} = response[c.set.status]?.Clean(${name})
			else if(response[er]?.Clean)
				${name}.response = response[er]?.Clean(${name}.response)`;
      code += `
			if(er) {
				if(!(${name} instanceof Response) && response[er]?.Check(${name}.response) === false) {
					if(!(response instanceof Error)) {
						c.set.status = ${name}[ELYSIA_RESPONSE]

						${returnError}
					}
				}
			} else if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {
				if(!(response instanceof Error))
					${returnError}
			}
`;
      return code;
    }
  });
  var KindSymbol2 = Symbol.for("TypeBox.Kind");
  var hasProperty2 = (expectedProperty, schema3) => {
    if (!schema3)
      return;
    if (schema3.type === "object") {
      const properties = schema3.properties;
      if (!properties)
        return false;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (expectedProperty in property)
          return true;
        if (property.type === "object") {
          if (hasProperty2(expectedProperty, property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++) {
            if (hasProperty2(expectedProperty, property.anyOf[i]))
              return true;
          }
        }
      }
      return false;
    }
    return expectedProperty in schema3;
  };
  var TransformSymbol2 = Symbol.for("TypeBox.Transform");
  var hasTransform2 = (schema3) => {
    if (!schema3)
      return;
    if (schema3.type === "object" && schema3.properties) {
      const properties = schema3.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (property.type === "object") {
          if (hasTransform2(property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++)
            if (hasTransform2(property.anyOf[i]))
              return true;
        }
        const hasTransformSymbol = TransformSymbol2 in property;
        if (hasTransformSymbol)
          return true;
      }
      return false;
    }
    return TransformSymbol2 in schema3 || schema3.properties && TransformSymbol2 in schema3.properties;
  };
  var matchFnReturn2 = /(?:return|=>) \S+\(/g;
  var isAsync2 = (v) => {
    const fn = "fn" in v ? v.fn : v;
    if (fn.constructor.name === "AsyncFunction")
      return true;
    const literal14 = fn.toString();
    if (literal14.includes("=> response.clone("))
      return false;
    if (literal14.includes("await"))
      return true;
    if (literal14.includes("async"))
      return true;
    return !!literal14.match(matchFnReturn2);
  };
  var composeHandler2 = ({
    app,
    path,
    method,
    localHook,
    hooks,
    validator,
    handler,
    allowMeta = false,
    appInference: { event: eventInference, trace: traceInference }
  }) => {
    const isHandleFn = typeof handler === "function";
    if (!isHandleFn)
      handler = mapResponse2(handler, {
        headers: app.setHeaders ?? {}
      });
    const hasErrorHandler = app.config.forceErrorEncapsulation && (isHandleFn || hooks.afterHandle.length > 0 || hooks.beforeHandle.length > 0 || hooks.transform.length > 0) || hooks.error.length > 0 || app.event.error.length > 0 || typeof Bun === "undefined" || hooks.onResponse.length > 0 || !!hooks.trace.length;
    const handle = isHandleFn ? `handler(c)` : `handler`;
    const handleResponse = hooks.onResponse.length ? `
;(async () => {${hooks.onResponse.map((_, i) => `await res${i}(c)`).join(";")}})();
` : "";
    const traceConditions = traceInference;
    const hasTrace = hooks.trace.length > 0;
    let fnLiteral = "";
    const inference = sucrose2(Object.assign(localHook, {
      handler
    }), eventInference);
    const hasQuery = inference.query || !!validator.query;
    const hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && hooks.type !== "none" && (inference.body || !!validator.body);
    const defaultHeaders = app.setHeaders;
    const hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length;
    const hasHeaders = inference.headers || validator.headers;
    const hasCookie = inference.cookie || !!validator.cookie;
    const cookieValidator = hasCookie ? getCookieValidator2({
      validator: validator.cookie,
      defaultConfig: app.config.cookie,
      dynamic: !!app.config.aot,
      config: validator.cookie?.config ?? {},
      models: app.definitions.type
    }) : undefined;
    const cookieMeta = cookieValidator?.config;
    let encodeCookie = "";
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
      if (cookieMeta.sign === true) {
        encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
      } else
        for (const name of cookieMeta.sign) {
          encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
        }
      encodeCookie += "}\n";
    }
    const normalize = app.config.normalize;
    const { composeValidation, composeResponseValidation } = composeValidationFactory2(hasErrorHandler, {
      normalize
    });
    if (hasHeaders) {
      fnLiteral += headersHasToJSON2 ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
    }
    if (hasCookie) {
      const get = (name, defaultValue) => {
        const value15 = cookieMeta?.[name] ?? defaultValue;
        if (!value15)
          return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
        if (typeof value15 === "string")
          return `${name}: '${value15}',`;
        if (value15 instanceof Date)
          return `${name}: new Date(${value15.getTime()}),`;
        return `${name}: ${value15},`;
      };
      const options = cookieMeta ? `{
			secrets: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a22, b) => a22 + `'${b}',`, "") + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a22, b) => a22 + `'${b}',`, "") + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
      if (hasHeaders)
        fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
      else
        fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
    }
    if (hasQuery) {
      let destructured = [];
      if (validator.query && validator.query.schema.type === "object") {
        destructured = Object.keys(validator.query.schema.properties);
      } else
        for (const query of inference.queries)
          if (destructured.indexOf(query) === -1)
            destructured.push(query);
      if (app.config.forceDynamicQuery === true || inference.unknownQueries === true || !destructured.length) {
        fnLiteral += `if(c.qi !== -1) {
				c.query = parseQuery(c.url.slice(c.qi + 1).replace(/\\+/g, ' '))

				// decodeURIComponent is already done in parseQuery function
				// for(const key of Object.keys(c.query))
				//  	c.query[key] = decodeURIComponentc.query[key])
			} else c.query = {}`;
      } else {
        fnLiteral += `if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1).replace(/\\+/g, ' ')

				${destructured.map((name, index) => `
						${index === 0 ? "let" : ""} memory = url.indexOf('&${name}=')
						let a${index}

						if (memory !== -1) {
							const start = memory + ${name.length + 2}
							memory = url.indexOf('&', start)

							if(memory === -1) a${index} = decodeURIComponent(url.slice(start))
							else a${index} = decodeURIComponent(url.slice(start, memory))
						}`).join("\n")}

				c.query = {
					${destructured.map((name, index) => `'${name}': a${index}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
      }
    }
    const hasTraceSet = traceInference.set;
    const hasSet = inference.cookie || inference.set || hasTraceSet || hasHeaders || isHandleFn && hasDefaultHeaders;
    if (hasTrace)
      fnLiteral += "\nconst id = c.$$requestId\n";
    const report = createReport2({
      hasTrace,
      hasTraceSet,
      condition: traceConditions,
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    fnLiteral += hasErrorHandler ? "\n try {\n" : "";
    if (hasTraceSet) {
      fnLiteral += `
const traceDone = Promise.all([`;
      for (let i = 0;i < hooks.trace.length; i++) {
        fnLiteral += `new Promise(r => { reporter.once(\`res\${id}.${i}\`, r) }),`;
      }
      fnLiteral += `])
`;
    }
    const isAsyncHandler = typeof handler === "function" && isAsync2(handler);
    const maybeAsync = hasCookie || hasBody || hasTraceSet || isAsyncHandler || !!hooks.mapResponse.length || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync2) || hooks.beforeHandle.some(isAsync2) || hooks.transform.some(isAsync2);
    const endParse = report("parse", {
      unit: hooks.parse.length
    });
    if (hasBody) {
      const hasBodyInference = hooks.parse.length || inference.body || validator.body;
      if (hooks.type && !hooks.parse.length) {
        switch (hooks.type) {
          case "json":
          case "application/json":
            if (hasErrorHandler)
              fnLiteral += `const tempBody = await c.request.text()

							try {
								c.body = JSON.parse(tempBody)
							} catch {
								throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
							}`;
            else
              fnLiteral += `c.body = await c.request.json()`;
            break;
          case "text":
          case "text/plain":
            fnLiteral += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
            break;
        }
      } else if (hasBodyInference) {
        fnLiteral += "\n";
        fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
        fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)

					c.contentType = contentType
`;
        if (hooks.parse.length) {
          fnLiteral += `let used = false
`;
          const endReport = report("parse", {
            unit: hooks.parse.length
          });
          for (let i = 0;i < hooks.parse.length; i++) {
            const endUnit = report("parse.unit", {
              name: hooks.parse[i].fn.name
            });
            const name = `bo${i}`;
            if (i !== 0)
              fnLiteral += `if(!used) {
`;
            fnLiteral += `let ${name} = parse[${i}](c, contentType)
`;
            fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
            fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
            endUnit();
            if (i !== 0)
              fnLiteral += `}`;
          }
          endReport();
        }
        fnLiteral += "\ndelete c.contentType\n";
        if (hooks.parse.length)
          fnLiteral += `if (!used) {`;
        if (hooks.type && !Array.isArray(hooks.type)) {
          switch (hooks.type) {
            case "json":
            case "application/json":
              if (hasErrorHandler)
                fnLiteral += `const tempBody = await c.request.text()

								try {
									c.body = JSON.parse(tempBody)
								} catch {
									throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
								}`;
              else
                fnLiteral += `c.body = await c.request.json()`;
              break;
            case "text":
            case "text/plain":
              fnLiteral += `c.body = await c.request.text()
`;
              break;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              fnLiteral += `c.body = parseQuery(await c.request.text())
`;
              break;
            case "arrayBuffer":
            case "application/octet-stream":
              fnLiteral += `c.body = await c.request.arrayBuffer()
`;
              break;
            case "formdata":
            case "multipart/form-data":
              fnLiteral += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}
`;
              break;
          }
        } else {
          fnLiteral += `
					switch (contentType) {
						case 'application/json':
							${hasErrorHandler ? `
							const tempBody = await c.request.text()

							try {
								c.body = JSON.parse(tempBody)
							} catch {
								throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
							}
							` : `c.body = await c.request.json()
`}
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;
        }
        if (hooks.parse.length)
          fnLiteral += `}`;
        fnLiteral += "}\n";
      }
      fnLiteral += "\n";
    }
    endParse();
    if (hooks?.transform) {
      const endTransform = report("transform", {
        unit: hooks.transform.length
      });
      if (hooks.transform.length)
        fnLiteral += "\nlet transformed\n";
      for (let i = 0;i < hooks.transform.length; i++) {
        const transform7 = hooks.transform[i];
        const endUnit = report("transform.unit", {
          name: transform7.fn.name
        });
        fnLiteral += isAsync2(transform7) ? `transformed = await transform[${i}](c)
` : `transformed = transform[${i}](c)
`;
        fnLiteral += `if(transformed?.[ELYSIA_RESPONSE])
				throw transformed
			else
				Object.assign(c, transformed)
`;
        endUnit();
      }
      endTransform();
    }
    if (validator) {
      fnLiteral += "\n";
      if (validator.headers) {
        if (hasProperty2("default", validator.headers.params))
          for (const [key, value15] of Object.entries(import_value32.Value.Default(validator.headers.schema, {}))) {
            const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
            if (parsed)
              fnLiteral += `c.headers['${key}'] ??= ${parsed}
`;
          }
        fnLiteral += `if(headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
        if (hasTransform2(validator.headers.schema))
          fnLiteral += `
c.headers = headers.Decode(c.headers)
`;
      }
      if (validator.params) {
        if (hasProperty2("default", validator.params.schema))
          for (const [key, value15] of Object.entries(import_value32.Value.Default(validator.params.schema, {}))) {
            const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
            if (parsed)
              fnLiteral += `c.params['${key}'] ??= ${parsed}
`;
          }
        fnLiteral += `if(params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
        if (hasTransform2(validator.params.schema))
          fnLiteral += `
c.params = params.Decode(c.params)
`;
      }
      if (validator.query) {
        if (normalize)
          fnLiteral += "c.query = query.Clean(c.query);\n";
        if (hasProperty2("default", validator.query.schema))
          for (const [key, value15] of Object.entries(import_value32.Value.Default(validator.query.schema, {}))) {
            const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
            if (parsed)
              fnLiteral += `c.query['${key}'] ??= ${parsed}
`;
          }
        fnLiteral += `if(query.Check(c.query) === false) {
				${composeValidation("query")}
			}`;
        if (hasTransform2(validator.query.schema))
          fnLiteral += `
c.query = query.Decode(Object.assign({}, c.query))
`;
      }
      if (validator.body) {
        if (normalize)
          fnLiteral += "c.body = body.Clean(c.body);\n";
        if (hasProperty2("default", validator.body.schema))
          fnLiteral += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(import_value32.Value.Default(validator.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${composeValidation("body")}
     			}
            }`;
        else
          fnLiteral += `if(body.Check(c.body) === false) {
			${composeValidation("body")}
		}`;
        if (hasTransform2(validator.body.schema))
          fnLiteral += `
c.body = body.Decode(c.body)
`;
      }
      if (isNotEmpty2(cookieValidator?.schema.properties ?? {})) {
        fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
        if (hasProperty2("default", cookieValidator.schema))
          for (const [key, value15] of Object.entries(import_value32.Value.Default(cookieValidator.schema, {}))) {
            fnLiteral += `cookieValue['${key}'] = ${typeof value15 === "object" ? JSON.stringify(value15) : value15}
`;
          }
        fnLiteral += `if(cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
      }
    }
    if (hooks?.beforeHandle) {
      const endBeforeHandle = report("beforeHandle", {
        unit: hooks.beforeHandle.length
      });
      let hasResolve = false;
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        const beforeHandle = hooks.beforeHandle[i];
        const endUnit = report("beforeHandle.unit", {
          name: beforeHandle.fn.name
        });
        const returning = hasReturn2(beforeHandle.fn.toString());
        const isResolver = beforeHandle.subType === "resolve";
        if (isResolver) {
          if (!hasResolve) {
            hasResolve = true;
            fnLiteral += "\nlet resolved\n";
          }
          fnLiteral += isAsync2(beforeHandle) ? `resolved = await beforeHandle[${i}](c);
` : `resolved = beforeHandle[${i}](c);
`;
          fnLiteral += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)
`;
        } else if (!returning) {
          fnLiteral += isAsync2(beforeHandle) ? `await beforeHandle[${i}](c);
` : `beforeHandle[${i}](c);
`;
          endUnit();
        } else {
          fnLiteral += `Object.assign(c, be);`;
          fnLiteral += isAsync2(beforeHandle) ? `be = await beforeHandle[${i}](c);
` : `be = beforeHandle[${i}](c);
`;
          endUnit();
          fnLiteral += `if(be !== undefined) {
`;
          endBeforeHandle();
          if (hooks.afterHandle?.length) {
            const endAfterHandle = report("afterHandle", {
              unit: hooks.transform.length
            });
            report("handle", {
              name: isHandleFn ? handler.name : undefined
            })();
            for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
              const hook = hooks.afterHandle[i2];
              const returning2 = hasReturn2(hook.fn.toString());
              const endUnit2 = report("afterHandle.unit", {
                name: hook.fn.name
              });
              fnLiteral += `c.response = be
`;
              if (!returning2) {
                fnLiteral += isAsync2(hook.fn) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
              } else {
                fnLiteral += isAsync2(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
                fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
              }
              endUnit2();
            }
            endAfterHandle();
          }
          if (validator.response)
            fnLiteral += composeResponseValidation("be");
          if (hooks.mapResponse.length) {
            fnLiteral += `c.response = be`;
            for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
              fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i2}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}
`;
            }
          }
          fnLiteral += encodeCookie;
          fnLiteral += `return mapEarlyResponse(be, c.set)}
`;
        }
      }
      endBeforeHandle();
    }
    if (hooks?.afterHandle.length) {
      const endHandle = report("handle", {
        name: isHandleFn ? handler.name : undefined
      });
      if (hooks.afterHandle.length)
        fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle};
` : `let r = c.response = ${handle};
`;
      else
        fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      const endAfterHandle = report("afterHandle", {
        unit: hooks.afterHandle.length
      });
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        const hook = hooks.afterHandle[i];
        const returning = hasReturn2(hook.fn.toString());
        const endUnit = report("afterHandle.unit", {
          name: hook.fn.name
        });
        if (!returning) {
          fnLiteral += isAsync2(hook.fn) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`;
          endUnit();
        } else {
          fnLiteral += isAsync2(hook.fn) ? `af = await afterHandle[${i}](c)
` : `af = afterHandle[${i}](c)
`;
          endUnit();
          if (validator.response) {
            fnLiteral += `if(af !== undefined) {`;
            endAfterHandle();
            fnLiteral += composeResponseValidation("af");
            fnLiteral += `c.response = af }`;
          } else {
            fnLiteral += `if(af !== undefined) {`;
            endAfterHandle();
            fnLiteral += `c.response = af}
`;
          }
        }
      }
      endAfterHandle();
      fnLiteral += `r = c.response
`;
      if (validator.response)
        fnLiteral += composeResponseValidation();
      fnLiteral += encodeCookie;
      if (hooks.mapResponse.length) {
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
mr = onMapResponse[${i}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr
`;
        }
      }
      if (hasSet)
        fnLiteral += `return mapResponse(r, c.set)
`;
      else
        fnLiteral += `return mapCompactResponse(r)
`;
    } else {
      const endHandle = report("handle", {
        name: isHandleFn ? handler.name : undefined
      });
      if (validator.response || hooks.mapResponse.length) {
        fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
        endHandle();
        if (validator.response)
          fnLiteral += composeResponseValidation();
        report("afterHandle")();
        if (hooks.mapResponse.length) {
          fnLiteral += "c.response = r";
          for (let i = 0;i < hooks.mapResponse.length; i++) {
            fnLiteral += `
if(mr === undefined) {
						mr = onMapResponse[${i}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}
`;
          }
        }
        fnLiteral += encodeCookie;
        if (handler instanceof Response) {
          fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${handle}.clone(), c.set)
				else
					return ${handle}.clone()` : `return ${handle}.clone()`;
          fnLiteral += "\n";
        } else if (hasSet)
          fnLiteral += `return mapResponse(r, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(r)
`;
      } else if (traceConditions.handle || hasCookie) {
        fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
        endHandle();
        report("afterHandle")();
        if (hooks.mapResponse.length) {
          fnLiteral += "c.response = r";
          for (let i = 0;i < hooks.mapResponse.length; i++) {
            fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}
`;
          }
        }
        fnLiteral += encodeCookie;
        if (hasSet)
          fnLiteral += `return mapResponse(r, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(r)
`;
      } else {
        endHandle();
        const handled = isAsyncHandler ? `await ${handle}` : handle;
        report("afterHandle")();
        if (handler instanceof Response) {
          fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${handle}.clone(), c.set)
				else
					return ${handle}.clone()` : `return ${handle}.clone()`;
          fnLiteral += "\n";
        } else if (hasSet)
          fnLiteral += `return mapResponse(${handled}, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(${handled})
`;
      }
    }
    if (hasErrorHandler || handleResponse) {
      fnLiteral += `
} catch(error) {`;
      if (!maybeAsync)
        fnLiteral += `return (async () => {`;
      fnLiteral += `const set = c.set
if (!set.status || set.status < 300) set.status = error?.status || 500
`;
      const endError = report("error", {
        unit: hooks.error.length
      });
      if (hooks.error.length) {
        fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
        for (let i = 0;i < hooks.error.length; i++) {
          const name = `er${i}`;
          const endUnit = report("error.unit", {
            name: hooks.error[i].fn.name
          });
          fnLiteral += `
let ${name} = handleErrors[${i}](c)
`;
          if (isAsync2(hooks.error[i]))
            fnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}
`;
          endUnit();
          fnLiteral += `${name} = mapEarlyResponse(${name}, set)
`;
          fnLiteral += `if (${name}) {`;
          fnLiteral += `return ${name} }
`;
        }
      }
      endError();
      fnLiteral += `return handleError(c, error, true)

`;
      if (!maybeAsync)
        fnLiteral += "})()";
      fnLiteral += "}";
      if (handleResponse || hasTrace) {
        fnLiteral += ` finally { `;
        const endResponse = report("response", {
          unit: hooks.onResponse.length
        });
        fnLiteral += handleResponse;
        endResponse();
        fnLiteral += `}`;
      }
    }
    fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE
	} = hooks

	${hooks.onResponse.length ? `const ${hooks.onResponse.map((x, i) => `res${i} = onResponse[${i}]`).join(",")}` : ""}

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${allowMeta ? "c.schema = schema; c.defs = definitions" : ""}
		${fnLiteral}
	}`;
    const createHandler = Function("hooks", fnLiteral);
    return createHandler({
      handler,
      hooks: lifeCycleToFn2(hooks),
      validator,
      handleError: app.handleError,
      utils: {
        mapResponse: mapResponse2,
        mapCompactResponse: mapCompactResponse2,
        mapEarlyResponse: mapEarlyResponse2,
        parseQuery: import_fast_querystring3.parse,
        isNotEmpty: isNotEmpty2
      },
      error: {
        NotFoundError: NotFoundError2,
        ValidationError: ValidationError2,
        InternalServerError: InternalServerError2,
        ParseError: ParseError2
      },
      schema: app.router.history,
      definitions: app.definitions.type,
      ERROR_CODE: ERROR_CODE2,
      getReporter: () => app.reporter,
      requestId: requestId2,
      parseCookie: parseCookie2,
      signCookie: signCookie2,
      decodeURIComponent: import_fast_decode_uri_component22.default,
      ELYSIA_RESPONSE: ELYSIA_RESPONSE2
    });
  };
  var composeGeneralHandler2 = (app) => {
    const inference = {
      event: {
        ...app.inference.event,
        queries: [...app.inference.event.queries]
      },
      trace: { ...app.inference.trace }
    };
    let decoratorsLiteral = "";
    let fnLiteral = "";
    const defaultHeaders = app.setHeaders;
    for (const key of Object.keys(app.singleton.decorator))
      decoratorsLiteral += `,${key}: app.singleton.decorator.${key}`;
    const router = app.router;
    const hasTrace = app.event.trace.length > 0;
    let findDynamicRoute = `
	const route = router.find(request.method, path) ${router.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${app.event.error.length ? `app.handleError(ctx, notFound)` : app.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params
`;
    const shouldPrecompile = app.config.precompile === true || typeof app.config.precompile === "object" && app.config.precompile.compose === true;
    if (!shouldPrecompile)
      findDynamicRoute += `
			if(route.store.composed)
				return route.store.composed(ctx)

			if(route.store.compose)
				return (route.store.compose())(ctx)`;
    else
      findDynamicRoute += `return route.store(ctx)`;
    findDynamicRoute += "\n";
    let switchMap = ``;
    for (const [path, { code, all }] of Object.entries(router.static.http.map))
      switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? `default: break map`}}

`;
    const maybeAsync = app.event.request.some(isAsync2);
    const init = `

	const url = request.url
	const s = url.indexOf('/', 11)
	const qi = url.indexOf('?', s + 1)
	let path
	if(qi === -1)
		path = url.substring(s)
	else
		path = url.substring(s, qi)
`;
    fnLiteral += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError,
		error,
		redirect
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const wsRouter = app.router.ws
	const router = app.router.http

	const notFound = new NotFoundError()

	${app.event.request.length ? `const onRequest = app.event.request.map(x => x.fn)` : ""}
	${router.static.http.variables}
	${app.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${maybeAsync ? "async" : ""} function map(request) {
`;
    if (app.event.request.length)
      fnLiteral += `let re`;
    const report = createReport2({
      hasTrace,
      hasTraceSet: inference.trace.set,
      condition: {
        request: inference.trace.request
      },
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    if (app.event.request.length) {
      fnLiteral += `
			${hasTrace ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				redirect,
				set: {
					headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				},
				error
				${hasTrace ? ",$$requestId: +id" : ""}
				${decoratorsLiteral}
			}
		`;
      const endReport = report("request", {
        attribute: "ctx",
        unit: app.event.request.length
      });
      fnLiteral += `
 try {
`;
      for (let i = 0;i < app.event.request.length; i++) {
        const hook = app.event.request[i];
        const withReturn = hasReturn2(hook.fn.toString());
        const maybeAsync2 = isAsync2(hook);
        const endUnit = report("request.unit", {
          name: app.event.request[i].fn.name
        });
        if (withReturn) {
          fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
					ctx.set,
					request
				)
`;
          endUnit();
          fnLiteral += `if(re !== undefined) return re
`;
        } else {
          fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)
`;
          endUnit();
        }
      }
      fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
      endReport();
      fnLiteral += init;
      fnLiteral += `
ctx.qi = qi
 ctx.path = path
ctx.url=url`;
    } else {
      fnLiteral += init;
      fnLiteral += `${hasTrace ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${hasTrace ? ",$$requestId: id" : ""}
			${decoratorsLiteral}
		}`;
      report("request", {
        unit: app.event.request.length,
        attribute: inference.trace.context || inference.trace.store || inference.trace.set ? "ctx" : ""
      })();
    }
    const wsPaths = app.router.static.ws;
    const wsRouter = app.router.ws;
    if (Object.keys(wsPaths).length || wsRouter.history.length) {
      fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
      for (const [path, index] of Object.entries(wsPaths)) {
        fnLiteral += `
					case '${path}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${index}(ctx)

						break`;
      }
      fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`;
    }
    fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}`;
    const handleError = composeErrorHandler2(app);
    app.handleError = handleError;
    return Function("data", fnLiteral)({
      app,
      mapEarlyResponse: mapEarlyResponse2,
      NotFoundError: NotFoundError2,
      getReporter: () => app.reporter,
      requestId: requestId2,
      handleError,
      error: error23,
      redirect: redirect2
    });
  };
  var composeErrorHandler2 = (app) => {
    let fnLiteral = `const {
		app: { event: { error: onErrorContainer, onResponse: resContainer } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${app.event.error.find(isAsync2) ? "async" : ""} function(context, error, skipGlobal) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(typeof error === "object" && ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
    for (let i = 0;i < app.event.error.length; i++) {
      const handler = app.event.error[i];
      const response = `${isAsync2(handler) ? "await " : ""}onError[${i}](context)`;
      fnLiteral += "\nif(skipGlobal !== true) {\n";
      if (hasReturn2(handler.fn.toString()))
        fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status
				return mapResponse(r, set, context.request)
			}
`;
      else
        fnLiteral += response + "\n";
      fnLiteral += "\n}\n";
    }
    fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set, context.request)
	}
}`;
    return Function("inject", fnLiteral)({
      app,
      mapResponse: mapResponse2,
      ERROR_CODE: ERROR_CODE2,
      ELYSIA_RESPONSE: ELYSIA_RESPONSE2
    });
  };
  var jitRoute2 = (index) => `if(stc${index}) return stc${index}(ctx)
if(st${index}.compose) return (stc${index} = st${index}.compose())(ctx)

return st${index}(ctx)`;
  var import_fast_querystring22 = require_lib();
  var createDynamicHandler2 = (app) => async (request) => {
    const url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi);
    const set2 = {
      cookie: {},
      status: 200,
      headers: {}
    };
    const context = Object.assign({}, app.singleton.decorator, {
      set: set2,
      store: app.singleton.store,
      request,
      path,
      qi
    });
    try {
      for (let i = 0;i < app.event.request.length; i++) {
        const onRequest = app.event.request[i].fn;
        let response2 = onRequest(context);
        if (response2 instanceof Promise)
          response2 = await response2;
        response2 = mapEarlyResponse2(response2, set2);
        if (response2)
          return response2;
      }
      const handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw new NotFoundError2;
      const { handle, hooks, validator, content } = handler.store;
      let body;
      if (request.method !== "GET" && request.method !== "HEAD") {
        if (content) {
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = (0, import_fast_querystring22.parse)(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              const form = await request.formData();
              for (const key of form.keys()) {
                if (body[key])
                  continue;
                const value15 = form.getAll(key);
                if (value15.length === 1)
                  body[key] = value15[0];
                else
                  body[key] = value15;
              }
              break;
          }
        } else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            const index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            context.contentType = contentType;
            for (let i = 0;i < hooks.parse.length; i++) {
              const hook = hooks.parse[i].fn;
              let temp = hook(context, contentType);
              if (temp instanceof Promise)
                temp = await temp;
              if (temp) {
                body = temp;
                break;
              }
            }
            delete context.contentType;
            if (body === undefined) {
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = (0, import_fast_querystring22.parse)(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  const form = await request.formData();
                  for (const key of form.keys()) {
                    if (body[key])
                      continue;
                    const value15 = form.getAll(key);
                    if (value15.length === 1)
                      body[key] = value15[0];
                    else
                      body[key] = value15;
                  }
                  break;
              }
            }
          }
        }
      }
      context.body = body;
      context.params = handler?.params || undefined;
      context.query = qi === -1 ? {} : (0, import_fast_querystring22.parse)(url.substring(qi + 1));
      context.headers = {};
      for (const [key, value15] of request.headers.entries())
        context.headers[key] = value15;
      const cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config);
      const cookieHeaderValue = request.headers.get("cookie");
      context.cookie = await parseCookie2(context.set, cookieHeaderValue, cookieMeta ? {
        secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
        sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
      } : undefined);
      for (let i = 0;i < hooks.transform.length; i++) {
        const hook = hooks.transform[i];
        const operation = hook.fn(context);
        if (hook.subType === "derive") {
          if (operation instanceof Promise)
            Object.assign(context, await operation);
          else
            Object.assign(context, operation);
        } else if (operation instanceof Promise)
          await operation;
      }
      if (validator) {
        if (validator.headers) {
          const _header = {};
          for (const key in request.headers)
            _header[key] = request.headers.get(key);
          if (validator.headers.Check(_header) === false)
            throw new ValidationError2("header", validator.headers, _header);
        }
        if (validator.params?.Check(context.params) === false)
          throw new ValidationError2("params", validator.params, context.params);
        if (validator.query?.Check(context.query) === false)
          throw new ValidationError2("query", validator.query, context.query);
        if (validator.cookie) {
          const cookieValue = {};
          for (const [key, value15] of Object.entries(context.cookie))
            cookieValue[key] = value15.value;
          if (validator.cookie?.Check(cookieValue) === false)
            throw new ValidationError2("cookie", validator.cookie, cookieValue);
        }
        if (validator.body?.Check(body) === false)
          throw new ValidationError2("body", validator.body, body);
      }
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        let response2 = hooks.beforeHandle[i].fn(context);
        if (response2 instanceof Promise)
          response2 = await response2;
        if (response2 !== undefined) {
          context.response = response2;
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let newResponse = hooks.afterHandle[i2].fn(context);
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            if (newResponse)
              response2 = newResponse;
          }
          const result = mapEarlyResponse2(response2, context.set);
          if (result)
            return result;
        }
      }
      let response = handle(context);
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle.length) {
        const responseValidator = validator?.response?.[response.status];
        if (responseValidator?.Check(response) === false)
          throw new ValidationError2("response", responseValidator, response);
      } else {
        context.response = response;
        for (let i = 0;i < hooks.afterHandle.length; i++) {
          let newResponse = hooks.afterHandle[i].fn(context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          const result = mapEarlyResponse2(newResponse, context.set);
          if (result !== undefined) {
            const responseValidator = validator?.response?.[response.status];
            if (responseValidator?.Check(result) === false)
              throw new ValidationError2("response", responseValidator, result);
            return result;
          }
        }
      }
      if (context.set.cookie && cookieMeta?.sign) {
        const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true)
          for (const [key, cookie] of Object.entries(context.set.cookie))
            context.set.cookie[key].value = await signCookie2(cookie.value, "${secret}");
        else {
          const properties = validator?.cookie?.schema?.properties;
          for (const name of cookieMeta.sign) {
            if (!(name in properties))
              continue;
            if (context.set.cookie[name]?.value) {
              context.set.cookie[name].value = await signCookie2(context.set.cookie[name].value, secret);
            }
          }
        }
      }
      return mapResponse2(response, context.set);
    } catch (error24) {
      if (error24.status)
        set2.status = error24.status;
      return app.handleError(context, error24);
    } finally {
      for (const onResponse of app.event.onResponse)
        await onResponse.fn(context);
    }
  };
  var createDynamicErrorHandler2 = (app) => async (context, error24) => {
    const errorContext = Object.assign(context, { error: error24, code: error24.code });
    errorContext.set = context.set;
    for (let i = 0;i < app.event.error.length; i++) {
      const hook = app.event.error[i];
      let response = hook.fn(errorContext);
      if (response instanceof Promise)
        response = await response;
      if (response !== undefined && response !== null)
        return mapResponse2(response, context.set);
    }
    return new Response(typeof error24.cause === "string" ? error24.cause : error24.message, {
      headers: context.set.headers,
      status: error24.status ?? 500
    });
  };
  var import_typebox2 = require_require();
  var import_system = require_system2();
  var import_typebox3 = require_require();
  var import_value4 = require_value5();
  var fullFormats2 = {
    date: date6,
    time: getTime2(true),
    "date-time": getDateTime2(true),
    "iso-time": getTime2(false),
    "iso-date-time": getDateTime2(false),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri: uri2,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex: regex2,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte: byte2,
    int32: { type: "number", validate: validateInt322 },
    int64: { type: "number", validate: validateInt642 },
    float: { type: "number", validate: validateNumber2 },
    double: { type: "number", validate: validateNumber2 },
    password: true,
    binary: true
  };
  var DATE2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME2 = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  var DATE_TIME_SEPARATOR2 = /t|\s/i;
  var NOT_URI_FRAGMENT2 = /\/|:/;
  var URI2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var BYTE2 = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  var MIN_INT322 = -(2 ** 31);
  var MAX_INT322 = 2 ** 31 - 1;
  var Z_ANCHOR2 = /[^\\]\\Z/;
  var import_system2 = require_system2();
  var import_compiler2 = require_compiler2();
  var isISO86012 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
  var isFormalDate2 = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
  var isShortenDate2 = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
  var _validateDate2 = fullFormats2.date;
  var _validateDateTime2 = fullFormats2["date-time"];
  if (!import_typebox3.FormatRegistry.Has("date"))
    import_system.TypeSystem.Format("date", (value15) => {
      const temp = value15.replace(/"/g, "");
      if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDate2(temp)) {
        const date22 = new Date(temp);
        if (!Number.isNaN(date22.getTime()))
          return true;
      }
      return false;
    });
  if (!import_typebox3.FormatRegistry.Has("date-time"))
    import_system.TypeSystem.Format("date-time", (value15) => {
      const temp = value15.replace(/"/g, "");
      if (isISO86012.test(temp) || isFormalDate2.test(temp) || isShortenDate2.test(temp) || _validateDateTime2(temp)) {
        const date22 = new Date(temp);
        if (!Number.isNaN(date22.getTime()))
          return true;
      }
      return false;
    });
  Object.entries(fullFormats2).forEach((formatEntry) => {
    const [formatName, formatValue] = formatEntry;
    if (!import_typebox3.FormatRegistry.Has(formatName)) {
      if (formatValue instanceof RegExp)
        import_system.TypeSystem.Format(formatName, (value15) => formatValue.test(value15));
      else if (typeof formatValue === "function")
        import_system.TypeSystem.Format(formatName, formatValue);
    }
  });
  var t22 = Object.assign({}, import_typebox3.Type);
  var parseFileUnit2 = (size) => {
    if (typeof size === "string")
      switch (size.slice(-1)) {
        case "k":
          return +size.slice(0, size.length - 1) * 1024;
        case "m":
          return +size.slice(0, size.length - 1) * 1048576;
        default:
          return +size;
      }
    return size;
  };
  var validateFile2 = (options, value15) => {
    if (!(value15 instanceof Blob))
      return false;
    if (options.minSize && value15.size < parseFileUnit2(options.minSize))
      return false;
    if (options.maxSize && value15.size > parseFileUnit2(options.maxSize))
      return false;
    if (options.extension)
      if (typeof options.extension === "string") {
        if (!value15.type.startsWith(options.extension))
          return false;
      } else {
        for (let i = 0;i < options.extension.length; i++)
          if (value15.type.startsWith(options.extension[i]))
            return true;
        return false;
      }
    return true;
  };
  var File2 = import_typebox2.TypeRegistry.Get("Files") ?? import_system.TypeSystem.Type("File", validateFile2);
  var Files2 = import_typebox2.TypeRegistry.Get("Files") ?? import_system.TypeSystem.Type("Files", (options, value15) => {
    if (!Array.isArray(value15))
      return validateFile2(options, value15);
    if (options.minItems && value15.length < options.minItems)
      return false;
    if (options.maxItems && value15.length > options.maxItems)
      return false;
    for (let i = 0;i < value15.length; i++)
      if (!validateFile2(options, value15[i]))
        return false;
    return true;
  });
  if (!import_typebox3.FormatRegistry.Has("numeric"))
    import_typebox3.FormatRegistry.Set("numeric", (value15) => !!value15 && !isNaN(+value15));
  if (!import_typebox3.FormatRegistry.Has("boolean"))
    import_typebox3.FormatRegistry.Set("boolean", (value15) => value15 === "true" || value15 === "false");
  if (!import_typebox3.FormatRegistry.Has("ObjectString"))
    import_typebox3.FormatRegistry.Set("ObjectString", (value15) => {
      let start = value15.charCodeAt(0);
      if (start === 9 || start === 10 || start === 32)
        start = value15.trimStart().charCodeAt(0);
      if (start !== 123 && start !== 91)
        return false;
      try {
        JSON.parse(value15);
        return true;
      } catch {
        return false;
      }
    });
  var ElysiaType2 = {
    Numeric: (property) => {
      const schema3 = import_typebox3.Type.Number(property);
      return t22.Transform(t22.Union([
        t22.String({
          format: "numeric",
          default: 0
        }),
        t22.Number(property)
      ], property)).Decode((value15) => {
        const number7 = +value15;
        if (isNaN(number7))
          return value15;
        if (property && !import_value4.Value.Check(schema3, number7))
          throw new ValidationError2("property", schema3, number7);
        return number7;
      }).Encode((value15) => value15);
    },
    Date: (property) => {
      const schema3 = import_typebox3.Type.Date(property);
      return t22.Transform(t22.Union([
        import_typebox3.Type.Date(property),
        t22.String({
          format: "date",
          default: (new Date()).toISOString()
        }),
        t22.String({
          format: "date-time",
          default: (new Date()).toISOString()
        })
      ], property)).Decode((value15) => {
        if (value15 instanceof Date)
          return value15;
        const date22 = new Date(value15);
        if (!import_value4.Value.Check(schema3, date22))
          throw new ValidationError2("property", schema3, date22);
        return date22;
      }).Encode((value15) => {
        if (typeof value15 === "string")
          return new Date(value15);
        return value15;
      });
    },
    BooleanString: (property) => {
      const schema3 = import_typebox3.Type.Boolean(property);
      return t22.Transform(t22.Union([
        t22.String({
          format: "boolean",
          default: false
        }),
        t22.Boolean(property)
      ], property)).Decode((value15) => {
        if (typeof value15 === "string")
          return value15 === "true";
        if (property && !import_value4.Value.Check(schema3, value15))
          throw new ValidationError2("property", schema3, value15);
        return value15;
      }).Encode((value15) => value15);
    },
    ObjectString: (properties = {}, options) => {
      const schema3 = t22.Object(properties, options);
      const defaultValue = JSON.stringify(import_value4.Value.Create(schema3));
      return t22.Transform(t22.Union([
        t22.String({
          format: "ObjectString",
          default: defaultValue
        }),
        schema3
      ])).Decode((value15) => {
        if (typeof value15 === "string") {
          try {
            value15 = JSON.parse(value15);
          } catch {
            throw new ValidationError2("property", schema3, value15);
          }
          if (!import_value4.Value.Check(schema3, value15))
            throw new ValidationError2("property", schema3, value15);
          return value15;
        }
        return value15;
      }).Encode((value15) => {
        if (typeof value15 === "string")
          try {
            value15 = JSON.parse(value15);
          } catch {
            throw new ValidationError2("property", schema3, value15);
          }
        if (!import_value4.Value.Check(schema3, value15))
          throw new ValidationError2("property", schema3, value15);
        return JSON.stringify(value15);
      });
    },
    File: File2,
    Files: (options = {}) => t22.Transform(Files2(options)).Decode((value15) => {
      if (Array.isArray(value15))
        return value15;
      return [value15];
    }).Encode((value15) => value15),
    Nullable: (schema3) => t22.Union([t22.Null(), schema3]),
    MaybeEmpty: (schema3) => t22.Union([t22.Null(), t22.Undefined(), schema3]),
    Cookie: (properties, {
      domain,
      expires,
      httpOnly,
      maxAge,
      path,
      priority,
      sameSite,
      secure,
      secrets,
      sign,
      ...options
    } = {}) => {
      const v = t22.Object(properties, options);
      v.config = {
        domain,
        expires,
        httpOnly,
        maxAge,
        path,
        priority,
        sameSite,
        secure,
        secrets,
        sign
      };
      return v;
    }
  };
  t22.BooleanString = ElysiaType2.BooleanString;
  t22.ObjectString = ElysiaType2.ObjectString;
  t22.Numeric = ElysiaType2.Numeric;
  t22.File = (arg = {}) => ElysiaType2.File({
    default: "File",
    ...arg,
    extension: arg?.type,
    type: "string",
    format: "binary"
  });
  t22.Files = (arg = {}) => ElysiaType2.Files({
    ...arg,
    elysiaMeta: "Files",
    default: "Files",
    extension: arg?.type,
    type: "array",
    items: {
      ...arg,
      default: "Files",
      type: "string",
      format: "binary"
    }
  });
  t22.Nullable = (schema3) => ElysiaType2.Nullable(schema3);
  t22.MaybeEmpty = ElysiaType2.MaybeEmpty;
  t22.Cookie = ElysiaType2.Cookie;
  t22.Date = ElysiaType2.Date;
  var Elysia2 = class _Elysia2 {
    constructor(config) {
      this.server = null;
      this.dependencies = {};
      this.reporter = new import_eventemitter32.default;
      this._routes = {};
      this._types = {
        Prefix: "",
        Scoped: false,
        Singleton: {},
        Definitions: {},
        Metadata: {}
      };
      this._ephemeral = {};
      this._volatile = {};
      this.singleton = {
        decorator: {},
        store: {},
        derive: {},
        resolve: {}
      };
      this.definitions = {
        type: {},
        error: {}
      };
      this.extender = {
        macros: []
      };
      this.validator = null;
      this.event = {
        start: [],
        request: [],
        parse: [],
        transform: [],
        beforeHandle: [],
        afterHandle: [],
        mapResponse: [],
        onResponse: [],
        trace: [],
        error: [],
        stop: []
      };
      this.telemetry = {
        stack: undefined
      };
      this.router = {
        http: new Memoirist2,
        ws: new Memoirist2,
        dynamic: new Memoirist2,
        static: {
          http: {
            handlers: [],
            variables: "",
            map: {},
            all: ""
          },
          ws: {}
        },
        history: []
      };
      this.inference = {
        event: {
          body: false,
          cookie: false,
          headers: false,
          queries: [],
          query: false,
          set: false,
          unknownQueries: false
        },
        trace: {
          request: false,
          parse: false,
          transform: false,
          handle: false,
          beforeHandle: false,
          afterHandle: false,
          error: false,
          context: false,
          store: false,
          set: false
        }
      };
      this.promisedModules = new PromiseGroup2;
      this.routeTree = new Map;
      this.handle = async (request) => this.fetch(request);
      this.fetch = (request) => {
        if (false)
          ;
        return (this.fetch = this.config.aot ? composeGeneralHandler2(this) : createDynamicHandler2(this))(request);
      };
      this.handleError = async (context, error24) => (this.handleError = this.config.aot ? composeErrorHandler2(this) : createDynamicErrorHandler2(this))(context, error24);
      this.outerErrorHandler = (error24) => new Response(error24.message || error24.name || "Error", {
        status: error24?.status ?? 500
      });
      this.listen = (options, callback) => {
        if (typeof Bun === "undefined")
          throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
        this.compile();
        if (typeof options === "string") {
          if (!isNumericString2(options))
            throw new Error("Port must be a numeric value");
          options = parseInt(options);
        }
        const fetch2 = this.fetch;
        const serve = typeof options === "object" ? {
          development: !isProduction2,
          reusePort: true,
          ...this.config.serve || {},
          ...options || {},
          websocket: {
            ...this.config.websocket || {},
            ...websocket2 || {}
          },
          fetch: fetch2,
          error: this.outerErrorHandler
        } : {
          development: !isProduction2,
          reusePort: true,
          ...this.config.serve || {},
          websocket: {
            ...this.config.websocket || {},
            ...websocket2 || {}
          },
          port: options,
          fetch: fetch2,
          error: this.outerErrorHandler
        };
        this.server = Bun?.serve(serve);
        for (let i = 0;i < this.event.start.length; i++)
          this.event.start[i].fn(this);
        if (callback)
          callback(this.server);
        process.on("beforeExit", () => {
          if (this.server) {
            this.server.stop();
            this.server = null;
            for (let i = 0;i < this.event.stop.length; i++)
              this.event.stop[i].fn(this);
          }
        });
        this.promisedModules.then(() => {
          Bun?.gc(false);
        });
        return this;
      };
      this.stop = async () => {
        if (!this.server)
          throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
        if (this.server) {
          this.server.stop();
          this.server = null;
          if (this.event.stop.length)
            for (let i = 0;i < this.event.stop.length; i++)
              this.event.stop[i].fn(this);
        }
      };
      if (config?.tags) {
        if (!config.detail)
          config.detail = {
            tags: config.tags
          };
        else
          config.detail.tags = config.tags;
      }
      this.config = {
        forceErrorEncapsulation: true,
        prefix: "",
        aot: true,
        strictPath: false,
        global: false,
        cookie: {},
        analytic: false,
        ...config,
        experimental: config?.experimental ?? {},
        seed: config?.seed === undefined ? "" : config?.seed
      };
      if (config?.analytic && (config?.name || config?.seed !== undefined))
        this.telemetry.stack = new Error().stack;
    }
    get store() {
      return this.singleton.store;
    }
    get decorator() {
      return this.singleton.decorator;
    }
    get _scoped() {
      return this.config.scoped;
    }
    getServer() {
      return this.server;
    }
    get routes() {
      return this.router.history;
    }
    applyMacro(localHook) {
      if (this.extender.macros.length) {
        const manage = createMacroManager2({
          globalHook: this.event,
          localHook
        });
        const manager = {
          events: {
            global: this.event,
            local: localHook
          },
          onParse: manage("parse"),
          onTransform: manage("transform"),
          onBeforeHandle: manage("beforeHandle"),
          onAfterHandle: manage("afterHandle"),
          onResponse: manage("onResponse"),
          mapResponse: manage("mapResponse"),
          onError: manage("error")
        };
        for (const macro of this.extender.macros)
          traceBackMacro2(macro.fn(manager), localHook);
      }
    }
    add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = {
      allowMeta: false,
      skipPrefix: false
    }) {
      localHook = localHookToLifeCycleStore2(localHook);
      if (path !== "" && path.charCodeAt(0) !== 47)
        path = "/" + path;
      if (this.config.prefix && !skipPrefix && !this.config.scoped)
        path = this.config.prefix + path;
      if (localHook?.type)
        switch (localHook.type) {
          case "text":
            localHook.type = "text/plain";
            break;
          case "json":
            localHook.type = "application/json";
            break;
          case "formdata":
            localHook.type = "multipart/form-data";
            break;
          case "urlencoded":
            localHook.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            localHook.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const models = this.definitions.type;
      let _body, _headers, _params, _query, _cookie, _response;
      const dynamic = !this.config.aot;
      const cloned = {
        body: localHook?.body ?? this.validator?.body,
        headers: localHook?.headers ?? this.validator?.headers,
        params: localHook?.params ?? this.validator?.params,
        query: localHook?.query ?? this.validator?.query,
        cookie: localHook?.cookie ?? this.validator?.cookie,
        response: localHook?.response ?? this.validator?.response
      };
      const cookieValidator = () => cloned.cookie ? getCookieValidator2({
        validator: cloned.cookie,
        defaultConfig: this.config.cookie,
        config: cloned.cookie?.config ?? {},
        dynamic,
        models
      }) : undefined;
      const normalize = this.config.normalize;
      const validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? {
        body: getSchemaValidator2(cloned.body, {
          dynamic,
          models,
          normalize
        }),
        headers: getSchemaValidator2(cloned.headers, {
          dynamic,
          models,
          additionalProperties: true
        }),
        params: getSchemaValidator2(cloned.params, {
          dynamic,
          models
        }),
        query: getSchemaValidator2(cloned.query, {
          dynamic,
          models,
          normalize
        }),
        cookie: cookieValidator(),
        response: getResponseSchemaValidator2(cloned.response, {
          dynamic,
          models,
          normalize
        })
      } : {
        get body() {
          if (_body)
            return _body;
          return _body = getSchemaValidator2(cloned.body, {
            dynamic,
            models,
            normalize
          });
        },
        get headers() {
          if (_headers)
            return _headers;
          return getSchemaValidator2(cloned.headers, {
            dynamic,
            models,
            additionalProperties: true
          });
        },
        get params() {
          if (_params)
            return _params;
          return _params = getSchemaValidator2(cloned.params, {
            dynamic,
            models
          });
        },
        get query() {
          if (_query)
            return _query;
          return _query = getSchemaValidator2(cloned.query, {
            dynamic,
            models
          });
        },
        get cookie() {
          if (_cookie)
            return _cookie;
          return _cookie = cookieValidator();
        },
        get response() {
          if (_response)
            return _response;
          return _response = getResponseSchemaValidator2(cloned.response, {
            dynamic,
            models,
            normalize
          });
        }
      };
      const loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
      localHook = mergeHook2(localHook, {}, { allowMacro: true });
      if (localHook.tags) {
        if (!localHook.detail)
          localHook.detail = {
            tags: localHook.tags
          };
        else
          localHook.detail.tags = localHook.tags;
      }
      if (isNotEmpty2(this.config.detail))
        localHook.detail = mergeDeep2(Object.assign({}, this.config.detail), localHook.detail);
      this.applyMacro(localHook);
      const hooks = mergeHook2(this.event, localHook);
      if (this.config.aot === false) {
        this.router.dynamic.add(method, path, {
          validator,
          hooks,
          content: localHook?.type,
          handle
        });
        if (this.config.strictPath === false) {
          this.router.dynamic.add(method, loosePath, {
            validator,
            hooks,
            content: localHook?.type,
            handle
          });
        }
        this.router.history.push({
          method,
          path,
          composed: null,
          handler: handle,
          hooks
        });
        return;
      }
      let composed = undefined;
      const shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true;
      const appInference = cloneInference2(this.inference);
      const mainHandler = shouldPrecompile ? composeHandler2({
        app: this,
        path,
        method,
        localHook: mergeHook2(localHook),
        hooks,
        validator,
        handler: handle,
        allowMeta,
        appInference
      }) : (context) => {
        if (composed)
          return composed(context);
        return (composed = composeHandler2({
          app: this,
          path,
          method,
          localHook: mergeHook2(localHook),
          hooks,
          validator,
          handler: handle,
          allowMeta,
          appInference
        }))(context);
      };
      if (!shouldPrecompile)
        mainHandler.compose = () => {
          return mainHandler.composed = composeHandler2({
            app: this,
            path,
            method,
            localHook: mergeHook2(localHook),
            hooks,
            validator,
            handler: handle,
            allowMeta,
            appInference
          });
        };
      let routeIndex = this.router.history.length;
      if (this.routeTree.has(method + path)) {
        routeIndex = this.router.history.findIndex((route) => route.path === path && route.method === method);
        if (routeIndex !== -1) {
          const removed = this.router.history.splice(routeIndex, 1)[0];
          if (removed && this.routeTree.has(removed?.method + removed?.path))
            this.routeTree.delete(removed.method + removed.path);
        }
      }
      this.routeTree.set(method + path, routeIndex);
      this.router.history.push({
        method,
        path,
        composed: mainHandler,
        handler: handle,
        hooks
      });
      const staticRouter = this.router.static.http;
      if (method === "$INTERNALWS") {
        const loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
        if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
          const index = staticRouter.handlers.length;
          staticRouter.handlers.push(mainHandler);
          staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
          this.router.static.ws[path] = index;
          if (loose)
            this.router.static.ws[loose] = index;
        } else {
          this.router.ws.add("ws", path, mainHandler);
          if (loose)
            this.router.ws.add("ws", loose, mainHandler);
        }
        return;
      }
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
        const index = staticRouter.handlers.length;
        staticRouter.handlers.push(mainHandler);
        staticRouter.variables += shouldPrecompile ? `const st${index} = staticRouter.handlers[${index}]
` : `let st${index} = staticRouter.handlers[${index}]
let stc${index}
`;
        if (!staticRouter.map[path])
          staticRouter.map[path] = {
            code: ""
          };
        if (method === "ALL")
          staticRouter.map[path].all = shouldPrecompile ? `default: return st${index}(ctx)
` : `default: ${jitRoute2(index)}
`;
        else
          staticRouter.map[path].code = shouldPrecompile ? `case '${method}': return st${index}(ctx)
${staticRouter.map[path].code}` : `case '${method}': ${jitRoute2(index)}
${staticRouter.map[path].code}`;
        if (!this.config.strictPath) {
          if (!staticRouter.map[loosePath])
            staticRouter.map[loosePath] = {
              code: ""
            };
          if (method === "ALL")
            staticRouter.map[loosePath].all = shouldPrecompile ? `default: return st${index}(ctx)
` : `default: ${jitRoute2(index)}
`;
          else
            staticRouter.map[loosePath].code = shouldPrecompile ? `case '${method}': return st${index}(ctx)
${staticRouter.map[loosePath].code}` : `case '${method}': ${jitRoute2(index)}
${staticRouter.map[loosePath].code}`;
        }
      } else {
        this.router.http.add(method, path, mainHandler);
        if (!this.config.strictPath)
          this.router.http.add(method, path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/", mainHandler);
      }
    }
    headers(header) {
      if (!header)
        return this;
      if (!this.setHeaders)
        this.setHeaders = {};
      this.setHeaders = mergeDeep2(this.setHeaders, header);
      return this;
    }
    onStart(handler) {
      this.on("start", handler);
      return this;
    }
    onRequest(handler) {
      this.on("request", handler);
      return this;
    }
    onParse(options, handler) {
      if (!handler)
        return this.on("parse", options);
      return this.on(options, "parse", handler);
    }
    onTransform(options, handler) {
      if (!handler)
        return this.on("transform", options);
      return this.on(options, "transform", handler);
    }
    resolve(optionsOrResolve, resolve) {
      if (!resolve) {
        resolve = optionsOrResolve;
        optionsOrResolve = { as: "local" };
      }
      const hook = {
        subType: "resolve",
        fn: resolve
      };
      return this.onBeforeHandle(optionsOrResolve, hook);
    }
    mapResolve(optionsOrResolve, mapper) {
      if (!mapper) {
        mapper = optionsOrResolve;
        optionsOrResolve = { as: "local" };
      }
      const hook = {
        subType: "resolve",
        fn: mapper
      };
      return this.onBeforeHandle(optionsOrResolve, hook);
    }
    onBeforeHandle(options, handler) {
      if (!handler)
        return this.on("beforeHandle", options);
      return this.on(options, "beforeHandle", handler);
    }
    onAfterHandle(options, handler) {
      if (!handler)
        return this.on("afterHandle", options);
      return this.on(options, "afterHandle", handler);
    }
    mapResponse(options, handler) {
      if (!handler)
        return this.on("mapResponse", options);
      return this.on(options, "mapResponse", handler);
    }
    onResponse(options, handler) {
      if (!handler)
        return this.on("response", options);
      return this.on(options, "response", handler);
    }
    trace(options, handler) {
      if (!handler) {
        handler = options;
        options = { as: "local" };
      }
      if (!Array.isArray(handler))
        handler = [handler];
      for (const fn of handler)
        this.reporter.on("event", createTraceListener2(() => this.reporter, this.event.trace.length, fn));
      this.on(options, "trace", handler);
      return this;
    }
    error(name, error24) {
      switch (typeof name) {
        case "string":
          error24.prototype[ERROR_CODE2] = name;
          this.definitions.error[name] = error24;
          return this;
        case "function":
          this.definitions.error = name(this.definitions.error);
          return this;
      }
      for (const [code, error32] of Object.entries(name)) {
        error32.prototype[ERROR_CODE2] = code;
        this.definitions.error[code] = error32;
      }
      return this;
    }
    onError(options, handler) {
      if (!handler)
        return this.on("error", options);
      return this.on(options, "error", handler);
    }
    onStop(handler) {
      this.on("stop", handler);
      return this;
    }
    on(optionsOrType, typeOrHandlers, handlers) {
      let type74;
      switch (typeof optionsOrType) {
        case "string":
          type74 = optionsOrType;
          handlers = typeOrHandlers;
          break;
        case "object":
          type74 = typeOrHandlers;
          break;
      }
      if (type74 === "response")
        type74 = "onResponse";
      if (Array.isArray(handlers))
        handlers = fnToContainer2(handlers);
      else {
        if (typeof handlers === "function")
          handlers = [
            {
              fn: handlers
            }
          ];
        else
          handlers = [handlers];
      }
      const handles = handlers;
      for (const handle of handles)
        handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
      if (type74 === "trace")
        sucroseTrace2(handles.map((x) => x.fn), this.inference.trace);
      else
        sucrose2({
          [type74]: handles.map((x) => x.fn)
        }, this.inference.event);
      for (const handle of handles) {
        const fn = asHookType2(handle, "global", { skipIfHasType: true });
        switch (type74) {
          case "start":
            this.event.start.push(fn);
            break;
          case "request":
            this.event.request.push(fn);
            break;
          case "parse":
            this.event.parse.push(fn);
            break;
          case "transform":
            this.event.transform.push(fn);
            break;
          case "beforeHandle":
            this.event.beforeHandle.push(fn);
            break;
          case "afterHandle":
            this.event.afterHandle.push(fn);
            break;
          case "mapResponse":
            this.event.mapResponse.push(fn);
            break;
          case "onResponse":
            this.event.onResponse.push(fn);
            break;
          case "trace":
            this.event.trace.push(fn);
            break;
          case "error":
            this.event.error.push(fn);
            break;
          case "stop":
            this.event.stop.push(fn);
            break;
        }
      }
      return this;
    }
    propagate() {
      const promoteEvent = (events) => {
        for (const event of events) {
          if ("scope" in event && event.scope === "local")
            event.scope = "scoped";
        }
      };
      promoteEvent(this.event.parse);
      promoteEvent(this.event.transform);
      promoteEvent(this.event.beforeHandle);
      promoteEvent(this.event.afterHandle);
      promoteEvent(this.event.mapResponse);
      promoteEvent(this.event.onResponse);
      promoteEvent(this.event.trace);
      promoteEvent(this.event.error);
      return this;
    }
    group(prefix, schemaOrRun, run) {
      const instance = new _Elysia2({
        ...this.config,
        prefix: ""
      });
      instance.singleton = { ...this.singleton };
      instance.definitions = { ...this.definitions };
      instance.getServer = () => this.server;
      instance.inference = cloneInference2(this.inference);
      instance.extender = { ...this.extender };
      const isSchema = typeof schemaOrRun === "object";
      const sandbox = (isSchema ? run : schemaOrRun)(instance);
      this.singleton = mergeDeep2(this.singleton, instance.singleton);
      this.definitions = mergeDeep2(this.definitions, instance.definitions);
      if (sandbox.event.request.length)
        this.event.request = [
          ...this.event.request || [],
          ...sandbox.event.request || []
        ];
      if (sandbox.event.onResponse.length)
        this.event.onResponse = [
          ...this.event.onResponse || [],
          ...sandbox.event.onResponse || []
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
        path = (isSchema ? "" : this.config.prefix) + prefix + path;
        if (isSchema) {
          const hook = schemaOrRun;
          const localHook = hooks;
          this.add(method, path, handler, mergeHook2(hook, {
            ...localHook || {},
            error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
              ...localHook.error || {},
              ...sandbox.event.error || {}
            ] : [
              localHook.error,
              ...sandbox.event.error || {}
            ]
          }));
        } else {
          this.add(method, path, handler, mergeHook2(hooks, {
            error: sandbox.event.error
          }), {
            skipPrefix: true
          });
        }
      });
      return this;
    }
    guard(hook, run) {
      if (!run) {
        if (typeof hook === "object") {
          this.applyMacro(hook);
          this.event = mergeLifeCycle2(this.event, hook);
          this.validator = {
            body: hook.body ?? this.validator?.body,
            headers: hook.headers ?? this.validator?.headers,
            params: hook.params ?? this.validator?.params,
            query: hook.query ?? this.validator?.query,
            response: hook.response ?? this.validator?.response,
            cookie: hook.cookie ?? this.validator?.cookie
          };
          if (hook.detail) {
            if (this.config.detail)
              this.config.detail = mergeDeep2(Object.assign({}, this.config.detail), hook.detail);
            else
              this.config.detail = hook.detail;
          }
          if (hook?.tags) {
            if (!this.config.detail)
              this.config.detail = {
                tags: hook.tags
              };
            else
              this.config.detail.tags = hook.tags;
          }
          return this;
        }
        return this.guard({}, hook);
      }
      const instance = new _Elysia2({
        ...this.config,
        prefix: ""
      });
      instance.singleton = { ...this.singleton };
      instance.definitions = { ...this.definitions };
      instance.inference = cloneInference2(this.inference);
      instance.extender = { ...this.extender };
      const sandbox = run(instance);
      this.singleton = mergeDeep2(this.singleton, instance.singleton);
      this.definitions = mergeDeep2(this.definitions, instance.definitions);
      sandbox.getServer = () => this.server;
      if (sandbox.event.request.length)
        this.event.request = [
          ...this.event.request || [],
          ...sandbox.event.request || []
        ];
      if (sandbox.event.onResponse.length)
        this.event.onResponse = [
          ...this.event.onResponse || [],
          ...sandbox.event.onResponse || []
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
        this.add(method, path, handler, mergeHook2(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || []
          ] : [
            localHook.error,
            ...sandbox.event.error || []
          ]
        }, {
          allowMacro: true
        }));
      });
      return this;
    }
    use(plugin, options) {
      if (options?.scoped)
        return this.guard({}, (app) => app.use(plugin));
      if (Array.isArray(plugin)) {
        let current = this;
        for (const p of plugin)
          current = this.use(p);
        return current;
      }
      if (plugin instanceof Promise) {
        this.promisedModules.add(plugin.then((plugin2) => {
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (plugin2 instanceof _Elysia2)
            return this._use(plugin2);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          if (plugin2.default instanceof _Elysia2)
            return this._use(plugin2.default);
          throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
        }).then((x) => x.compile()));
        return this;
      }
      return this._use(plugin);
    }
    _use(plugin) {
      if (typeof plugin === "function") {
        const instance = plugin(this);
        if (instance instanceof Promise) {
          this.promisedModules.add(instance.then((plugin2) => {
            if (plugin2 instanceof _Elysia2) {
              this.compile();
              for (const {
                method,
                path,
                handler,
                hooks
              } of Object.values(plugin2.router.history)) {
                this.add(method, path, handler, mergeHook2(hooks, {
                  error: plugin2.event.error
                }));
              }
              return plugin2;
            }
            if (typeof plugin2 === "function")
              return plugin2(this);
            if (typeof plugin2.default === "function")
              return plugin2.default(this);
            return this._use(plugin2);
          }).then((x) => x.compile()));
          return this;
        }
        return instance;
      }
      if (plugin.promisedModules.size) {
        this.promisedModules.add(plugin.modules.then(() => this._use(plugin)).then((x) => x.compile()));
        return this;
      }
      const { name, seed } = plugin.config;
      plugin.getServer = () => this.getServer();
      plugin.model(this.definitions.type);
      plugin.error(this.definitions.error);
      const isScoped = plugin.config.scoped;
      if (isScoped) {
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? checksum2(name + JSON.stringify(seed)) : 0;
          if (this.dependencies[name].some(({ checksum: checksum22 }) => current === checksum22))
            return this;
          this.dependencies[name].push(!this.config?.analytic ? {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies
          } : {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies,
            stack: plugin.telemetry.stack,
            routes: plugin.router.history,
            decorators: plugin.singleton.decorator,
            store: plugin.singleton.store,
            type: plugin.definitions.type,
            error: plugin.definitions.error,
            derive: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({
              fn: x.fn.toString(),
              stack: new Error().stack ?? ""
            })),
            resolve: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({
              fn: x.fn.toString(),
              stack: new Error().stack ?? ""
            }))
          });
        }
        plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
        const macroHashes = [];
        for (let i = 0;i < plugin.extender.macros.length; i++) {
          const macro = this.extender.macros[i];
          if (macroHashes.includes(macro.checksum)) {
            plugin.extender.macros.splice(i, 1);
            i--;
          }
          macroHashes.push(macro.checksum);
        }
        plugin.onRequest((context) => {
          Object.assign(context, this.singleton.decorator);
          Object.assign(context.store, this.singleton.store);
        });
        if (plugin.event.trace.length)
          plugin.event.trace.push(...plugin.event.trace);
        if (!plugin.config.prefix)
          console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
        if (plugin.event.error.length)
          plugin.event.error.push(...this.event.error);
        if (plugin.config.aot)
          plugin.compile();
        if (isScoped === true && plugin.config.prefix) {
          this.mount(plugin.config.prefix + "/", plugin.fetch);
          for (const route of plugin.router.history) {
            this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length);
            this.router.history.push({
              ...route,
              path: `${plugin.config.prefix}${route.path}`,
              hooks: mergeHook2(route.hooks, {
                error: this.event.error
              })
            });
          }
        } else {
          this.mount(plugin.fetch);
          for (const route of plugin.router.history) {
            this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length);
            this.router.history.push({
              ...route,
              path: `${plugin.config.prefix}${route.path}`,
              hooks: mergeHook2(route.hooks, {
                error: this.event.error
              })
            });
          }
        }
        return this;
      } else {
        this.headers(plugin.setHeaders);
        plugin.reporter = this.reporter;
        for (const trace of plugin.event.trace)
          if (trace.scope && trace.scope !== "local")
            this.trace(trace);
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? checksum2(name + JSON.stringify(seed)) : 0;
          if (!this.dependencies[name].some(({ checksum: checksum22 }) => current === checksum22))
            this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
        } else {
          this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
        }
        const macroHashes = [];
        for (let i = 0;i < this.extender.macros.length; i++) {
          const macro = this.extender.macros[i];
          if (macro.checksum) {
            if (macroHashes.includes(macro.checksum)) {
              this.extender.macros.splice(i, 1);
              i--;
            }
            macroHashes.push(macro.checksum);
          }
        }
        this.inference = {
          event: {
            body: this.inference.event.body || plugin.inference.event.body,
            cookie: this.inference.event.cookie || plugin.inference.event.cookie,
            headers: this.inference.event.headers || plugin.inference.event.headers,
            queries: [
              ...this.inference.event.queries,
              ...plugin.inference.event.queries
            ],
            query: this.inference.event.query || plugin.inference.event.query,
            set: this.inference.event.set || plugin.inference.event.set,
            unknownQueries: this.inference.event.unknownQueries || plugin.inference.event.unknownQueries
          },
          trace: {
            request: this.inference.trace.request || plugin.inference.trace.request,
            parse: this.inference.trace.parse || plugin.inference.trace.parse,
            transform: this.inference.trace.transform || plugin.inference.trace.transform,
            handle: this.inference.trace.handle || plugin.inference.trace.handle,
            beforeHandle: this.inference.trace.beforeHandle || plugin.inference.trace.beforeHandle,
            afterHandle: this.inference.trace.afterHandle || plugin.inference.trace.afterHandle,
            error: this.inference.trace.error || plugin.inference.trace.error,
            context: this.inference.trace.context || plugin.inference.trace.context,
            store: this.inference.trace.store || plugin.inference.trace.store,
            set: this.inference.trace.set || plugin.inference.trace.set
          }
        };
      }
      this.decorate(plugin.singleton.decorator);
      this.state(plugin.singleton.store);
      this.model(plugin.definitions.type);
      this.error(plugin.definitions.error);
      for (const { method, path, handler, hooks } of Object.values(plugin.router.history)) {
        this.add(method, path, handler, mergeHook2(hooks, {
          error: plugin.event.error
        }));
      }
      if (!isScoped)
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? checksum2(name + JSON.stringify(seed)) : 0;
          if (this.dependencies[name].some(({ checksum: checksum22 }) => current === checksum22))
            return this;
          this.dependencies[name].push(!this.config?.analytic ? {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies
          } : {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies,
            stack: plugin.telemetry.stack,
            routes: plugin.router.history,
            decorators: plugin.singleton,
            store: plugin.singleton.store,
            type: plugin.definitions.type,
            error: plugin.definitions.error,
            derive: plugin.event.transform.filter((x) => x?.subType === "derive").map((x) => ({
              fn: x.toString(),
              stack: new Error().stack ?? ""
            })),
            resolve: plugin.event.transform.filter((x) => x?.subType === "resolve").map((x) => ({
              fn: x.toString(),
              stack: new Error().stack ?? ""
            }))
          });
          this.event = mergeLifeCycle2(this.event, filterGlobalHook2(plugin.event), current);
        } else {
          this.event = mergeLifeCycle2(this.event, filterGlobalHook2(plugin.event));
        }
      return this;
    }
    macro(macro) {
      const hook = {
        checksum: checksum2(JSON.stringify({
          name: this.config.name,
          seed: this.config.seed,
          content: macro.toString()
        })),
        fn: macro
      };
      this.extender.macros.push(hook);
      return this;
    }
    mount(path, handle) {
      if (path instanceof _Elysia2 || typeof path === "function" || path.length === 0 || path === "/") {
        const run = typeof path === "function" ? path : path instanceof _Elysia2 ? path.compile().fetch : handle instanceof _Elysia2 ? handle.compile().fetch : handle;
        const handler2 = async ({ request, path: path2 }) => run(new Request(replaceUrlPath2(request.url, path2 || "/"), request));
        this.all("/*", handler2, {
          type: "none"
        });
        return this;
      }
      const length = path.length;
      if (handle instanceof _Elysia2)
        handle = handle.compile().fetch;
      const handler = async ({ request, path: path2 }) => handle(new Request(replaceUrlPath2(request.url, path2.slice(length) || "/"), request));
      this.all(path, handler, {
        type: "none"
      });
      this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
        type: "none"
      });
      return this;
    }
    get(path, handler, hook) {
      this.add("GET", path, handler, hook);
      return this;
    }
    post(path, handler, hook) {
      this.add("POST", path, handler, hook);
      return this;
    }
    put(path, handler, hook) {
      this.add("PUT", path, handler, hook);
      return this;
    }
    patch(path, handler, hook) {
      this.add("PATCH", path, handler, hook);
      return this;
    }
    delete(path, handler, hook) {
      this.add("DELETE", path, handler, hook);
      return this;
    }
    options(path, handler, hook) {
      this.add("OPTIONS", path, handler, hook);
      return this;
    }
    all(path, handler, hook) {
      this.add("ALL", path, handler, hook);
      return this;
    }
    head(path, handler, hook) {
      this.add("HEAD", path, handler, hook);
      return this;
    }
    connect(path, handler, hook) {
      this.add("CONNECT", path, handler, hook);
      return this;
    }
    route(method, path, handler, hook) {
      this.add(method.toUpperCase(), path, handler, hook, hook?.config);
      return this;
    }
    ws(path, options) {
      const transform7 = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined;
      let server = null;
      const validateMessage = getSchemaValidator2(options?.body, {
        models: this.definitions.type,
        normalize: this.config.normalize
      });
      const validateResponse = getSchemaValidator2(options?.response, {
        models: this.definitions.type,
        normalize: this.config.normalize
      });
      const parseMessage = (message) => {
        if (typeof message === "string") {
          const start = message?.charCodeAt(0);
          if (start === 47 || start === 123)
            try {
              message = JSON.parse(message);
            } catch {
            }
          else if (isNumericString2(message))
            message = +message;
        }
        if (transform7?.length)
          for (let i = 0;i < transform7.length; i++) {
            const temp = transform7[i](message);
            if (temp !== undefined)
              message = temp;
          }
        return message;
      };
      this.route("$INTERNALWS", path, (context) => {
        const { set: set2, path: path2, qi, headers, query, params } = context;
        if (server === null)
          server = this.getServer();
        if (server?.upgrade(context.request, {
          headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
          data: {
            validator: validateResponse,
            open(ws) {
              options.open?.(new ElysiaWS2(ws, context));
            },
            message: (ws, msg) => {
              const message = parseMessage(msg);
              if (validateMessage?.Check(message) === false)
                return void ws.send(new ValidationError2("message", validateMessage, message).message);
              options.message?.(new ElysiaWS2(ws, context), message);
            },
            drain(ws) {
              options.drain?.(new ElysiaWS2(ws, context));
            },
            close(ws, code, reason) {
              options.close?.(new ElysiaWS2(ws, context), code, reason);
            }
          }
        }))
          return;
        set2.status = 400;
        return "Expected a websocket connection";
      }, {
        beforeHandle: options.beforeHandle,
        transform: options.transform,
        headers: options.headers,
        params: options.params,
        query: options.query
      });
      return this;
    }
    state(name, value15) {
      switch (typeof name) {
        case "object":
          this.singleton.store = mergeDeep2(this.singleton.store, name);
          return this;
        case "function":
          this.singleton.store = name(this.singleton.store);
          return this;
      }
      if (!(name in this.singleton.store)) {
        this.singleton.store[name] = value15;
      }
      return this;
    }
    decorate(name, value15) {
      switch (typeof name) {
        case "object":
          this.singleton.decorator = mergeDeep2(this.singleton.decorator, name);
          return this;
        case "function":
          this.singleton.decorator = name(this.singleton.decorator);
          return this;
      }
      if (!(name in this.singleton.decorator))
        this.singleton.decorator[name] = value15;
      return this;
    }
    derive(optionsOrTransform, transform7) {
      if (!transform7) {
        transform7 = optionsOrTransform;
        optionsOrTransform = { as: "local" };
      }
      const hook = {
        subType: "derive",
        fn: transform7
      };
      return this.onTransform(optionsOrTransform, hook);
    }
    model(name, model) {
      switch (typeof name) {
        case "object":
          Object.entries(name).forEach(([key, value15]) => {
            if (!(key in this.definitions.type))
              this.definitions.type[key] = value15;
          });
          return this;
        case "function":
          this.definitions.type = name(this.definitions.type);
          return this;
      }
      this.definitions.type[name] = model;
      return this;
    }
    mapDerive(optionsOrDerive, mapper) {
      if (!mapper) {
        mapper = optionsOrDerive;
        optionsOrDerive = { as: "local" };
      }
      const hook = {
        subType: "derive",
        fn: mapper
      };
      return this.onTransform(optionsOrDerive, hook);
    }
    affix(base, type74, word) {
      if (word === "")
        return this;
      const delimieter = ["_", "-", " "];
      const capitalize2 = (word2) => word2[0].toUpperCase() + word2.slice(1);
      const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize2(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize2(suffix);
      const remap = (type210) => {
        const store = {};
        switch (type210) {
          case "decorator":
            for (const key in this.singleton.decorator) {
              store[joinKey(word, key)] = this.singleton.decorator[key];
            }
            this.singleton.decorator = store;
            break;
          case "state":
            for (const key in this.singleton.store)
              store[joinKey(word, key)] = this.singleton.store[key];
            this.singleton.store = store;
            break;
          case "model":
            for (const key in this.definitions.type)
              store[joinKey(word, key)] = this.definitions.type[key];
            this.definitions.type = store;
            break;
          case "error":
            for (const key in this.definitions.error)
              store[joinKey(word, key)] = this.definitions.error[key];
            this.definitions.error = store;
            break;
        }
      };
      const types = Array.isArray(type74) ? type74 : [type74];
      for (const type210 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
        remap(type210);
      return this;
    }
    prefix(type74, word) {
      return this.affix("prefix", type74, word);
    }
    suffix(type74, word) {
      return this.affix("suffix", type74, word);
    }
    compile() {
      this.fetch = this.config.aot ? composeGeneralHandler2(this) : createDynamicHandler2(this);
      if (typeof this.server?.reload === "function")
        this.server.reload({
          ...this.server || {},
          fetch: this.fetch
        });
      return this;
    }
    get modules() {
      return Promise.all(this.promisedModules.promises);
    }
  };
});

// node_modules/@kitajs/html/suspense.js
var require_suspense = __commonJS((exports, module) => {
  var Suspense = function(props) {
    if (!SUSPENSE_ROOT.enabled) {
      throw new Error("Cannot use Suspense outside of a `renderToStream` call.");
    }
    if (!props.rid) {
      throw new Error("Suspense requires a `rid` to be specified.");
    }
    const fallback = contentsToString([props.fallback]);
    if (!props.children) {
      return "";
    }
    const children = contentsToString([props.children]);
    if (typeof children === "string") {
      return children;
    }
    let data = SUSPENSE_ROOT.requests.get(props.rid);
    if (!data) {
      throw new Error("Request data was deleted before all suspense components were resolved.");
    }
    const run = ++data.running;
    children.then(writeStreamTemplate).catch(function errorRecover(error23) {
      if (!props.catch) {
        throw error23;
      }
      let html;
      if (typeof props.catch === "function") {
        html = props.catch(error23);
      } else {
        html = props.catch;
      }
      if (typeof html === "string") {
        return writeStreamTemplate(html);
      }
      return html.then(writeStreamTemplate);
    }).catch(function writeFatalError(error23) {
      if (data) {
        const stream = data.stream.deref();
        if (stream && stream.emit("error", error23)) {
          return;
        }
      }
      console.error(error23);
    }).finally(function clearRequestData() {
      data = SUSPENSE_ROOT.requests.get(props.rid);
      if (!data) {
        return;
      }
      if (data.running > 1) {
        data.running -= 1;
      } else {
        const stream = data.stream.deref();
        if (stream && !stream.closed) {
          stream.end();
        }
        SUSPENSE_ROOT.requests.delete(props.rid);
      }
    });
    if (typeof fallback === "string") {
      return '<div id="B:' + run + '" data-sf>' + fallback + "</div>";
    }
    return fallback.then(function resolveCallback(resolved) {
      return '<div id="B:' + run + '" data-sf>' + resolved + "</div>";
    });
    function writeStreamTemplate(result) {
      data = SUSPENSE_ROOT.requests.get(props.rid);
      if (!data) {
        return;
      }
      const stream = data.stream.deref();
      if (!stream || stream.closed) {
        return;
      }
      if (SUSPENSE_ROOT.autoScript && data.sent === false) {
        stream.write(SuspenseScript);
        data.sent = true;
      }
      stream.write('<template id="N:' + run + '" data-sr>' + result + '</template><script id="S:' + run + '" data-ss>$KITA_RC(' + run + ")</script>");
    }
  };
  var pipeHtml = function(html, stream, rid) {
    if (typeof html === "string") {
      stream.write(html);
      const requestData = SUSPENSE_ROOT.requests.get(rid);
      if (!requestData || requestData.running === 0) {
        stream.end();
        SUSPENSE_ROOT.requests.delete(rid);
      }
      return;
    }
    html.then(function writeStreamHtml(html2) {
      stream.write(html2);
    }).catch(function catchError(error23) {
      if (stream.emit("error", error23) === false) {
        console.error(error23);
      }
    }).finally(function endStream() {
      const requestData = SUSPENSE_ROOT.requests.get(rid);
      if (!requestData || requestData.running === 0) {
        stream.end();
        SUSPENSE_ROOT.requests.delete(rid);
      }
    });
  };
  var renderToStream = function(factory, rid) {
    if (SUSPENSE_ROOT.enabled === false) {
      SUSPENSE_ROOT.enabled = true;
    }
    if (!rid) {
      rid = SUSPENSE_ROOT.requestCounter++;
    } else if (SUSPENSE_ROOT.requests.has(rid)) {
      throw new Error(`The provided Request Id is already in use: ${rid}.`);
    }
    const stream = new PassThrough;
    SUSPENSE_ROOT.requests.set(rid, {
      stream: new WeakRef(stream),
      running: 0,
      sent: false
    });
    try {
      const html = factory(rid);
      pipeHtml(html, stream, rid);
      return stream;
    } catch (renderError) {
      stream.end();
      SUSPENSE_ROOT.requests.delete(rid);
      throw renderError;
    }
  };
  async function renderToString(factory, rid) {
    if (SUSPENSE_ROOT.enabled === false) {
      SUSPENSE_ROOT.enabled = true;
    }
    if (!rid) {
      rid = SUSPENSE_ROOT.requestCounter++;
    } else if (SUSPENSE_ROOT.requests.has(rid)) {
      throw new Error(`The provided Request Id is already in use: ${rid}.`);
    }
    let finalHtml = "";
    const stream = new Writable({
      write(chunk, _, callback) {
        finalHtml += chunk.toString();
        callback();
      }
    });
    SUSPENSE_ROOT.requests.set(rid, {
      stream: new WeakRef(stream),
      running: 0,
      sent: false
    });
    try {
      const html = factory(rid);
      pipeHtml(html, stream, rid);
      return new Promise((res, rej) => {
        stream.once("finish", () => res(finalHtml));
        stream.once("error", rej);
      });
    } catch (renderError) {
      stream.end();
      SUSPENSE_ROOT.requests.delete(rid);
      throw renderError;
    }
  }
  var { contentsToString } = require_html();
  var { PassThrough, Writable } = __require("stream");
  if (!globalThis.SUSPENSE_ROOT) {
    globalThis.SUSPENSE_ROOT = {
      requests: new Map,
      requestCounter: 1,
      enabled: false,
      autoScript: true
    };
  }
  var SuspenseScript = `
      <script id="kita-html-suspense">
        /*! Apache-2.0 https://kita.js.org */
        function \$KITA_RC(i){
          // simple aliases
          var d=document,q=d.querySelector.bind(d),
            // div sent as the fallback wrapper
            v=q('div[id="B:'+i+'"][data-sf]'),
            // template and script sent after promise finishes
            t=q('template[id="N:'+i+'"][data-sr]'),s=q('script[id="S:'+i+'"][data-ss]'),
            // fragment created to avoid inserting element one by one
            f=d.createDocumentFragment(),
            // used by iterators
            c,j,
            // all pending hydrations
            r;

          // if div or template is not found, let this hydration as pending
          if(t&&v&&s){
            // appends into the fragment
            while(c=t.content.firstChild)
              f.appendChild(c);

            // replaces the div and removes the script and template
            v.parentNode.replaceChild(f,v);
            t.remove();
            s.remove();

            // looks for pending templates
            r=d.querySelectorAll('template[id][data-sr]');

            do{
              // resets j from previous loop
              j=0;

              // loops over every found pending template and 
              for(c=0;c<r.length;c++)
                if(r[c]!=t)
                  // let j as true while at least on \$KITA_RC call returns true
                  j=\$KITA_RC(r[c].id.slice(2))?!0:j;
            }while(j)

            // we know at least the original template was substituted
            return!0;
          }
        }
      </script>
    `.replace(/^\s*\/\/.*/gm, "").replace(/\n\s*/g, "");
  exports.Suspense = Suspense;
  exports.pipeHtml = pipeHtml;
  exports.renderToStream = renderToStream;
  exports.renderToString = renderToString;
  exports.SuspenseScript = SuspenseScript;
});

// node_modules/@elysiajs/html/dist/cjs/utils.js
var require_utils = __commonJS((exports) => {
  var isHtml = function(value15) {
    if (typeof value15 !== "string")
      return false;
    value15 = value15.trim();
    const length = value15.length;
    return length >= 7 && value15[0] === "<" && value15[length - 1] === ">";
  };
  var isTagHtml = function(value15) {
    return value15.trimStart().slice(0, 5).startsWith("<html");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isTagHtml = exports.isHtml = undefined;
  exports.isHtml = isHtml;
  exports.isTagHtml = isTagHtml;
});

// node_modules/@elysiajs/html/dist/cjs/handler.js
var require_handler = __commonJS((exports) => {
  var handleHtml = function(value15, options, hasContentType) {
    if (value15 instanceof Promise) {
      return value15.then((v) => handleHtml(v, options, hasContentType));
    }
    if (typeof value15 === "string") {
      if (options.autoDoctype && (0, utils_1.isHtml)(value15) && (0, utils_1.isTagHtml)(value15))
        value15 = "<!doctype html>" + value15;
      return new Response(value15, hasContentType ? undefined : { headers: { "content-type": options.contentType } });
    }
    let stream = stream_1.Readable.toWeb(value15);
    if (options.autoDoctype) {
      let first = true;
      stream = stream.pipeThrough(new TransformStream({
        transform(chunk, controller) {
          let str = chunk.toString();
          if (first && (0, utils_1.isTagHtml)(str) && (0, utils_1.isTagHtml)(str)) {
            first = false;
            str = "<!doctype html>" + str;
          }
          controller.enqueue(str);
        }
      }));
    }
    return new Response(stream, hasContentType ? undefined : { headers: { "content-type": options.contentType } });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.handleHtml = undefined;
  var stream_1 = __require("stream");
  var utils_1 = require_utils();
  exports.handleHtml = handleHtml;
});

// node_modules/@elysiajs/html/dist/cjs/html.js
var require_html2 = __commonJS((exports) => {
  var html = function(options = {}) {
    options.contentType ??= "text/html; charset=utf8";
    options.autoDetect ??= true;
    options.isHtml ??= utils_1.isHtml;
    options.autoDoctype ??= true;
    const instance = new elysia_1.Elysia({
      name: "@elysiajs/html",
      seed: options
    }).derive({ as: "global" }, ({ set: set2 }) => {
      return {
        html(value15) {
          return (0, handler_1.handleHtml)(value15, options, "content-type" in set2.headers);
        },
        stream(value15, args) {
          return (0, handler_1.handleHtml)((0, suspense_1.renderToStream)((id) => value15({ ...args, id })), options, "content-type" in set2.headers);
        }
      };
    });
    if (options.autoDetect)
      return instance.mapResponse({ as: "global" }, async function handlerPossibleHtml({ response: value15, set: set2 }) {
        if ((0, utils_1.isHtml)(value15) || value15 instanceof node_stream_1.Readable && "rid" in value15) {
          const response = await (0, handler_1.handleHtml)(value15, options, "content-type" in set2.headers);
          if (response instanceof Response)
            return response;
          set2.headers["content-type"] = options.contentType;
          return new Response(response);
        }
        return;
      });
    return instance;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.html = undefined;
  var elysia_1 = require_cjs();
  var node_stream_1 = __require("node:stream");
  var suspense_1 = require_suspense();
  var handler_1 = require_handler();
  var utils_1 = require_utils();
  exports.html = html;
});

// node_modules/@elysiajs/html/dist/cjs/options.js
var require_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@kitajs/html/register.js
var require_register = __commonJS(() => {
  var root;
  try {
    root = Function("return this")();
  } catch (_) {
    root = window;
  }
  if (!root.Html) {
    root.Html = require_html();
  }
  if (root.Html.default) {
    root.Html = root.Html.default;
  }
});

// node_modules/@kitajs/html/error-boundary.js
var require_error_boundary = __commonJS((exports, module) => {
  var isTimeoutError = function(error23) {
    return error23 && error23[TIMEOUT_SYMBOL];
  };
  var ErrorBoundary = function(props) {
    let children = contentsToString([props.children]);
    if (typeof children === "string") {
      return children;
    }
    if (props.timeout) {
      children = Promise.race([
        children,
        setTimeout2(props.timeout).then(function reject() {
          const error23 = new Error("Children timed out.");
          error23[TIMEOUT_SYMBOL] = true;
          throw error23;
        })
      ]);
    }
    return children.catch(function errorBoundary(error23) {
      if (typeof props.catch === "function") {
        return props.catch(error23);
      }
      return props.catch;
    });
  };
  var { contentsToString } = require_html();
  var { setTimeout: setTimeout2 } = __require("timers/promises");
  var TIMEOUT_SYMBOL = Symbol.for("kHtmlTimeout");
  exports.ErrorBoundary = ErrorBoundary;
  exports.isTimeoutError = isTimeoutError;
});

// node_modules/@elysiajs/html/dist/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createElement = exports.Html = exports.Suspense = exports.ErrorBoundary = undefined;
  var h_1 = require_h();
  Object.defineProperty(exports, "createElement", { enumerable: true, get: function() {
    return h_1.createElement;
  } });
  __exportStar(require_html2(), exports);
  __exportStar(require_options(), exports);
  __exportStar(require_utils(), exports);
  __exportStar(require_register(), exports);
  var error_boundary_1 = require_error_boundary();
  Object.defineProperty(exports, "ErrorBoundary", { enumerable: true, get: function() {
    return error_boundary_1.ErrorBoundary;
  } });
  var suspense_1 = require_suspense();
  Object.defineProperty(exports, "Suspense", { enumerable: true, get: function() {
    return suspense_1.Suspense;
  } });
  var html_1 = require_html();
  Object.defineProperty(exports, "Html", { enumerable: true, get: function() {
    return html_1.Html;
  } });
  Html.createElement = h_1.createElement;
});

// node_modules/validator/lib/util/assertString.js
var require_assertString = __commonJS((exports, module) => {
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var assertString = function(input) {
    var isString = typeof input === "string" || input instanceof String;
    if (!isString) {
      var invalidType = _typeof(input);
      if (input === null)
        invalidType = "null";
      else if (invalidType === "object")
        invalidType = input.constructor.name;
      throw new TypeError("Expected a string but received a ".concat(invalidType));
    }
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assertString;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/toDate.js
var require_toDate = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var toDate = function(date6) {
    (0, _assertString.default)(date6);
    date6 = Date.parse(date6);
    return !isNaN(date6) ? new Date(date6) : null;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toDate;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/alpha.js
var require_alpha = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.commaDecimal = exports.dotDecimal = exports.bengaliLocales = exports.farsiLocales = exports.arabicLocales = exports.englishLocales = exports.decimal = exports.alphanumeric = exports.alpha = undefined;
  var alpha = {
    "en-US": /^[A-Z]+$/i,
    "az-AZ": /^[A-VXYZ]+$/i,
    "bg-BG": /^[-]+$/i,
    "cs-CZ": /^[A-Z]+$/i,
    "da-DK": /^[A-Z]+$/i,
    "de-DE": /^[A-Z]+$/i,
    "el-GR": /^[-]+$/i,
    "es-ES": /^[A-Z]+$/i,
    "fa-IR": /^[]+$/i,
    "fi-FI": /^[A-Z]+$/i,
    "fr-FR": /^[A-Z]+$/i,
    "it-IT": /^[A-Z]+$/i,
    "ja-JP": /^[----]+$/i,
    "nb-NO": /^[A-Z]+$/i,
    "nl-NL": /^[A-Z]+$/i,
    "nn-NO": /^[A-Z]+$/i,
    "hu-HU": /^[A-Z]+$/i,
    "pl-PL": /^[A-Z]+$/i,
    "pt-PT": /^[A-Z]+$/i,
    "ru-RU": /^[-]+$/i,
    "kk-KZ": /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
    "sl-SI": /^[A-Z]+$/i,
    "sk-SK": /^[A-Z]+$/i,
    "sr-RS@latin": /^[A-Z]+$/i,
    "sr-RS": /^[-]+$/i,
    "sv-SE": /^[A-Z]+$/i,
    "th-TH": /^[-\s]+$/i,
    "tr-TR": /^[A-Z]+$/i,
    "uk-UA": /^[-I]+$/i,
    "vi-VN": /^[A-Z]+$/i,
    "ko-KR": /^[---]*$/,
    "ku-IQ": /^[]+$/i,
    ar: /^[]+$/,
    he: /^[-]+$/,
    fa: /^['']+$/i,
    bn: /^['']+$/,
    "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
    "si-LK": /^[\u0D80-\u0DFF]+$/
  };
  exports.alpha = alpha;
  var alphanumeric = {
    "en-US": /^[0-9A-Z]+$/i,
    "az-AZ": /^[0-9A-VXYZ]+$/i,
    "bg-BG": /^[0-9-]+$/i,
    "cs-CZ": /^[0-9A-Z]+$/i,
    "da-DK": /^[0-9A-Z]+$/i,
    "de-DE": /^[0-9A-Z]+$/i,
    "el-GR": /^[0-9-]+$/i,
    "es-ES": /^[0-9A-Z]+$/i,
    "fi-FI": /^[0-9A-Z]+$/i,
    "fr-FR": /^[0-9A-Z]+$/i,
    "it-IT": /^[0-9A-Z]+$/i,
    "ja-JP": /^[0-9-----]+$/i,
    "hu-HU": /^[0-9A-Z]+$/i,
    "nb-NO": /^[0-9A-Z]+$/i,
    "nl-NL": /^[0-9A-Z]+$/i,
    "nn-NO": /^[0-9A-Z]+$/i,
    "pl-PL": /^[0-9A-Z]+$/i,
    "pt-PT": /^[0-9A-Z]+$/i,
    "ru-RU": /^[0-9-]+$/i,
    "kk-KZ": /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
    "sl-SI": /^[0-9A-Z]+$/i,
    "sk-SK": /^[0-9A-Z]+$/i,
    "sr-RS@latin": /^[0-9A-Z]+$/i,
    "sr-RS": /^[0-9-]+$/i,
    "sv-SE": /^[0-9A-Z]+$/i,
    "th-TH": /^[-\s]+$/i,
    "tr-TR": /^[0-9A-Z]+$/i,
    "uk-UA": /^[0-9-I]+$/i,
    "ko-KR": /^[0-9---]*$/,
    "ku-IQ": /^[0-9]+$/i,
    "vi-VN": /^[0-9A-Z]+$/i,
    ar: /^[0-9]+$/,
    he: /^[0-9-]+$/,
    fa: /^['0-9']+$/i,
    bn: /^['']+$/,
    "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
    "si-LK": /^[0-9\u0D80-\u0DFF]+$/
  };
  exports.alphanumeric = alphanumeric;
  var decimal = {
    "en-US": ".",
    ar: "\u066B"
  };
  exports.decimal = decimal;
  var englishLocales = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
  exports.englishLocales = englishLocales;
  for (i = 0;i < englishLocales.length; i++) {
    locale = "en-".concat(englishLocales[i]);
    alpha[locale] = alpha["en-US"];
    alphanumeric[locale] = alphanumeric["en-US"];
    decimal[locale] = decimal["en-US"];
  }
  var locale;
  var i;
  var arabicLocales = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
  exports.arabicLocales = arabicLocales;
  for (_i = 0;_i < arabicLocales.length; _i++) {
    _locale = "ar-".concat(arabicLocales[_i]);
    alpha[_locale] = alpha.ar;
    alphanumeric[_locale] = alphanumeric.ar;
    decimal[_locale] = decimal.ar;
  }
  var _locale;
  var _i;
  var farsiLocales = ["IR", "AF"];
  exports.farsiLocales = farsiLocales;
  for (_i2 = 0;_i2 < farsiLocales.length; _i2++) {
    _locale2 = "fa-".concat(farsiLocales[_i2]);
    alphanumeric[_locale2] = alphanumeric.fa;
    decimal[_locale2] = decimal.ar;
  }
  var _locale2;
  var _i2;
  var bengaliLocales = ["BD", "IN"];
  exports.bengaliLocales = bengaliLocales;
  for (_i3 = 0;_i3 < bengaliLocales.length; _i3++) {
    _locale3 = "bn-".concat(bengaliLocales[_i3]);
    alpha[_locale3] = alpha.bn;
    alphanumeric[_locale3] = alphanumeric.bn;
    decimal[_locale3] = decimal["en-US"];
  }
  var _locale3;
  var _i3;
  var dotDecimal = ["ar-EG", "ar-LB", "ar-LY"];
  exports.dotDecimal = dotDecimal;
  var commaDecimal = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
  exports.commaDecimal = commaDecimal;
  for (_i4 = 0;_i4 < dotDecimal.length; _i4++) {
    decimal[dotDecimal[_i4]] = decimal["en-US"];
  }
  var _i4;
  for (_i5 = 0;_i5 < commaDecimal.length; _i5++) {
    decimal[commaDecimal[_i5]] = ",";
  }
  var _i5;
  alpha["fr-CA"] = alpha["fr-FR"];
  alphanumeric["fr-CA"] = alphanumeric["fr-FR"];
  alpha["pt-BR"] = alpha["pt-PT"];
  alphanumeric["pt-BR"] = alphanumeric["pt-PT"];
  decimal["pt-BR"] = decimal["pt-PT"];
  alpha["pl-Pl"] = alpha["pl-PL"];
  alphanumeric["pl-Pl"] = alphanumeric["pl-PL"];
  decimal["pl-Pl"] = decimal["pl-PL"];
  alpha["fa-AF"] = alpha.fa;
});

// node_modules/validator/lib/isFloat.js
var require_isFloat = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isFloat = function(str, options) {
    (0, _assertString.default)(str);
    options = options || {};
    var float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
    if (str === "" || str === "." || str === "," || str === "-" || str === "+") {
      return false;
    }
    var value15 = parseFloat(str.replace(",", "."));
    return float.test(str) && (!options.hasOwnProperty("min") || value15 >= options.min) && (!options.hasOwnProperty("max") || value15 <= options.max) && (!options.hasOwnProperty("lt") || value15 < options.lt) && (!options.hasOwnProperty("gt") || value15 > options.gt);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFloat;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var _alpha = require_alpha();
  var locales = Object.keys(_alpha.decimal);
  exports.locales = locales;
});

// node_modules/validator/lib/toFloat.js
var require_toFloat = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var toFloat = function(str) {
    if (!(0, _isFloat.default)(str))
      return NaN;
    return parseFloat(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toFloat;
  var _isFloat = _interopRequireDefault(require_isFloat());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/toInt.js
var require_toInt = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var toInt = function(str, radix) {
    (0, _assertString.default)(str);
    return parseInt(str, radix || 10);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toInt;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/toBoolean.js
var require_toBoolean = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var toBoolean = function(str, strict4) {
    (0, _assertString.default)(str);
    if (strict4) {
      return str === "1" || /^true$/i.test(str);
    }
    return str !== "0" && !/^false$/i.test(str) && str !== "";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toBoolean;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/equals.js
var require_equals = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var equals = function(str, comparison) {
    (0, _assertString.default)(str);
    return str === comparison;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = equals;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/util/toString.js
var require_toString = __commonJS((exports, module) => {
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var toString2 = function(input) {
    if (_typeof(input) === "object" && input !== null) {
      if (typeof input.toString === "function") {
        input = input.toString();
      } else {
        input = "[object Object]";
      }
    } else if (input === null || typeof input === "undefined" || isNaN(input) && !input.length) {
      input = "";
    }
    return String(input);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toString2;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/util/merge.js
var require_merge = __commonJS((exports, module) => {
  var merge = function() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var defaults = arguments.length > 1 ? arguments[1] : undefined;
    for (var key in defaults) {
      if (typeof obj[key] === "undefined") {
        obj[key] = defaults[key];
      }
    }
    return obj;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = merge;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/contains.js
var require_contains = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var contains = function(str, elem, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, defaulContainsOptions);
    if (options.ignoreCase) {
      return str.toLowerCase().split((0, _toString.default)(elem).toLowerCase()).length > options.minOccurrences;
    }
    return str.split((0, _toString.default)(elem)).length > options.minOccurrences;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = contains;
  var _assertString = _interopRequireDefault(require_assertString());
  var _toString = _interopRequireDefault(require_toString());
  var _merge = _interopRequireDefault(require_merge());
  var defaulContainsOptions = {
    ignoreCase: false,
    minOccurrences: 1
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/matches.js
var require_matches = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var matches = function(str, pattern3, modifiers) {
    (0, _assertString.default)(str);
    if (Object.prototype.toString.call(pattern3) !== "[object RegExp]") {
      pattern3 = new RegExp(pattern3, modifiers);
    }
    return !!str.match(pattern3);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = matches;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isByteLength.js
var require_isByteLength = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var isByteLength = function(str, options) {
    (0, _assertString.default)(str);
    var min;
    var max;
    if (_typeof(options) === "object") {
      min = options.min || 0;
      max = options.max;
    } else {
      min = arguments[1];
      max = arguments[2];
    }
    var len = encodeURI(str).split(/%..|./).length - 1;
    return len >= min && (typeof max === "undefined" || len <= max);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isByteLength;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isFQDN.js
var require_isFQDN = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isFQDN = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_fqdn_options);
    if (options.allow_trailing_dot && str[str.length - 1] === ".") {
      str = str.substring(0, str.length - 1);
    }
    if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
      str = str.substring(2);
    }
    var parts = str.split(".");
    var tld = parts[parts.length - 1];
    if (options.require_tld) {
      if (parts.length < 2) {
        return false;
      }
      if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      if (/\s/.test(tld)) {
        return false;
      }
    }
    if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }
    return parts.every(function(part) {
      if (part.length > 63 && !options.ignore_max_length) {
        return false;
      }
      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (/^-|-$/.test(part)) {
        return false;
      }
      if (!options.allow_underscores && /_/.test(part)) {
        return false;
      }
      return true;
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFQDN;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_numeric_tld: false,
    allow_wildcard: false,
    ignore_max_length: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isIP.js
var require_isIP = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isIP = function(str) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    (0, _assertString.default)(str);
    version = String(version);
    if (!version) {
      return isIP(str, 4) || isIP(str, 6);
    }
    if (version === "4") {
      return IPv4AddressRegExp.test(str);
    }
    if (version === "6") {
      return IPv6AddressRegExp.test(str);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIP;
  var _assertString = _interopRequireDefault(require_assertString());
  var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
  var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
  var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
  var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isEmail.js
var require_isEmail = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validateDisplayName = function(display_name) {
    var display_name_without_quotes = display_name.replace(/^"(.+)"$/, "$1");
    if (!display_name_without_quotes.trim()) {
      return false;
    }
    var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
    if (contains_illegal) {
      if (display_name_without_quotes === display_name) {
        return false;
      }
      var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
      if (!all_start_with_back_slash) {
        return false;
      }
    }
    return true;
  };
  var isEmail = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_email_options);
    if (options.require_display_name || options.allow_display_name) {
      var display_email = str.match(splitNameAddress);
      if (display_email) {
        var display_name = display_email[1];
        str = str.replace(display_name, "").replace(/(^<|>$)/g, "");
        if (display_name.endsWith(" ")) {
          display_name = display_name.slice(0, -1);
        }
        if (!validateDisplayName(display_name)) {
          return false;
        }
      } else if (options.require_display_name) {
        return false;
      }
    }
    if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
      return false;
    }
    var parts = str.split("@");
    var domain = parts.pop();
    var lower_domain = domain.toLowerCase();
    if (options.host_blacklist.includes(lower_domain)) {
      return false;
    }
    if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
      return false;
    }
    var user = parts.join("@");
    if (options.domain_specific_validation && (lower_domain === "gmail.com" || lower_domain === "googlemail.com")) {
      user = user.toLowerCase();
      var username = user.split("+")[0];
      if (!(0, _isByteLength.default)(username.replace(/\./g, ""), {
        min: 6,
        max: 30
      })) {
        return false;
      }
      var _user_parts = username.split(".");
      for (var i = 0;i < _user_parts.length; i++) {
        if (!gmailUserPart.test(_user_parts[i])) {
          return false;
        }
      }
    }
    if (options.ignore_max_length === false && (!(0, _isByteLength.default)(user, {
      max: 64
    }) || !(0, _isByteLength.default)(domain, {
      max: 254
    }))) {
      return false;
    }
    if (!(0, _isFQDN.default)(domain, {
      require_tld: options.require_tld,
      ignore_max_length: options.ignore_max_length,
      allow_underscores: options.allow_underscores
    })) {
      if (!options.allow_ip_domain) {
        return false;
      }
      if (!(0, _isIP.default)(domain)) {
        if (!domain.startsWith("[") || !domain.endsWith("]")) {
          return false;
        }
        var noBracketdomain = domain.slice(1, -1);
        if (noBracketdomain.length === 0 || !(0, _isIP.default)(noBracketdomain)) {
          return false;
        }
      }
    }
    if (user[0] === '"') {
      user = user.slice(1, user.length - 1);
      return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
    }
    var pattern3 = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
    var user_parts = user.split(".");
    for (var _i = 0;_i < user_parts.length; _i++) {
      if (!pattern3.test(user_parts[_i])) {
        return false;
      }
    }
    if (options.blacklisted_chars) {
      if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), "g")) !== -1)
        return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmail;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isByteLength = _interopRequireDefault(require_isByteLength());
  var _isFQDN = _interopRequireDefault(require_isFQDN());
  var _isIP = _interopRequireDefault(require_isIP());
  var _merge = _interopRequireDefault(require_merge());
  var default_email_options = {
    allow_display_name: false,
    allow_underscores: false,
    require_display_name: false,
    allow_utf8_local_part: true,
    require_tld: true,
    blacklisted_chars: "",
    ignore_max_length: false,
    host_blacklist: [],
    host_whitelist: []
  };
  var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
  var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
  var gmailUserPart = /^[a-z\d]+$/;
  var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
  var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
  var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
  var defaultMaxEmailLength = 254;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isURL.js
var require_isURL = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _slicedToArray = function(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  };
  var _nonIterableRest = function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  };
  var _unsupportedIterableToArray = function(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  };
  var _arrayLikeToArray = function(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  };
  var _iterableToArrayLimit = function(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  };
  var _arrayWithHoles = function(arr) {
    if (Array.isArray(arr))
      return arr;
  };
  var isRegExp = function(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var checkHost = function(host, matches) {
    for (var i = 0;i < matches.length; i++) {
      var match = matches[i];
      if (host === match || isRegExp(match) && match.test(host)) {
        return true;
      }
    }
    return false;
  };
  var isURL = function(url, options) {
    (0, _assertString.default)(url);
    if (!url || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf("mailto:") === 0) {
      return false;
    }
    options = (0, _merge.default)(options, default_url_options);
    if (options.validate_length && url.length >= 2083) {
      return false;
    }
    if (!options.allow_fragments && url.includes("#")) {
      return false;
    }
    if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
      return false;
    }
    var protocol, auth, host, hostname, port, port_str, split, ipv6;
    split = url.split("#");
    url = split.shift();
    split = url.split("?");
    url = split.shift();
    split = url.split("://");
    if (split.length > 1) {
      protocol = split.shift().toLowerCase();
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.slice(0, 2) === "//") {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }
      split[0] = url.slice(2);
    }
    url = split.join("://");
    if (url === "") {
      return false;
    }
    split = url.split("/");
    url = split.shift();
    if (url === "" && !options.require_host) {
      return true;
    }
    split = url.split("@");
    if (split.length > 1) {
      if (options.disallow_auth) {
        return false;
      }
      if (split[0] === "") {
        return false;
      }
      auth = split.shift();
      if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
        return false;
      }
      var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
      if (user === "" && password === "") {
        return false;
      }
    }
    hostname = split.join("@");
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = "";
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split = hostname.split(":");
      host = split.shift();
      if (split.length) {
        port_str = split.join(":");
      }
    }
    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options.require_port) {
      return false;
    }
    if (options.host_whitelist) {
      return checkHost(host, options.host_whitelist);
    }
    if (host === "" && !options.require_host) {
      return true;
    }
    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
      return false;
    }
    host = host || ipv6;
    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isURL;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isFQDN = _interopRequireDefault(require_isFQDN());
  var _isIP = _interopRequireDefault(require_isIP());
  var _merge = _interopRequireDefault(require_merge());
  var default_url_options = {
    protocols: ["http", "https", "ftp"],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_port: false,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
    allow_fragments: true,
    allow_query_components: true,
    validate_length: true
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMACAddress.js
var require_isMACAddress = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isMACAddress = function(str, options) {
    (0, _assertString.default)(str);
    if (options !== null && options !== undefined && options.eui) {
      options.eui = String(options.eui);
    }
    if (options !== null && options !== undefined && options.no_colons || options !== null && options !== undefined && options.no_separators) {
      if (options.eui === "48") {
        return macAddress48NoSeparators.test(str);
      }
      if (options.eui === "64") {
        return macAddress64NoSeparators.test(str);
      }
      return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
    }
    if ((options === null || options === undefined ? undefined : options.eui) === "48") {
      return macAddress48.test(str) || macAddress48WithDots.test(str);
    }
    if ((options === null || options === undefined ? undefined : options.eui) === "64") {
      return macAddress64.test(str) || macAddress64WithDots.test(str);
    }
    return isMACAddress(str, {
      eui: "48"
    }) || isMACAddress(str, {
      eui: "64"
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMACAddress;
  var _assertString = _interopRequireDefault(require_assertString());
  var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
  var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
  var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
  var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
  var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
  var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isIPRange.js
var require_isIPRange = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isIPRange = function(str) {
    var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    (0, _assertString.default)(str);
    var parts = str.split("/");
    if (parts.length !== 2) {
      return false;
    }
    if (!subnetMaybe.test(parts[1])) {
      return false;
    }
    if (parts[1].length > 1 && parts[1].startsWith("0")) {
      return false;
    }
    var isValidIP = (0, _isIP.default)(parts[0], version);
    if (!isValidIP) {
      return false;
    }
    var expectedSubnet = null;
    switch (String(version)) {
      case "4":
        expectedSubnet = v4Subnet;
        break;
      case "6":
        expectedSubnet = v6Subnet;
        break;
      default:
        expectedSubnet = (0, _isIP.default)(parts[0], "6") ? v6Subnet : v4Subnet;
    }
    return parts[1] <= expectedSubnet && parts[1] >= 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIPRange;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isIP = _interopRequireDefault(require_isIP());
  var subnetMaybe = /^\d{1,3}$/;
  var v4Subnet = 32;
  var v6Subnet = 128;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isDate.js
var require_isDate = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _slicedToArray = function(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  };
  var _nonIterableRest = function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  };
  var _iterableToArrayLimit = function(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  };
  var _arrayWithHoles = function(arr) {
    if (Array.isArray(arr))
      return arr;
  };
  var _createForOfIteratorHelper = function(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  };
  var _unsupportedIterableToArray = function(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  };
  var _arrayLikeToArray = function(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  };
  var isValidFormat = function(format) {
    return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
  };
  var zip = function(date6, format) {
    var zippedArr = [], len = Math.min(date6.length, format.length);
    for (var i = 0;i < len; i++) {
      zippedArr.push([date6[i], format[i]]);
    }
    return zippedArr;
  };
  var isDate = function(input, options) {
    if (typeof options === "string") {
      options = (0, _merge.default)({
        format: options
      }, default_date_options);
    } else {
      options = (0, _merge.default)(options, default_date_options);
    }
    if (typeof input === "string" && isValidFormat(options.format)) {
      var formatDelimiter = options.delimiters.find(function(delimiter) {
        return options.format.indexOf(delimiter) !== -1;
      });
      var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function(delimiter) {
        return input.indexOf(delimiter) !== -1;
      });
      var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
      var dateObj = {};
      var _iterator = _createForOfIteratorHelper(dateAndFormat), _step;
      try {
        for (_iterator.s();!(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), dateWord = _step$value[0], formatWord = _step$value[1];
          if (dateWord.length !== formatWord.length) {
            return false;
          }
          dateObj[formatWord.charAt(0)] = dateWord;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      var fullYear = dateObj.y;
      if (dateObj.y.length === 2) {
        var parsedYear = parseInt(dateObj.y, 10);
        if (isNaN(parsedYear)) {
          return false;
        }
        var currentYearLastTwoDigits = new Date().getFullYear() % 100;
        if (parsedYear < currentYearLastTwoDigits) {
          fullYear = "20".concat(dateObj.y);
        } else {
          fullYear = "19".concat(dateObj.y);
        }
      }
      return new Date("".concat(fullYear, "-").concat(dateObj.m, "-").concat(dateObj.d)).getDate() === +dateObj.d;
    }
    if (!options.strictMode) {
      return Object.prototype.toString.call(input) === "[object Date]" && isFinite(input);
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDate;
  var _merge = _interopRequireDefault(require_merge());
  var default_date_options = {
    format: "YYYY/MM/DD",
    delimiters: ["/", "-"],
    strictMode: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isTime.js
var require_isTime = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isTime = function(input, options) {
    options = (0, _merge.default)(options, default_time_options);
    if (typeof input !== "string")
      return false;
    return formats[options.hourFormat][options.mode].test(input);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTime;
  var _merge = _interopRequireDefault(require_merge());
  var default_time_options = {
    hourFormat: "hour24",
    mode: "default"
  };
  var formats = {
    hour24: {
      default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
      withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
    },
    hour12: {
      default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
      withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
    }
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isBoolean.js
var require_isBoolean = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isBoolean = function(str) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
    (0, _assertString.default)(str);
    if (options.loose) {
      return looseBooleans.includes(str.toLowerCase());
    }
    return strictBooleans.includes(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBoolean;
  var _assertString = _interopRequireDefault(require_assertString());
  var defaultOptions = {
    loose: false
  };
  var strictBooleans = ["true", "false", "1", "0"];
  var looseBooleans = [].concat(strictBooleans, ["yes", "no"]);
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isLocale.js
var require_isLocale = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isLocale = function(str) {
    (0, _assertString.default)(str);
    return languageTagRegex.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLocale;
  var _assertString = _interopRequireDefault(require_assertString());
  var extlang = "([A-Za-z]{3}(-[A-Za-z]{3}){0,2})";
  var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");
  var script = "([A-Za-z]{4})";
  var region = "([A-Za-z]{2}|\\d{3})";
  var variant = "([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))";
  var singleton = "(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])";
  var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");
  var privateuse = "(x(-[A-Za-z0-9]{1,8})+)";
  var irregular = "((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))";
  var regular = "((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))";
  var grandfathered = "(".concat(irregular, "|").concat(regular, ")");
  var delimiter = "(-|_)";
  var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");
  var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isAlpha.js
var require_isAlpha = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAlpha = function(_str) {
    var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _assertString.default)(_str);
    var str = _str;
    var ignore = options.ignore;
    if (ignore) {
      if (ignore instanceof RegExp) {
        str = str.replace(ignore, "");
      } else if (typeof ignore === "string") {
        str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
      } else {
        throw new Error("ignore should be instance of a String or RegExp");
      }
    }
    if (locale in _alpha.alpha) {
      return _alpha.alpha[locale].test(str);
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAlpha;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var _alpha = require_alpha();
  var locales = Object.keys(_alpha.alpha);
  exports.locales = locales;
});

// node_modules/validator/lib/isAlphanumeric.js
var require_isAlphanumeric = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAlphanumeric = function(_str) {
    var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _assertString.default)(_str);
    var str = _str;
    var ignore = options.ignore;
    if (ignore) {
      if (ignore instanceof RegExp) {
        str = str.replace(ignore, "");
      } else if (typeof ignore === "string") {
        str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "");
      } else {
        throw new Error("ignore should be instance of a String or RegExp");
      }
    }
    if (locale in _alpha.alphanumeric) {
      return _alpha.alphanumeric[locale].test(str);
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAlphanumeric;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var _alpha = require_alpha();
  var locales = Object.keys(_alpha.alphanumeric);
  exports.locales = locales;
});

// node_modules/validator/lib/isNumeric.js
var require_isNumeric = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isNumeric = function(str, options) {
    (0, _assertString.default)(str);
    if (options && options.no_symbols) {
      return numericNoSymbols.test(str);
    }
    return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : ".", "])?[0-9]+$")).test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isNumeric;
  var _assertString = _interopRequireDefault(require_assertString());
  var _alpha = require_alpha();
  var numericNoSymbols = /^[0-9]+$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isPassportNumber.js
var require_isPassportNumber = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isPassportNumber = function(str, countryCode) {
    (0, _assertString.default)(str);
    var normalizedStr = str.replace(/\s/g, "").toUpperCase();
    return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPassportNumber;
  var _assertString = _interopRequireDefault(require_assertString());
  var passportRegexByCountryCode = {
    AM: /^[A-Z]{2}\d{7}$/,
    AR: /^[A-Z]{3}\d{6}$/,
    AT: /^[A-Z]\d{7}$/,
    AU: /^[A-Z]\d{7}$/,
    AZ: /^[A-Z]{2,3}\d{7,8}$/,
    BE: /^[A-Z]{2}\d{6}$/,
    BG: /^\d{9}$/,
    BR: /^[A-Z]{2}\d{6}$/,
    BY: /^[A-Z]{2}\d{7}$/,
    CA: /^[A-Z]{2}\d{6}$/,
    CH: /^[A-Z]\d{7}$/,
    CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
    CY: /^[A-Z](\d{6}|\d{8})$/,
    CZ: /^\d{8}$/,
    DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
    DK: /^\d{9}$/,
    DZ: /^\d{9}$/,
    EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
    ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
    FI: /^[A-Z]{2}\d{7}$/,
    FR: /^\d{2}[A-Z]{2}\d{5}$/,
    GB: /^\d{9}$/,
    GR: /^[A-Z]{2}\d{7}$/,
    HR: /^\d{9}$/,
    HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
    IE: /^[A-Z0-9]{2}\d{7}$/,
    IN: /^[A-Z]{1}-?\d{7}$/,
    ID: /^[A-C]\d{7}$/,
    IR: /^[A-Z]\d{8}$/,
    IS: /^(A)\d{7}$/,
    IT: /^[A-Z0-9]{2}\d{7}$/,
    JM: /^[Aa]\d{7}$/,
    JP: /^[A-Z]{2}\d{7}$/,
    KR: /^[MS]\d{8}$/,
    KZ: /^[a-zA-Z]\d{7}$/,
    LI: /^[a-zA-Z]\d{5}$/,
    LT: /^[A-Z0-9]{8}$/,
    LU: /^[A-Z0-9]{8}$/,
    LV: /^[A-Z0-9]{2}\d{7}$/,
    LY: /^[A-Z0-9]{8}$/,
    MT: /^\d{7}$/,
    MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
    MY: /^[AHK]\d{8}$/,
    MX: /^\d{10,11}$/,
    NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
    NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
    PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
    PK: /^[A-Z]{2}\d{7}$/,
    PL: /^[A-Z]{2}\d{7}$/,
    PT: /^[A-Z]\d{6}$/,
    RO: /^\d{8,9}$/,
    RU: /^\d{9}$/,
    SE: /^\d{8}$/,
    SL: /^(P)[A-Z]\d{7}$/,
    SK: /^[0-9A-Z]\d{7}$/,
    TH: /^[A-Z]{1,2}\d{6,7}$/,
    TR: /^[A-Z]\d{8}$/,
    UA: /^[A-Z]{2}\d{6}$/,
    US: /^\d{9}$/
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isInt.js
var require_isInt = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isInt = function(str, options) {
    (0, _assertString.default)(str);
    options = options || {};
    var regex2 = options.hasOwnProperty("allow_leading_zeroes") && !options.allow_leading_zeroes ? int : intLeadingZeroes;
    var minCheckPassed = !options.hasOwnProperty("min") || str >= options.min;
    var maxCheckPassed = !options.hasOwnProperty("max") || str <= options.max;
    var ltCheckPassed = !options.hasOwnProperty("lt") || str < options.lt;
    var gtCheckPassed = !options.hasOwnProperty("gt") || str > options.gt;
    return regex2.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isInt;
  var _assertString = _interopRequireDefault(require_assertString());
  var int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
  var intLeadingZeroes = /^[-+]?[0-9]+$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isPort.js
var require_isPort = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isPort = function(str) {
    return (0, _isInt.default)(str, {
      min: 0,
      max: 65535
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPort;
  var _isInt = _interopRequireDefault(require_isInt());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isLowercase.js
var require_isLowercase = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isLowercase = function(str) {
    (0, _assertString.default)(str);
    return str === str.toLowerCase();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLowercase;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isUppercase.js
var require_isUppercase = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isUppercase = function(str) {
    (0, _assertString.default)(str);
    return str === str.toUpperCase();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUppercase;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isIMEI.js
var require_isIMEI = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isIMEI = function(str, options) {
    (0, _assertString.default)(str);
    options = options || {};
    var imeiRegex = imeiRegexWithoutHypens;
    if (options.allow_hyphens) {
      imeiRegex = imeiRegexWithHypens;
    }
    if (!imeiRegex.test(str)) {
      return false;
    }
    str = str.replace(/-/g, "");
    var sum = 0, mul = 2, l = 14;
    for (var i = 0;i < l; i++) {
      var digit = str.substring(l - i - 1, l - i);
      var tp = parseInt(digit, 10) * mul;
      if (tp >= 10) {
        sum += tp % 10 + 1;
      } else {
        sum += tp;
      }
      if (mul === 1) {
        mul += 1;
      } else {
        mul -= 1;
      }
    }
    var chk = (10 - sum % 10) % 10;
    if (chk !== parseInt(str.substring(14, 15), 10)) {
      return false;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIMEI;
  var _assertString = _interopRequireDefault(require_assertString());
  var imeiRegexWithoutHypens = /^[0-9]{15}$/;
  var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isAscii.js
var require_isAscii = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAscii = function(str) {
    (0, _assertString.default)(str);
    return ascii.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAscii;
  var _assertString = _interopRequireDefault(require_assertString());
  var ascii = /^[\x00-\x7F]+$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isFullWidth.js
var require_isFullWidth = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isFullWidth = function(str) {
    (0, _assertString.default)(str);
    return fullWidth.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFullWidth;
  exports.fullWidth = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
  exports.fullWidth = fullWidth;
});

// node_modules/validator/lib/isHalfWidth.js
var require_isHalfWidth = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isHalfWidth = function(str) {
    (0, _assertString.default)(str);
    return halfWidth.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHalfWidth;
  exports.halfWidth = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
  exports.halfWidth = halfWidth;
});

// node_modules/validator/lib/isVariableWidth.js
var require_isVariableWidth = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isVariableWidth = function(str) {
    (0, _assertString.default)(str);
    return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isVariableWidth;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isFullWidth = require_isFullWidth();
  var _isHalfWidth = require_isHalfWidth();
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMultibyte.js
var require_isMultibyte = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isMultibyte = function(str) {
    (0, _assertString.default)(str);
    return multibyte.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMultibyte;
  var _assertString = _interopRequireDefault(require_assertString());
  var multibyte = /[^\x00-\x7F]/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/util/multilineRegex.js
var require_multilineRegex = __commonJS((exports, module) => {
  var multilineRegexp = function(parts, flags) {
    var regexpAsStringLiteral = parts.join("");
    return new RegExp(regexpAsStringLiteral, flags);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = multilineRegexp;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isSemVer.js
var require_isSemVer = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isSemVer = function(str) {
    (0, _assertString.default)(str);
    return semanticVersioningRegex.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSemVer;
  var _assertString = _interopRequireDefault(require_assertString());
  var _multilineRegex = _interopRequireDefault(require_multilineRegex());
  var semanticVersioningRegex = (0, _multilineRegex.default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isSurrogatePair.js
var require_isSurrogatePair = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isSurrogatePair = function(str) {
    (0, _assertString.default)(str);
    return surrogatePair.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSurrogatePair;
  var _assertString = _interopRequireDefault(require_assertString());
  var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/util/includes.js
var require_includes = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var includes = function includes(arr, val) {
    return arr.some(function(arrVal) {
      return val === arrVal;
    });
  };
  var _default = includes;
  exports.default = _default;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isDecimal.js
var require_isDecimal = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var decimalRegExp = function(options) {
    var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? "" : "?", "$"));
    return regExp;
  };
  var isDecimal = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_decimal_options);
    if (options.locale in _alpha.decimal) {
      return !(0, _includes.default)(blacklist, str.replace(/ /g, "")) && decimalRegExp(options).test(str);
    }
    throw new Error("Invalid locale '".concat(options.locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDecimal;
  var _merge = _interopRequireDefault(require_merge());
  var _assertString = _interopRequireDefault(require_assertString());
  var _includes = _interopRequireDefault(require_includes());
  var _alpha = require_alpha();
  var default_decimal_options = {
    force_decimal: false,
    decimal_digits: "1,",
    locale: "en-US"
  };
  var blacklist = ["", "-", "+"];
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isHexadecimal.js
var require_isHexadecimal = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isHexadecimal = function(str) {
    (0, _assertString.default)(str);
    return hexadecimal.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHexadecimal;
  var _assertString = _interopRequireDefault(require_assertString());
  var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isOctal.js
var require_isOctal = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isOctal = function(str) {
    (0, _assertString.default)(str);
    return octal.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isOctal;
  var _assertString = _interopRequireDefault(require_assertString());
  var octal = /^(0o)?[0-7]+$/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isDivisibleBy.js
var require_isDivisibleBy = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isDivisibleBy = function(str, num) {
    (0, _assertString.default)(str);
    return (0, _toFloat.default)(str) % parseInt(num, 10) === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDivisibleBy;
  var _assertString = _interopRequireDefault(require_assertString());
  var _toFloat = _interopRequireDefault(require_toFloat());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isHexColor.js
var require_isHexColor = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isHexColor = function(str) {
    (0, _assertString.default)(str);
    return hexcolor.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHexColor;
  var _assertString = _interopRequireDefault(require_assertString());
  var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isRgbColor.js
var require_isRgbColor = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isRgbColor = function(str) {
    var includePercentValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    (0, _assertString.default)(str);
    if (!includePercentValues) {
      return rgbColor.test(str) || rgbaColor.test(str);
    }
    return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isRgbColor;
  var _assertString = _interopRequireDefault(require_assertString());
  var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
  var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
  var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
  var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isHSL.js
var require_isHSL = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isHSL = function(str) {
    (0, _assertString.default)(str);
    var strippedStr = str.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/ig, "$1");
    if (strippedStr.indexOf(",") !== -1) {
      return hslComma.test(strippedStr);
    }
    return hslSpace.test(strippedStr);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHSL;
  var _assertString = _interopRequireDefault(require_assertString());
  var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
  var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISRC.js
var require_isISRC = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISRC = function(str) {
    (0, _assertString.default)(str);
    return isrc.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISRC;
  var _assertString = _interopRequireDefault(require_assertString());
  var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isIBAN.js
var require_isIBAN = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var hasOnlyValidCountryCodes = function(countryCodeArray) {
    var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function(countryCode) {
      return !(countryCode in ibanRegexThroughCountryCode);
    });
    if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
      return false;
    }
    return true;
  };
  var hasValidIbanFormat = function(str, options) {
    var strippedStr = str.replace(/[\s\-]+/gi, "").toUpperCase();
    var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
    var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
    if (options.whitelist) {
      if (!hasOnlyValidCountryCodes(options.whitelist)) {
        return false;
      }
      var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);
      if (!isoCountryCodeInWhiteList) {
        return false;
      }
    }
    if (options.blacklist) {
      var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);
      if (isoCountryCodeInBlackList) {
        return false;
      }
    }
    return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
  };
  var hasValidIbanChecksum = function(str) {
    var strippedStr = str.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
    var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
    var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function(char) {
      return char.charCodeAt(0) - 55;
    });
    var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function(acc, value15) {
      return Number(acc + value15) % 97;
    }, "");
    return remainder === 1;
  };
  var isIBAN = function(str) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assertString.default)(str);
    return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIBAN;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var ibanRegexThroughCountryCode = {
    AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
    AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
    AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
    AT: /^(AT[0-9]{2})\d{16}$/,
    AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    BA: /^(BA[0-9]{2})\d{16}$/,
    BE: /^(BE[0-9]{2})\d{12}$/,
    BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
    BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
    BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
    BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
    CR: /^(CR[0-9]{2})\d{18}$/,
    CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
    CZ: /^(CZ[0-9]{2})\d{20}$/,
    DE: /^(DE[0-9]{2})\d{18}$/,
    DK: /^(DK[0-9]{2})\d{14}$/,
    DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
    EE: /^(EE[0-9]{2})\d{16}$/,
    EG: /^(EG[0-9]{2})\d{25}$/,
    ES: /^(ES[0-9]{2})\d{20}$/,
    FI: /^(FI[0-9]{2})\d{14}$/,
    FO: /^(FO[0-9]{2})\d{14}$/,
    FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
    GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
    GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
    GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
    GL: /^(GL[0-9]{2})\d{14}$/,
    GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
    GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
    HR: /^(HR[0-9]{2})\d{17}$/,
    HU: /^(HU[0-9]{2})\d{24}$/,
    IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
    IL: /^(IL[0-9]{2})\d{19}$/,
    IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
    IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
    IS: /^(IS[0-9]{2})\d{22}$/,
    IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
    JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
    KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
    KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
    LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
    LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
    LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
    LT: /^(LT[0-9]{2})\d{16}$/,
    LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
    LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
    MA: /^(MA[0-9]{26})$/,
    MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
    MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
    ME: /^(ME[0-9]{2})\d{18}$/,
    MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
    MR: /^(MR[0-9]{2})\d{23}$/,
    MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
    MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
    MZ: /^(MZ[0-9]{2})\d{21}$/,
    NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
    NO: /^(NO[0-9]{2})\d{11}$/,
    PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
    PL: /^(PL[0-9]{2})\d{24}$/,
    PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
    PT: /^(PT[0-9]{2})\d{21}$/,
    QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
    RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
    RS: /^(RS[0-9]{2})\d{18}$/,
    SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
    SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
    SE: /^(SE[0-9]{2})\d{20}$/,
    SI: /^(SI[0-9]{2})\d{15}$/,
    SK: /^(SK[0-9]{2})\d{20}$/,
    SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
    SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
    TL: /^(TL[0-9]{2})\d{19}$/,
    TN: /^(TN[0-9]{2})\d{20}$/,
    TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
    UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
    VA: /^(VA[0-9]{2})\d{18}$/,
    VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
    XK: /^(XK[0-9]{2})\d{16}$/
  };
  var locales = Object.keys(ibanRegexThroughCountryCode);
  exports.locales = locales;
});

// node_modules/validator/lib/isISO31661Alpha2.js
var require_isISO31661Alpha2 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISO31661Alpha2 = function(str) {
    (0, _assertString.default)(str);
    return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO31661Alpha2;
  exports.CountryCodes = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var validISO31661Alpha2CountriesCodes = new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]);
  var CountryCodes = validISO31661Alpha2CountriesCodes;
  exports.CountryCodes = CountryCodes;
});

// node_modules/validator/lib/isBIC.js
var require_isBIC = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isBIC = function(str) {
    (0, _assertString.default)(str);
    var countryCode = str.slice(4, 6).toUpperCase();
    if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== "XK") {
      return false;
    }
    return isBICReg.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBIC;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isISO31661Alpha = require_isISO31661Alpha2();
  var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMD5.js
var require_isMD5 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isMD5 = function(str) {
    (0, _assertString.default)(str);
    return md5.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMD5;
  var _assertString = _interopRequireDefault(require_assertString());
  var md5 = /^[a-f0-9]{32}$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isHash.js
var require_isHash = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isHash = function(str, algorithm) {
    (0, _assertString.default)(str);
    var hash7 = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
    return hash7.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isHash;
  var _assertString = _interopRequireDefault(require_assertString());
  var lengths = {
    md5: 32,
    md4: 32,
    sha1: 40,
    sha256: 64,
    sha384: 96,
    sha512: 128,
    ripemd128: 32,
    ripemd160: 40,
    tiger128: 32,
    tiger160: 40,
    tiger192: 48,
    crc32: 8,
    crc32b: 8
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isBase64.js
var require_isBase64 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isBase64 = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, defaultBase64Options);
    var len = str.length;
    if (options.urlSafe) {
      return urlSafeBase64.test(str);
    }
    if (len % 4 !== 0 || notBase64.test(str)) {
      return false;
    }
    var firstPaddingChar = str.indexOf("=");
    return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === "=";
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase64;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var notBase64 = /[^A-Z0-9+\/=]/i;
  var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
  var defaultBase64Options = {
    urlSafe: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isJWT.js
var require_isJWT = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isJWT = function(str) {
    (0, _assertString.default)(str);
    var dotSplit = str.split(".");
    var len = dotSplit.length;
    if (len !== 3) {
      return false;
    }
    return dotSplit.reduce(function(acc, currElem) {
      return acc && (0, _isBase.default)(currElem, {
        urlSafe: true
      });
    }, true);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isJWT;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isBase = _interopRequireDefault(require_isBase64());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isJSON.js
var require_isJSON = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var isJSON = function(str, options) {
    (0, _assertString.default)(str);
    try {
      options = (0, _merge.default)(options, default_json_options);
      var primitives = [];
      if (options.allow_primitives) {
        primitives = [null, false, true];
      }
      var obj = JSON.parse(str);
      return primitives.includes(obj) || !!obj && _typeof(obj) === "object";
    } catch (e2) {
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isJSON;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var default_json_options = {
    allow_primitives: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isEmpty.js
var require_isEmpty = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isEmpty = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_is_empty_options);
    return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEmpty;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var default_is_empty_options = {
    ignore_whitespace: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isLength.js
var require_isLength = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var isLength = function(str, options) {
    (0, _assertString.default)(str);
    var min;
    var max;
    if (_typeof(options) === "object") {
      min = options.min || 0;
      max = options.max;
    } else {
      min = arguments[1] || 0;
      max = arguments[2];
    }
    var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
    var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
    var len = str.length - presentationSequences.length - surrogatePairs.length;
    return len >= min && (typeof max === "undefined" || len <= max);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLength;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isUUID.js
var require_isUUID = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isUUID = function(str, version) {
    (0, _assertString.default)(str);
    var pattern3 = uuid[![undefined, null].includes(version) ? version : "all"];
    return !!pattern3 && pattern3.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isUUID;
  var _assertString = _interopRequireDefault(require_assertString());
  var uuid = {
    1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMongoId.js
var require_isMongoId = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isMongoId = function(str) {
    (0, _assertString.default)(str);
    return (0, _isHexadecimal.default)(str) && str.length === 24;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMongoId;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isAfter.js
var require_isAfter = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isAfter = function(date6, options) {
    var comparisonDate = (options === null || options === undefined ? undefined : options.comparisonDate) || options || Date().toString();
    var comparison = (0, _toDate.default)(comparisonDate);
    var original = (0, _toDate.default)(date6);
    return !!(original && comparison && original > comparison);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAfter;
  var _toDate = _interopRequireDefault(require_toDate());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isBefore.js
var require_isBefore = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isBefore = function(str) {
    var date6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date);
    (0, _assertString.default)(str);
    var comparison = (0, _toDate.default)(date6);
    var original = (0, _toDate.default)(str);
    return !!(original && comparison && original < comparison);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBefore;
  var _assertString = _interopRequireDefault(require_assertString());
  var _toDate = _interopRequireDefault(require_toDate());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isIn.js
var require_isIn = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var isIn = function(str, options) {
    (0, _assertString.default)(str);
    var i;
    if (Object.prototype.toString.call(options) === "[object Array]") {
      var array5 = [];
      for (i in options) {
        if ({}.hasOwnProperty.call(options, i)) {
          array5[i] = (0, _toString.default)(options[i]);
        }
      }
      return array5.indexOf(str) >= 0;
    } else if (_typeof(options) === "object") {
      return options.hasOwnProperty(str);
    } else if (options && typeof options.indexOf === "function") {
      return options.indexOf(str) >= 0;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIn;
  var _assertString = _interopRequireDefault(require_assertString());
  var _toString = _interopRequireDefault(require_toString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isLuhnNumber.js
var require_isLuhnNumber = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isLuhnNumber = function(str) {
    (0, _assertString.default)(str);
    var sanitized = str.replace(/[- ]+/g, "");
    var sum = 0;
    var digit;
    var tmpNum;
    var shouldDouble;
    for (var i = sanitized.length - 1;i >= 0; i--) {
      digit = sanitized.substring(i, i + 1);
      tmpNum = parseInt(digit, 10);
      if (shouldDouble) {
        tmpNum *= 2;
        if (tmpNum >= 10) {
          sum += tmpNum % 10 + 1;
        } else {
          sum += tmpNum;
        }
      } else {
        sum += tmpNum;
      }
      shouldDouble = !shouldDouble;
    }
    return !!(sum % 10 === 0 ? sanitized : false);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLuhnNumber;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isCreditCard.js
var require_isCreditCard = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isCreditCard = function(card) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assertString.default)(card);
    var provider = options.provider;
    var sanitized = card.replace(/[- ]+/g, "");
    if (provider && provider.toLowerCase() in cards) {
      if (!cards[provider.toLowerCase()].test(sanitized)) {
        return false;
      }
    } else if (provider && !(provider.toLowerCase() in cards)) {
      throw new Error("".concat(provider, " is not a valid credit card provider."));
    } else if (!allCards.some(function(cardProvider) {
      return cardProvider.test(sanitized);
    })) {
      return false;
    }
    return (0, _isLuhnNumber.default)(card);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCreditCard;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
  var cards = {
    amex: /^3[47][0-9]{13}$/,
    dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
    discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
    jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
    mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
    unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
    visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
  };
  var allCards = function() {
    var tmpCardsArray = [];
    for (var cardProvider in cards) {
      if (cards.hasOwnProperty(cardProvider)) {
        tmpCardsArray.push(cards[cardProvider]);
      }
    }
    return tmpCardsArray;
  }();
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isIdentityCard.js
var require_isIdentityCard = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isIdentityCard = function(str, locale) {
    (0, _assertString.default)(str);
    if (locale in validators) {
      return validators[locale](str);
    } else if (locale === "any") {
      for (var key in validators) {
        if (validators.hasOwnProperty(key)) {
          var validator = validators[key];
          if (validator(str)) {
            return true;
          }
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isIdentityCard;
  var _assertString = _interopRequireDefault(require_assertString());
  var _isInt = _interopRequireDefault(require_isInt());
  var validators = {
    PL: function PL(str) {
      (0, _assertString.default)(str);
      var weightOfDigits = {
        1: 1,
        2: 3,
        3: 7,
        4: 9,
        5: 1,
        6: 3,
        7: 7,
        8: 9,
        9: 1,
        10: 3,
        11: 0
      };
      if (str != null && str.length === 11 && (0, _isInt.default)(str, {
        allow_leading_zeroes: true
      })) {
        var digits = str.split("").slice(0, -1);
        var sum = digits.reduce(function(acc, digit, index) {
          return acc + Number(digit) * weightOfDigits[index + 1];
        }, 0);
        var modulo = sum % 10;
        var lastDigit = Number(str.charAt(str.length - 1));
        if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
          return true;
        }
      }
      return false;
    },
    ES: function ES(str) {
      (0, _assertString.default)(str);
      var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
      var charsValue = {
        X: 0,
        Y: 1,
        Z: 2
      };
      var controlDigits = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
      var sanitized = str.trim().toUpperCase();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var number7 = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function(char) {
        return charsValue[char];
      });
      return sanitized.endsWith(controlDigits[number7 % 23]);
    },
    FI: function FI(str) {
      (0, _assertString.default)(str);
      if (str.length !== 11) {
        return false;
      }
      if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
        return false;
      }
      var checkDigits = "0123456789ABCDEFHJKLMNPRSTUVWXY";
      var idAsNumber = parseInt(str.slice(0, 6), 10) * 1000 + parseInt(str.slice(7, 10), 10);
      var remainder = idAsNumber % 31;
      var checkDigit = checkDigits[remainder];
      return checkDigit === str.slice(10, 11);
    },
    IN: function IN(str) {
      var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;
      var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
      var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
      var sanitized = str.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var c = 0;
      var invertedArray = sanitized.replace(/\s/g, "").split("").map(Number).reverse();
      invertedArray.forEach(function(val, i) {
        c = d[c][p[i % 8][val]];
      });
      return c === 0;
    },
    IR: function IR(str) {
      if (!str.match(/^\d{10}$/))
        return false;
      str = "0000".concat(str).slice(str.length - 6);
      if (parseInt(str.slice(3, 9), 10) === 0)
        return false;
      var lastNumber = parseInt(str.slice(9, 10), 10);
      var sum = 0;
      for (var i = 0;i < 9; i++) {
        sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
      }
      sum %= 11;
      return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
    },
    IT: function IT(str) {
      if (str.length !== 9)
        return false;
      if (str === "CA00000AA")
        return false;
      return str.search(/C[A-Z][0-9]{5}[A-Z]{2}/i) > -1;
    },
    NO: function NO(str) {
      var sanitized = str.trim();
      if (isNaN(Number(sanitized)))
        return false;
      if (sanitized.length !== 11)
        return false;
      if (sanitized === "00000000000")
        return false;
      var f = sanitized.split("").map(Number);
      var k1 = (11 - (3 * f[0] + 7 * f[1] + 6 * f[2] + 1 * f[3] + 8 * f[4] + 9 * f[5] + 4 * f[6] + 5 * f[7] + 2 * f[8]) % 11) % 11;
      var k2 = (11 - (5 * f[0] + 4 * f[1] + 3 * f[2] + 2 * f[3] + 7 * f[4] + 6 * f[5] + 5 * f[6] + 4 * f[7] + 3 * f[8] + 2 * k1) % 11) % 11;
      if (k1 !== f[9] || k2 !== f[10])
        return false;
      return true;
    },
    TH: function TH(str) {
      if (!str.match(/^[1-8]\d{12}$/))
        return false;
      var sum = 0;
      for (var i = 0;i < 12; i++) {
        sum += parseInt(str[i], 10) * (13 - i);
      }
      return str[12] === ((11 - sum % 11) % 10).toString();
    },
    LK: function LK(str) {
      var old_nic = /^[1-9]\d{8}[vx]$/i;
      var new_nic = /^[1-9]\d{11}$/i;
      if (str.length === 10 && old_nic.test(str))
        return true;
      else if (str.length === 12 && new_nic.test(str))
        return true;
      return false;
    },
    "he-IL": function heIL(str) {
      var DNI = /^\d{9}$/;
      var sanitized = str.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      var id = sanitized;
      var sum = 0, incNum;
      for (var i = 0;i < id.length; i++) {
        incNum = Number(id[i]) * (i % 2 + 1);
        sum += incNum > 9 ? incNum - 9 : incNum;
      }
      return sum % 10 === 0;
    },
    "ar-LY": function arLY(str) {
      var NIN = /^(1|2)\d{11}$/;
      var sanitized = str.trim();
      if (!NIN.test(sanitized)) {
        return false;
      }
      return true;
    },
    "ar-TN": function arTN(str) {
      var DNI = /^\d{8}$/;
      var sanitized = str.trim();
      if (!DNI.test(sanitized)) {
        return false;
      }
      return true;
    },
    "zh-CN": function zhCN(str) {
      var provincesAndCities = [
        "11",
        "12",
        "13",
        "14",
        "15",
        "21",
        "22",
        "23",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "50",
        "51",
        "52",
        "53",
        "54",
        "61",
        "62",
        "63",
        "64",
        "65",
        "71",
        "81",
        "82",
        "91"
      ];
      var powers = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"];
      var parityBit = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"];
      var checkAddressCode = function checkAddressCode(addressCode) {
        return provincesAndCities.includes(addressCode);
      };
      var checkBirthDayCode = function checkBirthDayCode(birDayCode) {
        var yyyy = parseInt(birDayCode.substring(0, 4), 10);
        var mm = parseInt(birDayCode.substring(4, 6), 10);
        var dd = parseInt(birDayCode.substring(6), 10);
        var xdata = new Date(yyyy, mm - 1, dd);
        if (xdata > new Date) {
          return false;
        } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
          return true;
        }
        return false;
      };
      var getParityBit = function getParityBit(idCardNo) {
        var id17 = idCardNo.substring(0, 17);
        var power = 0;
        for (var i = 0;i < 17; i++) {
          power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
        }
        var mod = power % 11;
        return parityBit[mod];
      };
      var checkParityBit = function checkParityBit(idCardNo) {
        return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
      };
      var check15IdCardNo = function check15IdCardNo(idCardNo) {
        var check11 = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
        if (!check11)
          return false;
        var addressCode = idCardNo.substring(0, 2);
        check11 = checkAddressCode(addressCode);
        if (!check11)
          return false;
        var birDayCode = "19".concat(idCardNo.substring(6, 12));
        check11 = checkBirthDayCode(birDayCode);
        if (!check11)
          return false;
        return true;
      };
      var check18IdCardNo = function check18IdCardNo(idCardNo) {
        var check11 = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
        if (!check11)
          return false;
        var addressCode = idCardNo.substring(0, 2);
        check11 = checkAddressCode(addressCode);
        if (!check11)
          return false;
        var birDayCode = idCardNo.substring(6, 14);
        check11 = checkBirthDayCode(birDayCode);
        if (!check11)
          return false;
        return checkParityBit(idCardNo);
      };
      var checkIdCardNo = function checkIdCardNo(idCardNo) {
        var check11 = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
        if (!check11)
          return false;
        if (idCardNo.length === 15) {
          return check15IdCardNo(idCardNo);
        }
        return check18IdCardNo(idCardNo);
      };
      return checkIdCardNo(str);
    },
    "zh-HK": function zhHK(str) {
      str = str.trim();
      var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
      var regexIsDigit = /^[0-9]$/;
      str = str.toUpperCase();
      if (!regexHKID.test(str))
        return false;
      str = str.replace(/\[|\]|\(|\)/g, "");
      if (str.length === 8)
        str = "3".concat(str);
      var checkSumVal = 0;
      for (var i = 0;i <= 7; i++) {
        var convertedChar = undefined;
        if (!regexIsDigit.test(str[i]))
          convertedChar = (str[i].charCodeAt(0) - 55) % 11;
        else
          convertedChar = str[i];
        checkSumVal += convertedChar * (9 - i);
      }
      checkSumVal %= 11;
      var checkSumConverted;
      if (checkSumVal === 0)
        checkSumConverted = "0";
      else if (checkSumVal === 1)
        checkSumConverted = "A";
      else
        checkSumConverted = String(11 - checkSumVal);
      if (checkSumConverted === str[str.length - 1])
        return true;
      return false;
    },
    "zh-TW": function zhTW(str) {
      var ALPHABET_CODES = {
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        G: 16,
        H: 17,
        I: 34,
        J: 18,
        K: 19,
        L: 20,
        M: 21,
        N: 22,
        O: 35,
        P: 23,
        Q: 24,
        R: 25,
        S: 26,
        T: 27,
        U: 28,
        V: 29,
        W: 32,
        X: 30,
        Y: 31,
        Z: 33
      };
      var sanitized = str.trim().toUpperCase();
      if (!/^[A-Z][0-9]{9}$/.test(sanitized))
        return false;
      return Array.from(sanitized).reduce(function(sum, number7, index) {
        if (index === 0) {
          var code = ALPHABET_CODES[number7];
          return code % 10 * 9 + Math.floor(code / 10);
        }
        if (index === 9) {
          return (10 - sum % 10 - Number(number7)) % 10 === 0;
        }
        return sum + Number(number7) * (9 - index);
      }, 0);
    }
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isEAN.js
var require_isEAN = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var getPositionWeightThroughLengthAndIndex = function(length, index) {
    if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
      return index % 2 === 0 ? 3 : 1;
    }
    return index % 2 === 0 ? 1 : 3;
  };
  var calculateCheckDigit = function(ean) {
    var checksum2 = ean.slice(0, -1).split("").map(function(char, index) {
      return Number(char) * getPositionWeightThroughLengthAndIndex(ean.length, index);
    }).reduce(function(acc, partialSum) {
      return acc + partialSum;
    }, 0);
    var remainder = 10 - checksum2 % 10;
    return remainder < 10 ? remainder : 0;
  };
  var isEAN = function(str) {
    (0, _assertString.default)(str);
    var actualCheckDigit = Number(str.slice(-1));
    return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEAN;
  var _assertString = _interopRequireDefault(require_assertString());
  var LENGTH_EAN_8 = 8;
  var LENGTH_EAN_14 = 14;
  var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISIN.js
var require_isISIN = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISIN = function(str) {
    (0, _assertString.default)(str);
    if (!isin.test(str)) {
      return false;
    }
    var double = true;
    var sum = 0;
    for (var i = str.length - 2;i >= 0; i--) {
      if (str[i] >= "A" && str[i] <= "Z") {
        var value15 = str[i].charCodeAt(0) - 55;
        var lo = value15 % 10;
        var hi = Math.trunc(value15 / 10);
        for (var _i = 0, _arr = [lo, hi];_i < _arr.length; _i++) {
          var digit = _arr[_i];
          if (double) {
            if (digit >= 5) {
              sum += 1 + (digit - 5) * 2;
            } else {
              sum += digit * 2;
            }
          } else {
            sum += digit;
          }
          double = !double;
        }
      } else {
        var _digit = str[i].charCodeAt(0) - "0".charCodeAt(0);
        if (double) {
          if (_digit >= 5) {
            sum += 1 + (_digit - 5) * 2;
          } else {
            sum += _digit * 2;
          }
        } else {
          sum += _digit;
        }
        double = !double;
      }
    }
    var check11 = Math.trunc((sum + 9) / 10) * 10 - sum;
    return +str[str.length - 1] === check11;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISIN;
  var _assertString = _interopRequireDefault(require_assertString());
  var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISBN.js
var require_isISBN = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISBN = function(isbn, options) {
    (0, _assertString.default)(isbn);
    var version = String((options === null || options === undefined ? undefined : options.version) || options);
    if (!(options !== null && options !== undefined && options.version || options)) {
      return isISBN(isbn, {
        version: 10
      }) || isISBN(isbn, {
        version: 13
      });
    }
    var sanitizedIsbn = isbn.replace(/[\s-]+/g, "");
    var checksum2 = 0;
    if (version === "10") {
      if (!possibleIsbn10.test(sanitizedIsbn)) {
        return false;
      }
      for (var i = 0;i < version - 1; i++) {
        checksum2 += (i + 1) * sanitizedIsbn.charAt(i);
      }
      if (sanitizedIsbn.charAt(9) === "X") {
        checksum2 += 10 * 10;
      } else {
        checksum2 += 10 * sanitizedIsbn.charAt(9);
      }
      if (checksum2 % 11 === 0) {
        return true;
      }
    } else if (version === "13") {
      if (!possibleIsbn13.test(sanitizedIsbn)) {
        return false;
      }
      for (var _i = 0;_i < 12; _i++) {
        checksum2 += factor[_i % 2] * sanitizedIsbn.charAt(_i);
      }
      if (sanitizedIsbn.charAt(12) - (10 - checksum2 % 10) % 10 === 0) {
        return true;
      }
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISBN;
  var _assertString = _interopRequireDefault(require_assertString());
  var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
  var possibleIsbn13 = /^(?:[0-9]{13})$/;
  var factor = [1, 3];
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISSN.js
var require_isISSN = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISSN = function(str) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assertString.default)(str);
    var testIssn = issn;
    testIssn = options.require_hyphen ? testIssn.replace("?", "") : testIssn;
    testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, "i");
    if (!testIssn.test(str)) {
      return false;
    }
    var digits = str.replace("-", "").toUpperCase();
    var checksum2 = 0;
    for (var i = 0;i < digits.length; i++) {
      var digit = digits[i];
      checksum2 += (digit === "X" ? 10 : +digit) * (8 - i);
    }
    return checksum2 % 11 === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISSN;
  var _assertString = _interopRequireDefault(require_assertString());
  var issn = "^\\d{4}-?\\d{3}[\\dX]$";
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/util/algorithms.js
var require_algorithms = __commonJS((exports) => {
  var iso7064Check = function(str) {
    var checkvalue = 10;
    for (var i = 0;i < str.length - 1; i++) {
      checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;
    }
    checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
    return checkvalue === parseInt(str[10], 10);
  };
  var luhnCheck = function(str) {
    var checksum2 = 0;
    var second = false;
    for (var i = str.length - 1;i >= 0; i--) {
      if (second) {
        var product = parseInt(str[i], 10) * 2;
        if (product > 9) {
          checksum2 += product.toString().split("").map(function(a2) {
            return parseInt(a2, 10);
          }).reduce(function(a2, b) {
            return a2 + b;
          }, 0);
        } else {
          checksum2 += product;
        }
      } else {
        checksum2 += parseInt(str[i], 10);
      }
      second = !second;
    }
    return checksum2 % 10 === 0;
  };
  var reverseMultiplyAndSum = function(digits, base) {
    var total = 0;
    for (var i = 0;i < digits.length; i++) {
      total += digits[i] * (base - i);
    }
    return total;
  };
  var verhoeffCheck = function(str) {
    var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
    var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];
    var str_copy = str.split("").reverse().join("");
    var checksum2 = 0;
    for (var i = 0;i < str_copy.length; i++) {
      checksum2 = d_table[checksum2][p_table[i % 8][parseInt(str_copy[i], 10)]];
    }
    return checksum2 === 0;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.iso7064Check = iso7064Check;
  exports.luhnCheck = luhnCheck;
  exports.reverseMultiplyAndSum = reverseMultiplyAndSum;
  exports.verhoeffCheck = verhoeffCheck;
});

// node_modules/validator/lib/isTaxID.js
var require_isTaxID = __commonJS((exports, module) => {
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var _getRequireWildcardCache = function() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap;
    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };
    return cache;
  };
  var _interopRequireWildcard = function(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  };
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _toConsumableArray = function(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  };
  var _nonIterableSpread = function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  };
  var _unsupportedIterableToArray = function(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  };
  var _iterableToArray = function(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
      return Array.from(iter);
  };
  var _arrayWithoutHoles = function(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  };
  var _arrayLikeToArray = function(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  };
  var bgBgCheck = function(tin) {
    var century_year = tin.slice(0, 2);
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 40) {
      month -= 40;
      century_year = "20".concat(century_year);
    } else if (month > 20) {
      month -= 20;
      century_year = "18".concat(century_year);
    } else {
      century_year = "19".concat(century_year);
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date6 = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a2) {
      return parseInt(a2, 10);
    });
    var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
    var checksum2 = 0;
    for (var i = 0;i < multip_lookup.length; i++) {
      checksum2 += digits[i] * multip_lookup[i];
    }
    checksum2 = checksum2 % 11 === 10 ? 0 : checksum2 % 11;
    return checksum2 === digits[9];
  };
  var isCanadianSIN = function(input) {
    var digitsArray = input.split("");
    var even = digitsArray.filter(function(_, idx) {
      return idx % 2;
    }).map(function(i) {
      return Number(i) * 2;
    }).join("").split("");
    var total = digitsArray.filter(function(_, idx) {
      return !(idx % 2);
    }).concat(even).map(function(i) {
      return Number(i);
    }).reduce(function(acc, cur) {
      return acc + cur;
    });
    return total % 10 === 0;
  };
  var csCzCheck = function(tin) {
    tin = tin.replace(/\W/, "");
    var full_year = parseInt(tin.slice(0, 2), 10);
    if (tin.length === 10) {
      if (full_year < 54) {
        full_year = "20".concat(full_year);
      } else {
        full_year = "19".concat(full_year);
      }
    } else {
      if (tin.slice(6) === "000") {
        return false;
      }
      if (full_year < 54) {
        full_year = "19".concat(full_year);
      } else {
        return false;
      }
    }
    if (full_year.length === 3) {
      full_year = [full_year.slice(0, 2), "0", full_year.slice(2)].join("");
    }
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 50) {
      month -= 50;
    }
    if (month > 20) {
      if (parseInt(full_year, 10) < 2004) {
        return false;
      }
      month -= 20;
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date6 = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    if (tin.length === 10) {
      if (parseInt(tin, 10) % 11 !== 0) {
        var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
        if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
          if (parseInt(tin.slice(9), 10) !== 0) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
    return true;
  };
  var deAtCheck = function(tin) {
    return algorithms.luhnCheck(tin);
  };
  var deDeCheck = function(tin) {
    var digits = tin.split("").map(function(a2) {
      return parseInt(a2, 10);
    });
    var occurences = [];
    for (var i = 0;i < digits.length - 1; i++) {
      occurences.push("");
      for (var j = 0;j < digits.length - 1; j++) {
        if (digits[i] === digits[j]) {
          occurences[i] += j;
        }
      }
    }
    occurences = occurences.filter(function(a2) {
      return a2.length > 1;
    });
    if (occurences.length !== 2 && occurences.length !== 3) {
      return false;
    }
    if (occurences[0].length === 3) {
      var trip_locations = occurences[0].split("").map(function(a2) {
        return parseInt(a2, 10);
      });
      var recurrent = 0;
      for (var _i = 0;_i < trip_locations.length - 1; _i++) {
        if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
          recurrent += 1;
        }
      }
      if (recurrent === 2) {
        return false;
      }
    }
    return algorithms.iso7064Check(tin);
  };
  var dkDkCheck = function(tin) {
    tin = tin.replace(/\W/, "");
    var year = parseInt(tin.slice(4, 6), 10);
    var century_digit = tin.slice(6, 7);
    switch (century_digit) {
      case "0":
      case "1":
      case "2":
      case "3":
        year = "19".concat(year);
        break;
      case "4":
      case "9":
        if (year < 37) {
          year = "20".concat(year);
        } else {
          year = "19".concat(year);
        }
        break;
      default:
        if (year < 37) {
          year = "20".concat(year);
        } else if (year > 58) {
          year = "18".concat(year);
        } else {
          return false;
        }
        break;
    }
    if (year.length === 3) {
      year = [year.slice(0, 2), "0", year.slice(2)].join("");
    }
    var date6 = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
    if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a2) {
      return parseInt(a2, 10);
    });
    var checksum2 = 0;
    var weight = 4;
    for (var i = 0;i < 9; i++) {
      checksum2 += digits[i] * weight;
      weight -= 1;
      if (weight === 1) {
        weight = 7;
      }
    }
    checksum2 %= 11;
    if (checksum2 === 1) {
      return false;
    }
    return checksum2 === 0 ? digits[9] === 0 : digits[9] === 11 - checksum2;
  };
  var elCyCheck = function(tin) {
    var digits = tin.slice(0, 8).split("").map(function(a2) {
      return parseInt(a2, 10);
    });
    var checksum2 = 0;
    for (var i = 1;i < digits.length; i += 2) {
      checksum2 += digits[i];
    }
    for (var _i2 = 0;_i2 < digits.length; _i2 += 2) {
      if (digits[_i2] < 2) {
        checksum2 += 1 - digits[_i2];
      } else {
        checksum2 += 2 * (digits[_i2] - 2) + 5;
        if (digits[_i2] > 4) {
          checksum2 += 2;
        }
      }
    }
    return String.fromCharCode(checksum2 % 26 + 65) === tin.charAt(8);
  };
  var elGrCheck = function(tin) {
    var digits = tin.split("").map(function(a2) {
      return parseInt(a2, 10);
    });
    var checksum2 = 0;
    for (var i = 0;i < 8; i++) {
      checksum2 += digits[i] * Math.pow(2, 8 - i);
    }
    return checksum2 % 11 % 10 === digits[8];
  };
  var enIeCheck = function(tin) {
    var checksum2 = algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a2) {
      return parseInt(a2, 10);
    }), 8);
    if (tin.length === 9 && tin[8] !== "W") {
      checksum2 += (tin[8].charCodeAt(0) - 64) * 9;
    }
    checksum2 %= 23;
    if (checksum2 === 0) {
      return tin[7].toUpperCase() === "W";
    }
    return tin[7].toUpperCase() === String.fromCharCode(64 + checksum2);
  };
  var enUsGetPrefixes = function() {
    var prefixes = [];
    for (var location in enUsCampusPrefix) {
      if (enUsCampusPrefix.hasOwnProperty(location)) {
        prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
      }
    }
    return prefixes;
  };
  var enUsCheck = function(tin) {
    return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
  };
  var esEsCheck = function(tin) {
    var chars = tin.toUpperCase().split("");
    if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
      var lead_replace = 0;
      switch (chars[0]) {
        case "Y":
          lead_replace = 1;
          break;
        case "Z":
          lead_replace = 2;
          break;
        default:
      }
      chars.splice(0, 1, lead_replace);
    } else {
      while (chars.length < 9) {
        chars.unshift(0);
      }
    }
    var lookup = ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"];
    chars = chars.join("");
    var checksum2 = parseInt(chars.slice(0, 8), 10) % 23;
    return chars[8] === lookup[checksum2];
  };
  var etEeCheck = function(tin) {
    var full_year = tin.slice(1, 3);
    var century_digit = tin.slice(0, 1);
    switch (century_digit) {
      case "1":
      case "2":
        full_year = "18".concat(full_year);
        break;
      case "3":
      case "4":
        full_year = "19".concat(full_year);
        break;
      default:
        full_year = "20".concat(full_year);
        break;
    }
    var date6 = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
    if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    var digits = tin.split("").map(function(a2) {
      return parseInt(a2, 10);
    });
    var checksum2 = 0;
    var weight = 1;
    for (var i = 0;i < 10; i++) {
      checksum2 += digits[i] * weight;
      weight += 1;
      if (weight === 10) {
        weight = 1;
      }
    }
    if (checksum2 % 11 === 10) {
      checksum2 = 0;
      weight = 3;
      for (var _i3 = 0;_i3 < 10; _i3++) {
        checksum2 += digits[_i3] * weight;
        weight += 1;
        if (weight === 10) {
          weight = 1;
        }
      }
      if (checksum2 % 11 === 10) {
        return digits[10] === 0;
      }
    }
    return checksum2 % 11 === digits[10];
  };
  var fiFiCheck = function(tin) {
    var full_year = tin.slice(4, 6);
    var century_symbol = tin.slice(6, 7);
    switch (century_symbol) {
      case "+":
        full_year = "18".concat(full_year);
        break;
      case "-":
        full_year = "19".concat(full_year);
        break;
      default:
        full_year = "20".concat(full_year);
        break;
    }
    var date6 = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
    if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    var checksum2 = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
    if (checksum2 < 10) {
      return checksum2 === parseInt(tin.slice(10), 10);
    }
    checksum2 -= 10;
    var letters_lookup = ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"];
    return letters_lookup[checksum2] === tin.slice(10);
  };
  var frBeCheck = function(tin) {
    if (tin.slice(2, 4) !== "00" || tin.slice(4, 6) !== "00") {
      var date6 = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date6, "YY/MM/DD")) {
        return false;
      }
    }
    var checksum2 = 97 - parseInt(tin.slice(0, 9), 10) % 97;
    var checkdigits = parseInt(tin.slice(9, 11), 10);
    if (checksum2 !== checkdigits) {
      checksum2 = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
      if (checksum2 !== checkdigits) {
        return false;
      }
    }
    return true;
  };
  var frFrCheck = function(tin) {
    tin = tin.replace(/\s/g, "");
    var checksum2 = parseInt(tin.slice(0, 10), 10) % 511;
    var checkdigits = parseInt(tin.slice(10, 13), 10);
    return checksum2 === checkdigits;
  };
  var frLuCheck = function(tin) {
    var date6 = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
    if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    if (!algorithms.luhnCheck(tin.slice(0, 12))) {
      return false;
    }
    return algorithms.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
  };
  var hrHrCheck = function(tin) {
    return algorithms.iso7064Check(tin);
  };
  var huHuCheck = function(tin) {
    var digits = tin.split("").map(function(a2) {
      return parseInt(a2, 10);
    });
    var checksum2 = 8;
    for (var i = 1;i < 9; i++) {
      checksum2 += digits[i] * (i + 1);
    }
    return checksum2 % 11 === digits[9];
  };
  var itItNameCheck = function(name) {
    var vowelflag = false;
    var xflag = false;
    for (var i = 0;i < 3; i++) {
      if (!vowelflag && /[AEIOU]/.test(name[i])) {
        vowelflag = true;
      } else if (!xflag && vowelflag && name[i] === "X") {
        xflag = true;
      } else if (i > 0) {
        if (vowelflag && !xflag) {
          if (!/[AEIOU]/.test(name[i])) {
            return false;
          }
        }
        if (xflag) {
          if (!/X/.test(name[i])) {
            return false;
          }
        }
      }
    }
    return true;
  };
  var itItCheck = function(tin) {
    var chars = tin.toUpperCase().split("");
    if (!itItNameCheck(chars.slice(0, 3))) {
      return false;
    }
    if (!itItNameCheck(chars.slice(3, 6))) {
      return false;
    }
    var number_locations = [6, 7, 9, 10, 12, 13, 14];
    var number_replace = {
      L: "0",
      M: "1",
      N: "2",
      P: "3",
      Q: "4",
      R: "5",
      S: "6",
      T: "7",
      U: "8",
      V: "9"
    };
    for (var _i4 = 0, _number_locations = number_locations;_i4 < _number_locations.length; _i4++) {
      var i = _number_locations[_i4];
      if (chars[i] in number_replace) {
        chars.splice(i, 1, number_replace[chars[i]]);
      }
    }
    var month_replace = {
      A: "01",
      B: "02",
      C: "03",
      D: "04",
      E: "05",
      H: "06",
      L: "07",
      M: "08",
      P: "09",
      R: "10",
      S: "11",
      T: "12"
    };
    var month = month_replace[chars[8]];
    var day = parseInt(chars[9] + chars[10], 10);
    if (day > 40) {
      day -= 40;
    }
    if (day < 10) {
      day = "0".concat(day);
    }
    var date6 = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
    if (!(0, _isDate.default)(date6, "YY/MM/DD")) {
      return false;
    }
    var checksum2 = 0;
    for (var _i5 = 1;_i5 < chars.length - 1; _i5 += 2) {
      var char_to_int = parseInt(chars[_i5], 10);
      if (isNaN(char_to_int)) {
        char_to_int = chars[_i5].charCodeAt(0) - 65;
      }
      checksum2 += char_to_int;
    }
    var odd_convert = {
      A: 1,
      B: 0,
      C: 5,
      D: 7,
      E: 9,
      F: 13,
      G: 15,
      H: 17,
      I: 19,
      J: 21,
      K: 2,
      L: 4,
      M: 18,
      N: 20,
      O: 11,
      P: 3,
      Q: 6,
      R: 8,
      S: 12,
      T: 14,
      U: 16,
      V: 10,
      W: 22,
      X: 25,
      Y: 24,
      Z: 23,
      0: 1,
      1: 0
    };
    for (var _i6 = 0;_i6 < chars.length - 1; _i6 += 2) {
      var _char_to_int = 0;
      if (chars[_i6] in odd_convert) {
        _char_to_int = odd_convert[chars[_i6]];
      } else {
        var multiplier = parseInt(chars[_i6], 10);
        _char_to_int = 2 * multiplier + 1;
        if (multiplier > 4) {
          _char_to_int += 2;
        }
      }
      checksum2 += _char_to_int;
    }
    if (String.fromCharCode(65 + checksum2 % 26) !== chars[15]) {
      return false;
    }
    return true;
  };
  var lvLvCheck = function(tin) {
    tin = tin.replace(/\W/, "");
    var day = tin.slice(0, 2);
    if (day !== "32") {
      var month = tin.slice(2, 4);
      if (month !== "00") {
        var full_year = tin.slice(4, 6);
        switch (tin[6]) {
          case "0":
            full_year = "18".concat(full_year);
            break;
          case "1":
            full_year = "19".concat(full_year);
            break;
          default:
            full_year = "20".concat(full_year);
            break;
        }
        var date6 = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
        if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
          return false;
        }
      }
      var checksum2 = 1101;
      var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
      for (var i = 0;i < tin.length - 1; i++) {
        checksum2 -= parseInt(tin[i], 10) * multip_lookup[i];
      }
      return parseInt(tin[10], 10) === checksum2 % 11;
    }
    return true;
  };
  var mtMtCheck = function(tin) {
    if (tin.length !== 9) {
      var chars = tin.toUpperCase().split("");
      while (chars.length < 8) {
        chars.unshift(0);
      }
      switch (tin[7]) {
        case "A":
        case "P":
          if (parseInt(chars[6], 10) === 0) {
            return false;
          }
          break;
        default: {
          var first_part = parseInt(chars.join("").slice(0, 5), 10);
          if (first_part > 32000) {
            return false;
          }
          var second_part = parseInt(chars.join("").slice(5, 7), 10);
          if (first_part === second_part) {
            return false;
          }
        }
      }
    }
    return true;
  };
  var nlNlCheck = function(tin) {
    return algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a2) {
      return parseInt(a2, 10);
    }), 9) % 11 === parseInt(tin[8], 10);
  };
  var plPlCheck = function(tin) {
    if (tin.length === 10) {
      var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
      var _checksum = 0;
      for (var i = 0;i < lookup.length; i++) {
        _checksum += parseInt(tin[i], 10) * lookup[i];
      }
      _checksum %= 11;
      if (_checksum === 10) {
        return false;
      }
      return _checksum === parseInt(tin[9], 10);
    }
    var full_year = tin.slice(0, 2);
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 80) {
      full_year = "18".concat(full_year);
      month -= 80;
    } else if (month > 60) {
      full_year = "22".concat(full_year);
      month -= 60;
    } else if (month > 40) {
      full_year = "21".concat(full_year);
      month -= 40;
    } else if (month > 20) {
      full_year = "20".concat(full_year);
      month -= 20;
    } else {
      full_year = "19".concat(full_year);
    }
    if (month < 10) {
      month = "0".concat(month);
    }
    var date6 = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    var checksum2 = 0;
    var multiplier = 1;
    for (var _i7 = 0;_i7 < tin.length - 1; _i7++) {
      checksum2 += parseInt(tin[_i7], 10) * multiplier % 10;
      multiplier += 2;
      if (multiplier > 10) {
        multiplier = 1;
      } else if (multiplier === 5) {
        multiplier += 2;
      }
    }
    checksum2 = 10 - checksum2 % 10;
    return checksum2 === parseInt(tin[10], 10);
  };
  var ptBrCheck = function(tin) {
    if (tin.length === 11) {
      var _sum;
      var remainder;
      _sum = 0;
      if (tin === "11111111111" || tin === "22222222222" || tin === "33333333333" || tin === "44444444444" || tin === "55555555555" || tin === "66666666666" || tin === "77777777777" || tin === "88888888888" || tin === "99999999999" || tin === "00000000000")
        return false;
      for (var i = 1;i <= 9; i++) {
        _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
      }
      remainder = _sum * 10 % 11;
      if (remainder === 10)
        remainder = 0;
      if (remainder !== parseInt(tin.substring(9, 10), 10))
        return false;
      _sum = 0;
      for (var _i8 = 1;_i8 <= 10; _i8++) {
        _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
      }
      remainder = _sum * 10 % 11;
      if (remainder === 10)
        remainder = 0;
      if (remainder !== parseInt(tin.substring(10, 11), 10))
        return false;
      return true;
    }
    if (tin === "00000000000000" || tin === "11111111111111" || tin === "22222222222222" || tin === "33333333333333" || tin === "44444444444444" || tin === "55555555555555" || tin === "66666666666666" || tin === "77777777777777" || tin === "88888888888888" || tin === "99999999999999") {
      return false;
    }
    var length = tin.length - 2;
    var identifiers = tin.substring(0, length);
    var verificators = tin.substring(length);
    var sum = 0;
    var pos = length - 7;
    for (var _i9 = length;_i9 >= 1; _i9--) {
      sum += identifiers.charAt(length - _i9) * pos;
      pos -= 1;
      if (pos < 2) {
        pos = 9;
      }
    }
    var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
    if (result !== parseInt(verificators.charAt(0), 10)) {
      return false;
    }
    length += 1;
    identifiers = tin.substring(0, length);
    sum = 0;
    pos = length - 7;
    for (var _i10 = length;_i10 >= 1; _i10--) {
      sum += identifiers.charAt(length - _i10) * pos;
      pos -= 1;
      if (pos < 2) {
        pos = 9;
      }
    }
    result = sum % 11 < 2 ? 0 : 11 - sum % 11;
    if (result !== parseInt(verificators.charAt(1), 10)) {
      return false;
    }
    return true;
  };
  var ptPtCheck = function(tin) {
    var checksum2 = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a2) {
      return parseInt(a2, 10);
    }), 9) % 11;
    if (checksum2 > 9) {
      return parseInt(tin[8], 10) === 0;
    }
    return checksum2 === parseInt(tin[8], 10);
  };
  var roRoCheck = function(tin) {
    if (tin.slice(0, 4) !== "9000") {
      var full_year = tin.slice(1, 3);
      switch (tin[0]) {
        case "1":
        case "2":
          full_year = "19".concat(full_year);
          break;
        case "3":
        case "4":
          full_year = "18".concat(full_year);
          break;
        case "5":
        case "6":
          full_year = "20".concat(full_year);
          break;
        default:
      }
      var date6 = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
      if (date6.length === 8) {
        if (!(0, _isDate.default)(date6, "YY/MM/DD")) {
          return false;
        }
      } else if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
        return false;
      }
      var digits = tin.split("").map(function(a2) {
        return parseInt(a2, 10);
      });
      var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
      var checksum2 = 0;
      for (var i = 0;i < multipliers.length; i++) {
        checksum2 += digits[i] * multipliers[i];
      }
      if (checksum2 % 11 === 10) {
        return digits[12] === 1;
      }
      return digits[12] === checksum2 % 11;
    }
    return true;
  };
  var skSkCheck = function(tin) {
    if (tin.length === 9) {
      tin = tin.replace(/\W/, "");
      if (tin.slice(6) === "000") {
        return false;
      }
      var full_year = parseInt(tin.slice(0, 2), 10);
      if (full_year > 53) {
        return false;
      }
      if (full_year < 10) {
        full_year = "190".concat(full_year);
      } else {
        full_year = "19".concat(full_year);
      }
      var month = parseInt(tin.slice(2, 4), 10);
      if (month > 50) {
        month -= 50;
      }
      if (month < 10) {
        month = "0".concat(month);
      }
      var date6 = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
      if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
        return false;
      }
    }
    return true;
  };
  var slSiCheck = function(tin) {
    var checksum2 = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 7).map(function(a2) {
      return parseInt(a2, 10);
    }), 8) % 11;
    if (checksum2 === 10) {
      return parseInt(tin[7], 10) === 0;
    }
    return checksum2 === parseInt(tin[7], 10);
  };
  var svSeCheck = function(tin) {
    var tin_copy = tin.slice(0);
    if (tin.length > 11) {
      tin_copy = tin_copy.slice(2);
    }
    var full_year = "";
    var month = tin_copy.slice(2, 4);
    var day = parseInt(tin_copy.slice(4, 6), 10);
    if (tin.length > 11) {
      full_year = tin.slice(0, 4);
    } else {
      full_year = tin.slice(0, 2);
      if (tin.length === 11 && day < 60) {
        var current_year = new Date().getFullYear().toString();
        var current_century = parseInt(current_year.slice(0, 2), 10);
        current_year = parseInt(current_year, 10);
        if (tin[6] === "-") {
          if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
            full_year = "".concat(current_century - 1).concat(full_year);
          } else {
            full_year = "".concat(current_century).concat(full_year);
          }
        } else {
          full_year = "".concat(current_century - 1).concat(full_year);
          if (current_year - parseInt(full_year, 10) < 100) {
            return false;
          }
        }
      }
    }
    if (day > 60) {
      day -= 60;
    }
    if (day < 10) {
      day = "0".concat(day);
    }
    var date6 = "".concat(full_year, "/").concat(month, "/").concat(day);
    if (date6.length === 8) {
      if (!(0, _isDate.default)(date6, "YY/MM/DD")) {
        return false;
      }
    } else if (!(0, _isDate.default)(date6, "YYYY/MM/DD")) {
      return false;
    }
    return algorithms.luhnCheck(tin.replace(/\W/, ""));
  };
  var isTaxID = function(str) {
    var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "en-US";
    (0, _assertString.default)(str);
    var strcopy = str.slice(0);
    if (locale in taxIdFormat) {
      if (locale in sanitizeRegexes) {
        strcopy = strcopy.replace(sanitizeRegexes[locale], "");
      }
      if (!taxIdFormat[locale].test(strcopy)) {
        return false;
      }
      if (locale in taxIdCheck) {
        return taxIdCheck[locale](strcopy);
      }
      return true;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTaxID;
  var _assertString = _interopRequireDefault(require_assertString());
  var algorithms = _interopRequireWildcard(require_algorithms());
  var _isDate = _interopRequireDefault(require_isDate());
  var enUsCampusPrefix = {
    andover: ["10", "12"],
    atlanta: ["60", "67"],
    austin: ["50", "53"],
    brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
    cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
    fresno: ["15", "24"],
    internet: ["20", "26", "27", "45", "46", "47"],
    kansas: ["40", "44"],
    memphis: ["94", "95"],
    ogden: ["80", "90"],
    philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
    sba: ["31"]
  };
  var taxIdFormat = {
    "bg-BG": /^\d{10}$/,
    "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
    "de-AT": /^\d{9}$/,
    "de-DE": /^[1-9]\d{10}$/,
    "dk-DK": /^\d{6}-{0,1}\d{4}$/,
    "el-CY": /^[09]\d{7}[A-Z]$/,
    "el-GR": /^([0-4]|[7-9])\d{8}$/,
    "en-CA": /^\d{9}$/,
    "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
    "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
    "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
    "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
    "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
    "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
    "fr-BE": /^\d{11}$/,
    "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
    "fr-LU": /^\d{13}$/,
    "hr-HR": /^\d{11}$/,
    "hu-HU": /^8\d{9}$/,
    "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
    "lv-LV": /^\d{6}-{0,1}\d{5}$/,
    "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
    "nl-NL": /^\d{9}$/,
    "pl-PL": /^\d{10,11}$/,
    "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
    "pt-PT": /^\d{9}$/,
    "ro-RO": /^\d{13}$/,
    "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
    "sl-SI": /^[1-9]\d{7}$/,
    "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/
  };
  taxIdFormat["lb-LU"] = taxIdFormat["fr-LU"];
  taxIdFormat["lt-LT"] = taxIdFormat["et-EE"];
  taxIdFormat["nl-BE"] = taxIdFormat["fr-BE"];
  taxIdFormat["fr-CA"] = taxIdFormat["en-CA"];
  var taxIdCheck = {
    "bg-BG": bgBgCheck,
    "cs-CZ": csCzCheck,
    "de-AT": deAtCheck,
    "de-DE": deDeCheck,
    "dk-DK": dkDkCheck,
    "el-CY": elCyCheck,
    "el-GR": elGrCheck,
    "en-CA": isCanadianSIN,
    "en-IE": enIeCheck,
    "en-US": enUsCheck,
    "es-ES": esEsCheck,
    "et-EE": etEeCheck,
    "fi-FI": fiFiCheck,
    "fr-BE": frBeCheck,
    "fr-FR": frFrCheck,
    "fr-LU": frLuCheck,
    "hr-HR": hrHrCheck,
    "hu-HU": huHuCheck,
    "it-IT": itItCheck,
    "lv-LV": lvLvCheck,
    "mt-MT": mtMtCheck,
    "nl-NL": nlNlCheck,
    "pl-PL": plPlCheck,
    "pt-BR": ptBrCheck,
    "pt-PT": ptPtCheck,
    "ro-RO": roRoCheck,
    "sk-SK": skSkCheck,
    "sl-SI": slSiCheck,
    "sv-SE": svSeCheck
  };
  taxIdCheck["lb-LU"] = taxIdCheck["fr-LU"];
  taxIdCheck["lt-LT"] = taxIdCheck["et-EE"];
  taxIdCheck["nl-BE"] = taxIdCheck["fr-BE"];
  taxIdCheck["fr-CA"] = taxIdCheck["en-CA"];
  var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
  var sanitizeRegexes = {
    "de-AT": allsymbols,
    "de-DE": /[\/\\]/g,
    "fr-BE": allsymbols
  };
  sanitizeRegexes["nl-BE"] = sanitizeRegexes["fr-BE"];
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMobilePhone.js
var require_isMobilePhone = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isMobilePhone = function(str, locale, options) {
    (0, _assertString.default)(str);
    if (options && options.strictMode && !str.startsWith("+")) {
      return false;
    }
    if (Array.isArray(locale)) {
      return locale.some(function(key2) {
        if (phones.hasOwnProperty(key2)) {
          var phone2 = phones[key2];
          if (phone2.test(str)) {
            return true;
          }
        }
        return false;
      });
    } else if (locale in phones) {
      return phones[locale].test(str);
    } else if (!locale || locale === "any") {
      for (var key in phones) {
        if (phones.hasOwnProperty(key)) {
          var phone = phones[key];
          if (phone.test(str)) {
            return true;
          }
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMobilePhone;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var phones = {
    "am-AM": /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/,
    "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
    "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
    "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
    "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
    "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
    "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
    "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
    "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
    "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
    "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
    "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
    "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
    "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
    "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
    "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
    "ar-TN": /^(\+?216)?[2459]\d{7}$/,
    "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
    "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
    "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
    "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
    "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
    "ca-AD": /^(\+376)?[346]\d{5}$/,
    "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
    "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
    "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
    "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
    "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
    "de-LU": /^(\+352)?((6\d1)\d{6})$/,
    "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
    "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
    "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
    "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
    "en-AU": /^(\+?61|0)4\d{8}$/,
    "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
    "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
    "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
    "en-GB": /^(\+?44|0)7\d{9}$/,
    "en-GG": /^(\+?44|0)1481\d{6}$/,
    "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
    "en-GY": /^(\+592|0)6\d{6}$/,
    "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
    "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
    "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
    "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
    "en-JM": /^(\+?876)?\d{7}$/,
    "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
    "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
    "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
    "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
    "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
    "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
    "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
    "en-MU": /^(\+?230|0)?\d{8}$/,
    "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
    "en-NG": /^(\+?234|0)?[789]\d{9}$/,
    "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
    "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
    "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
    "en-PH": /^(09|\+639)\d{9}$/,
    "en-RW": /^(\+?250|0)?[7]\d{8}$/,
    "en-SG": /^(\+65)?[3689]\d{7}$/,
    "en-SL": /^(\+?232|0)\d{8}$/,
    "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
    "en-UG": /^(\+?256|0)?[7]\d{8}$/,
    "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
    "en-ZA": /^(\+?27|0)\d{9}$/,
    "en-ZM": /^(\+?26)?09[567]\d{7}$/,
    "en-ZW": /^(\+263)[0-9]{9}$/,
    "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
    "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
    "es-BO": /^(\+?591)?(6|7)\d{7}$/,
    "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
    "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
    "es-CR": /^(\+506)?[2-8]\d{7}$/,
    "es-CU": /^(\+53|0053)?5\d{7}$/,
    "es-DO": /^(\+?1)?8[024]9\d{7}$/,
    "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
    "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
    "es-ES": /^(\+?34)?[6|7]\d{8}$/,
    "es-PE": /^(\+?51)?9\d{8}$/,
    "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
    "es-NI": /^(\+?505)\d{7,8}$/,
    "es-PA": /^(\+?507)\d{7,8}$/,
    "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
    "es-SV": /^(\+?503)?[67]\d{7}$/,
    "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
    "es-VE": /^(\+?58)?(2|4)\d{9}$/,
    "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
    "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
    "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
    "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
    "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
    "fr-BF": /^(\+226|0)[67]\d{7}$/,
    "fr-BJ": /^(\+229)\d{8}$/,
    "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
    "fr-CM": /^(\+?237)6[0-9]{8}$/,
    "fr-FR": /^(\+?33|0)[67]\d{8}$/,
    "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
    "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
    "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
    "fr-PF": /^(\+?689)?8[789]\d{6}$/,
    "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
    "fr-WF": /^(\+681)?\d{6}$/,
    "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
    "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
    "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
    "ir-IR": /^(\+98|0)?9\d{9}$/,
    "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
    "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
    "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
    "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
    "kk-KZ": /^(\+?7|8)?7\d{9}$/,
    "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
    "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
    "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
    "lt-LT": /^(\+370|8)\d{8}$/,
    "lv-LV": /^(\+?371)2\d{7}$/,
    "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
    "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
    "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
    "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
    "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
    "nb-NO": /^(\+?47)?[49]\d{7}$/,
    "ne-NP": /^(\+?977)?9[78]\d{8}$/,
    "nl-BE": /^(\+?32|0)4\d{8}$/,
    "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
    "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
    "nn-NO": /^(\+?47)?[49]\d{7}$/,
    "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
    "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
    "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
    "pt-AO": /^(\+244)\d{9}$/,
    "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
    "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
    "ru-RU": /^(\+?7|8)?9\d{9}$/,
    "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
    "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
    "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
    "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
    "sq-AL": /^(\+355|0)6[789]\d{6}$/,
    "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
    "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
    "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
    "th-TH": /^(\+66|66|0)\d{9}$/,
    "tr-TR": /^(\+?90|0)?5\d{9}$/,
    "tk-TM": /^(\+993|993|8)\d{8}$/,
    "uk-UA": /^(\+?38|8)?0\d{9}$/,
    "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
    "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
    "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
    "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
    "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
    "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
    "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
    "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
  };
  phones["en-CA"] = phones["en-US"];
  phones["fr-CA"] = phones["en-CA"];
  phones["fr-BE"] = phones["nl-BE"];
  phones["zh-HK"] = phones["en-HK"];
  phones["zh-MO"] = phones["en-MO"];
  phones["ga-IE"] = phones["en-IE"];
  phones["fr-CH"] = phones["de-CH"];
  phones["it-CH"] = phones["fr-CH"];
  var locales = Object.keys(phones);
  exports.locales = locales;
});

// node_modules/validator/lib/isEthereumAddress.js
var require_isEthereumAddress = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isEthereumAddress = function(str) {
    (0, _assertString.default)(str);
    return eth.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEthereumAddress;
  var _assertString = _interopRequireDefault(require_assertString());
  var eth = /^(0x)[0-9a-f]{40}$/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isCurrency.js
var require_isCurrency = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var currencyRegex = function(options) {
    var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
    options.digits_after_decimal.forEach(function(digit, index) {
      if (index !== 0)
        decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
    });
    var symbol5 = "(".concat(options.symbol.replace(/\W/, function(m) {
      return "\\".concat(m);
    }), ")").concat(options.require_symbol ? "" : "?"), negative = "-?", whole_dollar_amount_without_sep = "[1-9]\\d*", whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"), valid_whole_dollar_amounts = ["0", whole_dollar_amount_without_sep, whole_dollar_amount_with_sep], whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join("|"), ")?"), decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? "" : "?");
    var pattern3 = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : "");
    if (options.allow_negatives && !options.parens_for_negatives) {
      if (options.negative_sign_after_digits) {
        pattern3 += negative;
      } else if (options.negative_sign_before_digits) {
        pattern3 = negative + pattern3;
      }
    }
    if (options.allow_negative_sign_placeholder) {
      pattern3 = "( (?!\\-))?".concat(pattern3);
    } else if (options.allow_space_after_symbol) {
      pattern3 = " ?".concat(pattern3);
    } else if (options.allow_space_after_digits) {
      pattern3 += "( (?!$))?";
    }
    if (options.symbol_after_digits) {
      pattern3 += symbol5;
    } else {
      pattern3 = symbol5 + pattern3;
    }
    if (options.allow_negatives) {
      if (options.parens_for_negatives) {
        pattern3 = "(\\(".concat(pattern3, "\\)|").concat(pattern3, ")");
      } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
        pattern3 = negative + pattern3;
      }
    }
    return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern3, "$"));
  };
  var isCurrency = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_currency_options);
    return currencyRegex(options).test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isCurrency;
  var _merge = _interopRequireDefault(require_merge());
  var _assertString = _interopRequireDefault(require_assertString());
  var default_currency_options = {
    symbol: "$",
    require_symbol: false,
    allow_space_after_symbol: false,
    symbol_after_digits: false,
    allow_negatives: true,
    parens_for_negatives: false,
    negative_sign_before_digits: false,
    negative_sign_after_digits: false,
    allow_negative_sign_placeholder: false,
    thousands_separator: ",",
    decimal_separator: ".",
    allow_decimal: true,
    require_decimal: false,
    digits_after_decimal: [2],
    allow_space_after_digits: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isBtcAddress.js
var require_isBtcAddress = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isBtcAddress = function(str) {
    (0, _assertString.default)(str);
    return bech32.test(str) || base58.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBtcAddress;
  var _assertString = _interopRequireDefault(require_assertString());
  var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
  var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISO6346.js
var require_isISO6346 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISO6346 = function(str) {
    (0, _assertString.default)(str);
    str = str.toUpperCase();
    if (!isISO6346Str.test(str))
      return false;
    if (str.length === 11) {
      var sum = 0;
      for (var i = 0;i < str.length - 1; i++) {
        if (!isDigit.test(str[i])) {
          var convertedCode = undefined;
          var letterCode = str.charCodeAt(i) - 55;
          if (letterCode < 11)
            convertedCode = letterCode;
          else if (letterCode >= 11 && letterCode <= 20)
            convertedCode = 12 + letterCode % 11;
          else if (letterCode >= 21 && letterCode <= 30)
            convertedCode = 23 + letterCode % 21;
          else
            convertedCode = 34 + letterCode % 31;
          sum += convertedCode * Math.pow(2, i);
        } else
          sum += str[i] * Math.pow(2, i);
      }
      var checkSumDigit = sum % 11;
      return Number(str[str.length - 1]) === checkSumDigit;
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isISO6346 = isISO6346;
  exports.isFreightContainerID = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
  var isDigit = /^[0-9]$/;
  var isFreightContainerID = isISO6346;
  exports.isFreightContainerID = isFreightContainerID;
});

// node_modules/validator/lib/isISO6391.js
var require_isISO6391 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISO6391 = function(str) {
    (0, _assertString.default)(str);
    return isISO6391Set.has(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO6391;
  var _assertString = _interopRequireDefault(require_assertString());
  var isISO6391Set = new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISO8601.js
var require_isISO8601 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISO86012 = function(str) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _assertString.default)(str);
    var check11 = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
    if (check11 && options.strict)
      return isValidDate(str);
    return check11;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO86012;
  var _assertString = _interopRequireDefault(require_assertString());
  var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
  var isValidDate = function isValidDate(str) {
    var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
    if (ordinalMatch) {
      var oYear = Number(ordinalMatch[1]);
      var oDay = Number(ordinalMatch[2]);
      if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0)
        return oDay <= 366;
      return oDay <= 365;
    }
    var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
    var year = match[1];
    var month = match[2];
    var day = match[3];
    var monthString = month ? "0".concat(month).slice(-2) : month;
    var dayString = day ? "0".concat(day).slice(-2) : day;
    var d = new Date("".concat(year, "-").concat(monthString || "01", "-").concat(dayString || "01"));
    if (month && day) {
      return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
    }
    return true;
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isRFC3339.js
var require_isRFC3339 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isRFC3339 = function(str) {
    (0, _assertString.default)(str);
    return rfc3339.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isRFC3339;
  var _assertString = _interopRequireDefault(require_assertString());
  var dateFullYear = /[0-9]{4}/;
  var dateMonth = /(0[1-9]|1[0-2])/;
  var dateMDay = /([12]\d|0[1-9]|3[01])/;
  var timeHour = /([01][0-9]|2[0-3])/;
  var timeMinute = /[0-5][0-9]/;
  var timeSecond = /([0-5][0-9]|60)/;
  var timeSecFrac = /(\.[0-9]+)?/;
  var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
  var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
  var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
  var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
  var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
  var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISO31661Alpha3.js
var require_isISO31661Alpha3 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISO31661Alpha3 = function(str) {
    (0, _assertString.default)(str);
    return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO31661Alpha3;
  var _assertString = _interopRequireDefault(require_assertString());
  var validISO31661Alpha3CountriesCodes = new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isISO4217.js
var require_isISO4217 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isISO4217 = function(str) {
    (0, _assertString.default)(str);
    return validISO4217CurrencyCodes.has(str.toUpperCase());
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isISO4217;
  exports.CurrencyCodes = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var validISO4217CurrencyCodes = new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]);
  var CurrencyCodes = validISO4217CurrencyCodes;
  exports.CurrencyCodes = CurrencyCodes;
});

// node_modules/validator/lib/isBase32.js
var require_isBase32 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isBase32 = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, defaultBase32Options);
    if (options.crockford) {
      return crockfordBase32.test(str);
    }
    var len = str.length;
    if (len % 8 === 0 && base32.test(str)) {
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase32;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var base32 = /^[A-Z2-7]+=*$/;
  var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
  var defaultBase32Options = {
    crockford: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isBase58.js
var require_isBase58 = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isBase58 = function(str) {
    (0, _assertString.default)(str);
    if (base58Reg.test(str)) {
      return true;
    }
    return false;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBase58;
  var _assertString = _interopRequireDefault(require_assertString());
  var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isDataURI.js
var require_isDataURI = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isDataURI = function(str) {
    (0, _assertString.default)(str);
    var data = str.split(",");
    if (data.length < 2) {
      return false;
    }
    var attributes = data.shift().trim().split(";");
    var schemeAndMediaType = attributes.shift();
    if (schemeAndMediaType.slice(0, 5) !== "data:") {
      return false;
    }
    var mediaType = schemeAndMediaType.slice(5);
    if (mediaType !== "" && !validMediaType.test(mediaType)) {
      return false;
    }
    for (var i = 0;i < attributes.length; i++) {
      if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === "base64") && !validAttribute.test(attributes[i])) {
        return false;
      }
    }
    for (var _i = 0;_i < data.length; _i++) {
      if (!validData.test(data[_i])) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDataURI;
  var _assertString = _interopRequireDefault(require_assertString());
  var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
  var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
  var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMagnetURI.js
var require_isMagnetURI = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isMagnetURI = function(url) {
    (0, _assertString.default)(url);
    if (url.indexOf("magnet:?") !== 0) {
      return false;
    }
    return magnetURIComponent.test(url);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMagnetURI;
  var _assertString = _interopRequireDefault(require_assertString());
  var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/rtrim.js
var require_rtrim = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rtrim = function(str, chars) {
    (0, _assertString.default)(str);
    if (chars) {
      var pattern3 = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
      return str.replace(pattern3, "");
    }
    var strIndex = str.length - 1;
    while (/\s/.test(str.charAt(strIndex))) {
      strIndex -= 1;
    }
    return str.slice(0, strIndex + 1);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rtrim;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/ltrim.js
var require_ltrim = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var ltrim = function(str, chars) {
    (0, _assertString.default)(str);
    var pattern3 = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
    return str.replace(pattern3, "");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = ltrim;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/trim.js
var require_trim = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var trim = function(str, chars) {
    return (0, _rtrim.default)((0, _ltrim.default)(str, chars), chars);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = trim;
  var _rtrim = _interopRequireDefault(require_rtrim());
  var _ltrim = _interopRequireDefault(require_ltrim());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMailtoURI.js
var require_isMailtoURI = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var _slicedToArray = function(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  };
  var _nonIterableRest = function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  };
  var _iterableToArrayLimit = function(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  };
  var _arrayWithHoles = function(arr) {
    if (Array.isArray(arr))
      return arr;
  };
  var _createForOfIteratorHelper = function(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e2) {
          throw _e2;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    }, e: function e(_e3) {
      didErr = true;
      err = _e3;
    }, f: function f() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  };
  var _unsupportedIterableToArray = function(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  };
  var _arrayLikeToArray = function(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len);i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  };
  var parseMailtoQueryString = function(queryString) {
    var allowedParams = new Set(["subject", "body", "cc", "bcc"]), query = {
      cc: "",
      bcc: ""
    };
    var isParseFailed = false;
    var queryParams = queryString.split("&");
    if (queryParams.length > 4) {
      return false;
    }
    var _iterator = _createForOfIteratorHelper(queryParams), _step;
    try {
      for (_iterator.s();!(_step = _iterator.n()).done; ) {
        var q = _step.value;
        var _q$split = q.split("="), _q$split2 = _slicedToArray(_q$split, 2), key = _q$split2[0], value15 = _q$split2[1];
        if (key && !allowedParams.has(key)) {
          isParseFailed = true;
          break;
        }
        if (value15 && (key === "cc" || key === "bcc")) {
          query[key] = value15;
        }
        if (key) {
          allowedParams.delete(key);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return isParseFailed ? false : query;
  };
  var isMailtoURI = function(url, options) {
    (0, _assertString.default)(url);
    if (url.indexOf("mailto:") !== 0) {
      return false;
    }
    var _url$replace$split = url.replace("mailto:", "").split("?"), _url$replace$split2 = _slicedToArray(_url$replace$split, 2), _url$replace$split2$ = _url$replace$split2[0], to = _url$replace$split2$ === undefined ? "" : _url$replace$split2$, _url$replace$split2$2 = _url$replace$split2[1], queryString = _url$replace$split2$2 === undefined ? "" : _url$replace$split2$2;
    if (!to && !queryString) {
      return true;
    }
    var query = parseMailtoQueryString(queryString);
    if (!query) {
      return false;
    }
    return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(",").every(function(email) {
      email = (0, _trim.default)(email, " ");
      if (email) {
        return (0, _isEmail.default)(email, options);
      }
      return true;
    });
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMailtoURI;
  var _trim = _interopRequireDefault(require_trim());
  var _isEmail = _interopRequireDefault(require_isEmail());
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isMimeType.js
var require_isMimeType = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isMimeType = function(str) {
    (0, _assertString.default)(str);
    return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMimeType;
  var _assertString = _interopRequireDefault(require_assertString());
  var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i;
  var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i;
  var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isLatLong.js
var require_isLatLong = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isLatLong = function(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, defaultLatLongOptions);
    if (!str.includes(","))
      return false;
    var pair = str.split(",");
    if (pair[0].startsWith("(") && !pair[1].endsWith(")") || pair[1].endsWith(")") && !pair[0].startsWith("("))
      return false;
    if (options.checkDMS) {
      return latDMS.test(pair[0]) && longDMS.test(pair[1]);
    }
    return lat.test(pair[0]) && long.test(pair[1]);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLatLong;
  var _assertString = _interopRequireDefault(require_assertString());
  var _merge = _interopRequireDefault(require_merge());
  var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
  var long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
  var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
  var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
  var defaultLatLongOptions = {
    checkDMS: false
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isPostalCode.js
var require_isPostalCode = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isPostalCode = function(str, locale) {
    (0, _assertString.default)(str);
    if (locale in patterns7) {
      return patterns7[locale].test(str);
    } else if (locale === "any") {
      for (var key in patterns7) {
        if (patterns7.hasOwnProperty(key)) {
          var pattern3 = patterns7[key];
          if (pattern3.test(str)) {
            return true;
          }
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPostalCode;
  exports.locales = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var threeDigit = /^\d{3}$/;
  var fourDigit = /^\d{4}$/;
  var fiveDigit = /^\d{5}$/;
  var sixDigit = /^\d{6}$/;
  var patterns7 = {
    AD: /^AD\d{3}$/,
    AT: fourDigit,
    AU: fourDigit,
    AZ: /^AZ\d{4}$/,
    BA: /^([7-8]\d{4}$)/,
    BE: fourDigit,
    BG: fourDigit,
    BR: /^\d{5}-\d{3}$/,
    BY: /^2[1-4]\d{4}$/,
    CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
    CH: fourDigit,
    CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
    CZ: /^\d{3}\s?\d{2}$/,
    DE: fiveDigit,
    DK: fourDigit,
    DO: fiveDigit,
    DZ: fiveDigit,
    EE: fiveDigit,
    ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
    FI: fiveDigit,
    FR: /^\d{2}\s?\d{3}$/,
    GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
    GR: /^\d{3}\s?\d{2}$/,
    HR: /^([1-5]\d{4}$)/,
    HT: /^HT\d{4}$/,
    HU: fourDigit,
    ID: fiveDigit,
    IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
    IL: /^(\d{5}|\d{7})$/,
    IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
    IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
    IS: threeDigit,
    IT: fiveDigit,
    JP: /^\d{3}\-\d{4}$/,
    KE: fiveDigit,
    KR: /^(\d{5}|\d{6})$/,
    LI: /^(948[5-9]|949[0-7])$/,
    LT: /^LT\-\d{5}$/,
    LU: fourDigit,
    LV: /^LV\-\d{4}$/,
    LK: fiveDigit,
    MG: threeDigit,
    MX: fiveDigit,
    MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
    MY: fiveDigit,
    NL: /^\d{4}\s?[a-z]{2}$/i,
    NO: fourDigit,
    NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
    NZ: fourDigit,
    PL: /^\d{2}\-\d{3}$/,
    PR: /^00[679]\d{2}([ -]\d{4})?$/,
    PT: /^\d{4}\-\d{3}?$/,
    RO: sixDigit,
    RU: sixDigit,
    SA: fiveDigit,
    SE: /^[1-9]\d{2}\s?\d{2}$/,
    SG: sixDigit,
    SI: fourDigit,
    SK: /^\d{3}\s?\d{2}$/,
    TH: fiveDigit,
    TN: fourDigit,
    TW: /^\d{3}(\d{2})?$/,
    UA: fiveDigit,
    US: /^\d{5}(-\d{4})?$/,
    ZA: fourDigit,
    ZM: fiveDigit
  };
  var locales = Object.keys(patterns7);
  exports.locales = locales;
});

// node_modules/validator/lib/escape.js
var require_escape = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var escape = function(str) {
    (0, _assertString.default)(str);
    return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = escape;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/unescape.js
var require_unescape = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var unescape = function(str) {
    (0, _assertString.default)(str);
    return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = unescape;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/blacklist.js
var require_blacklist = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var blacklist = function(str, chars) {
    (0, _assertString.default)(str);
    return str.replace(new RegExp("[".concat(chars, "]+"), "g"), "");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = blacklist;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/stripLow.js
var require_stripLow = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stripLow = function(str, keep_new_lines) {
    (0, _assertString.default)(str);
    var chars = keep_new_lines ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
    return (0, _blacklist.default)(str, chars);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = stripLow;
  var _assertString = _interopRequireDefault(require_assertString());
  var _blacklist = _interopRequireDefault(require_blacklist());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/whitelist.js
var require_whitelist = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var whitelist = function(str, chars) {
    (0, _assertString.default)(str);
    return str.replace(new RegExp("[^".concat(chars, "]+"), "g"), "");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = whitelist;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isWhitelisted.js
var require_isWhitelisted = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isWhitelisted = function(str, chars) {
    (0, _assertString.default)(str);
    for (var i = str.length - 1;i >= 0; i--) {
      if (chars.indexOf(str[i]) === -1) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isWhitelisted;
  var _assertString = _interopRequireDefault(require_assertString());
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/normalizeEmail.js
var require_normalizeEmail = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var dotsReplacer = function(match) {
    if (match.length > 1) {
      return match;
    }
    return "";
  };
  var normalizeEmail = function(email, options) {
    options = (0, _merge.default)(options, default_normalize_email_options);
    var raw_parts = email.split("@");
    var domain = raw_parts.pop();
    var user = raw_parts.join("@");
    var parts = [user, domain];
    parts[1] = parts[1].toLowerCase();
    if (parts[1] === "gmail.com" || parts[1] === "googlemail.com") {
      if (options.gmail_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (options.gmail_remove_dots) {
        parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.gmail_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = options.gmail_convert_googlemaildotcom ? "gmail.com" : parts[1];
    } else if (icloud_domains.indexOf(parts[1]) >= 0) {
      if (options.icloud_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.icloud_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
      if (options.outlookdotcom_remove_subaddress) {
        parts[0] = parts[0].split("+")[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.outlookdotcom_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
      if (options.yahoo_remove_subaddress) {
        var components = parts[0].split("-");
        parts[0] = components.length > 1 ? components.slice(0, -1).join("-") : components[0];
      }
      if (!parts[0].length) {
        return false;
      }
      if (options.all_lowercase || options.yahoo_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
    } else if (yandex_domains.indexOf(parts[1]) >= 0) {
      if (options.all_lowercase || options.yandex_lowercase) {
        parts[0] = parts[0].toLowerCase();
      }
      parts[1] = "yandex.ru";
    } else if (options.all_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
    return parts.join("@");
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = normalizeEmail;
  var _merge = _interopRequireDefault(require_merge());
  var default_normalize_email_options = {
    all_lowercase: true,
    gmail_lowercase: true,
    gmail_remove_dots: true,
    gmail_remove_subaddress: true,
    gmail_convert_googlemaildotcom: true,
    outlookdotcom_lowercase: true,
    outlookdotcom_remove_subaddress: true,
    yahoo_lowercase: true,
    yahoo_remove_subaddress: true,
    yandex_lowercase: true,
    icloud_lowercase: true,
    icloud_remove_subaddress: true
  };
  var icloud_domains = ["icloud.com", "me.com"];
  var outlookdotcom_domains = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"];
  var yahoo_domains = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"];
  var yandex_domains = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isSlug.js
var require_isSlug = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isSlug = function(str) {
    (0, _assertString.default)(str);
    return charsetRegex.test(str);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSlug;
  var _assertString = _interopRequireDefault(require_assertString());
  var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isLicensePlate.js
var require_isLicensePlate = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isLicensePlate = function(str, locale) {
    (0, _assertString.default)(str);
    if (locale in validators) {
      return validators[locale](str);
    } else if (locale === "any") {
      for (var key in validators) {
        var validator = validators[key];
        if (validator(str)) {
          return true;
        }
      }
      return false;
    }
    throw new Error("Invalid locale '".concat(locale, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLicensePlate;
  var _assertString = _interopRequireDefault(require_assertString());
  var validators = {
    "cs-CZ": function csCZ(str) {
      return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
    },
    "de-DE": function deDE(str) {
      return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G|GP|GR|GS|GT|G|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T|B|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BD|BUL|BR|BS|BZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL|FOR|FRG|FRI|FRW|FTL|FS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM|HOG|HOH|HOL|HOM|HOR|HS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JL|KEH|KEL|KEM|KIB|KLE|KLZ|KN|KT|KZ|KRU|KN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LB|LOS|LRO|LSZ|LN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MB|MR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL|PR|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RD|RG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL|SLZ|SM|SOB|SOG|SOK|SM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SW|SWA|SZB|TBB|TDO|TET|TIR|TL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
    },
    "de-LI": function deLI(str) {
      return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
    },
    "en-IN": function enIN(str) {
      return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
    },
    "es-AR": function esAR(str) {
      return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
    },
    "fi-FI": function fiFI(str) {
      return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
    },
    "hu-HU": function huHU(str) {
      return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
    },
    "pt-BR": function ptBR(str) {
      return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
    },
    "pt-PT": function ptPT(str) {
      return /^([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})$/.test(str);
    },
    "sq-AL": function sqAL(str) {
      return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
    },
    "sv-SE": function svSE(str) {
      return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z ]{2,7}$)/.test(str.trim());
    }
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isStrongPassword.js
var require_isStrongPassword = __commonJS((exports, module) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var countChars = function(str) {
    var result = {};
    Array.from(str).forEach(function(char) {
      var curVal = result[char];
      if (curVal) {
        result[char] += 1;
      } else {
        result[char] = 1;
      }
    });
    return result;
  };
  var analyzePassword = function(password) {
    var charMap = countChars(password);
    var analysis = {
      length: password.length,
      uniqueChars: Object.keys(charMap).length,
      uppercaseCount: 0,
      lowercaseCount: 0,
      numberCount: 0,
      symbolCount: 0
    };
    Object.keys(charMap).forEach(function(char) {
      if (upperCaseRegex.test(char)) {
        analysis.uppercaseCount += charMap[char];
      } else if (lowerCaseRegex.test(char)) {
        analysis.lowercaseCount += charMap[char];
      } else if (numberRegex.test(char)) {
        analysis.numberCount += charMap[char];
      } else if (symbolRegex.test(char)) {
        analysis.symbolCount += charMap[char];
      }
    });
    return analysis;
  };
  var scorePassword = function(analysis, scoringOptions) {
    var points = 0;
    points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
    points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
    if (analysis.lowercaseCount > 0) {
      points += scoringOptions.pointsForContainingLower;
    }
    if (analysis.uppercaseCount > 0) {
      points += scoringOptions.pointsForContainingUpper;
    }
    if (analysis.numberCount > 0) {
      points += scoringOptions.pointsForContainingNumber;
    }
    if (analysis.symbolCount > 0) {
      points += scoringOptions.pointsForContainingSymbol;
    }
    return points;
  };
  var isStrongPassword = function(str) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    (0, _assertString.default)(str);
    var analysis = analyzePassword(str);
    options = (0, _merge.default)(options || {}, defaultOptions);
    if (options.returnScore) {
      return scorePassword(analysis, options);
    }
    return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isStrongPassword;
  var _merge = _interopRequireDefault(require_merge());
  var _assertString = _interopRequireDefault(require_assertString());
  var upperCaseRegex = /^[A-Z]$/;
  var lowerCaseRegex = /^[a-z]$/;
  var numberRegex = /^[0-9]$/;
  var symbolRegex = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/ ]$/;
  var defaultOptions = {
    minLength: 8,
    minLowercase: 1,
    minUppercase: 1,
    minNumbers: 1,
    minSymbols: 1,
    returnScore: false,
    pointsPerUnique: 1,
    pointsPerRepeat: 0.5,
    pointsForContainingLower: 10,
    pointsForContainingUpper: 10,
    pointsForContainingNumber: 10,
    pointsForContainingSymbol: 10
  };
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/validator/lib/isVAT.js
var require_isVAT = __commonJS((exports) => {
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var _getRequireWildcardCache = function() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap;
    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };
    return cache;
  };
  var _interopRequireWildcard = function(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  };
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var isVAT = function(str, countryCode) {
    (0, _assertString.default)(str);
    (0, _assertString.default)(countryCode);
    if (countryCode in vatMatchers) {
      return vatMatchers[countryCode](str);
    }
    throw new Error("Invalid country code: '".concat(countryCode, "'"));
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isVAT;
  exports.vatMatchers = undefined;
  var _assertString = _interopRequireDefault(require_assertString());
  var algorithms = _interopRequireWildcard(require_algorithms());
  var CH = function CH(str) {
    var hasValidCheckNumber = function hasValidCheckNumber(digits) {
      var lastDigit = digits.pop();
      var weights = [5, 4, 3, 2, 7, 6, 5, 4];
      var calculatedCheckNumber = (11 - digits.reduce(function(acc, el, idx) {
        return acc + el * weights[idx];
      }, 0) % 11) % 11;
      return lastDigit === calculatedCheckNumber;
    };
    return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function(el) {
      return +el;
    }));
  };
  var PT = function PT(str) {
    var match = str.match(/^(PT)?(\d{9})$/);
    if (!match) {
      return false;
    }
    var tin = match[2];
    var checksum2 = 11 - algorithms.reverseMultiplyAndSum(tin.split("").slice(0, 8).map(function(a2) {
      return parseInt(a2, 10);
    }), 9) % 11;
    if (checksum2 > 9) {
      return parseInt(tin[8], 10) === 0;
    }
    return checksum2 === parseInt(tin[8], 10);
  };
  var vatMatchers = {
    AT: function AT(str) {
      return /^(AT)?U\d{8}$/.test(str);
    },
    BE: function BE(str) {
      return /^(BE)?\d{10}$/.test(str);
    },
    BG: function BG(str) {
      return /^(BG)?\d{9,10}$/.test(str);
    },
    HR: function HR(str) {
      return /^(HR)?\d{11}$/.test(str);
    },
    CY: function CY(str) {
      return /^(CY)?\w{9}$/.test(str);
    },
    CZ: function CZ(str) {
      return /^(CZ)?\d{8,10}$/.test(str);
    },
    DK: function DK(str) {
      return /^(DK)?\d{8}$/.test(str);
    },
    EE: function EE(str) {
      return /^(EE)?\d{9}$/.test(str);
    },
    FI: function FI(str) {
      return /^(FI)?\d{8}$/.test(str);
    },
    FR: function FR(str) {
      return /^(FR)?\w{2}\d{9}$/.test(str);
    },
    DE: function DE(str) {
      return /^(DE)?\d{9}$/.test(str);
    },
    EL: function EL(str) {
      return /^(EL)?\d{9}$/.test(str);
    },
    HU: function HU(str) {
      return /^(HU)?\d{8}$/.test(str);
    },
    IE: function IE(str) {
      return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
    },
    IT: function IT(str) {
      return /^(IT)?\d{11}$/.test(str);
    },
    LV: function LV(str) {
      return /^(LV)?\d{11}$/.test(str);
    },
    LT: function LT(str) {
      return /^(LT)?\d{9,12}$/.test(str);
    },
    LU: function LU(str) {
      return /^(LU)?\d{8}$/.test(str);
    },
    MT: function MT(str) {
      return /^(MT)?\d{8}$/.test(str);
    },
    NL: function NL(str) {
      return /^(NL)?\d{9}B\d{2}$/.test(str);
    },
    PL: function PL(str) {
      return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
    },
    PT,
    RO: function RO(str) {
      return /^(RO)?\d{2,10}$/.test(str);
    },
    SK: function SK(str) {
      return /^(SK)?\d{10}$/.test(str);
    },
    SI: function SI(str) {
      return /^(SI)?\d{8}$/.test(str);
    },
    ES: function ES(str) {
      return /^(ES)?\w\d{7}[A-Z]$/.test(str);
    },
    SE: function SE(str) {
      return /^(SE)?\d{12}$/.test(str);
    },
    AL: function AL(str) {
      return /^(AL)?\w{9}[A-Z]$/.test(str);
    },
    MK: function MK(str) {
      return /^(MK)?\d{13}$/.test(str);
    },
    AU: function AU(str) {
      return /^(AU)?\d{11}$/.test(str);
    },
    BY: function BY(str) {
      return /^( )?\d{9}$/.test(str);
    },
    CA: function CA(str) {
      return /^(CA)?\d{9}$/.test(str);
    },
    IS: function IS(str) {
      return /^(IS)?\d{5,6}$/.test(str);
    },
    IN: function IN(str) {
      return /^(IN)?\d{15}$/.test(str);
    },
    ID: function ID(str) {
      return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
    },
    IL: function IL(str) {
      return /^(IL)?\d{9}$/.test(str);
    },
    KZ: function KZ(str) {
      return /^(KZ)?\d{9}$/.test(str);
    },
    NZ: function NZ(str) {
      return /^(NZ)?\d{9}$/.test(str);
    },
    NG: function NG(str) {
      return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
    },
    NO: function NO(str) {
      return /^(NO)?\d{9}MVA$/.test(str);
    },
    PH: function PH(str) {
      return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
    },
    RU: function RU(str) {
      return /^(RU)?(\d{10}|\d{12})$/.test(str);
    },
    SM: function SM(str) {
      return /^(SM)?\d{5}$/.test(str);
    },
    SA: function SA(str) {
      return /^(SA)?\d{15}$/.test(str);
    },
    RS: function RS(str) {
      return /^(RS)?\d{9}$/.test(str);
    },
    CH,
    TR: function TR(str) {
      return /^(TR)?\d{10}$/.test(str);
    },
    UA: function UA(str) {
      return /^(UA)?\d{12}$/.test(str);
    },
    GB: function GB(str) {
      return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
    },
    UZ: function UZ(str) {
      return /^(UZ)?\d{9}$/.test(str);
    },
    AR: function AR(str) {
      return /^(AR)?\d{11}$/.test(str);
    },
    BO: function BO(str) {
      return /^(BO)?\d{7}$/.test(str);
    },
    BR: function BR(str) {
      return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
    },
    CL: function CL(str) {
      return /^(CL)?\d{8}-\d{1}$/.test(str);
    },
    CO: function CO(str) {
      return /^(CO)?\d{10}$/.test(str);
    },
    CR: function CR(str) {
      return /^(CR)?\d{9,12}$/.test(str);
    },
    EC: function EC(str) {
      return /^(EC)?\d{13}$/.test(str);
    },
    SV: function SV(str) {
      return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
    },
    GT: function GT(str) {
      return /^(GT)?\d{7}-\d{1}$/.test(str);
    },
    HN: function HN(str) {
      return /^(HN)?$/.test(str);
    },
    MX: function MX(str) {
      return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
    },
    NI: function NI(str) {
      return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
    },
    PA: function PA(str) {
      return /^(PA)?$/.test(str);
    },
    PY: function PY(str) {
      return /^(PY)?\d{6,8}-\d{1}$/.test(str);
    },
    PE: function PE(str) {
      return /^(PE)?\d{11}$/.test(str);
    },
    DO: function DO(str) {
      return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
    },
    UY: function UY(str) {
      return /^(UY)?\d{12}$/.test(str);
    },
    VE: function VE(str) {
      return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
    }
  };
  exports.vatMatchers = vatMatchers;
});

// node_modules/validator/index.js
var require_validator = __commonJS((exports, module) => {
  var _typeof = function(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  };
  var _getRequireWildcardCache = function() {
    if (typeof WeakMap !== "function")
      return null;
    var cache = new WeakMap;
    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };
    return cache;
  };
  var _interopRequireWildcard = function(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
      return { default: obj };
    }
    var cache = _getRequireWildcardCache();
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  };
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _toDate = _interopRequireDefault(require_toDate());
  var _toFloat = _interopRequireDefault(require_toFloat());
  var _toInt = _interopRequireDefault(require_toInt());
  var _toBoolean = _interopRequireDefault(require_toBoolean());
  var _equals = _interopRequireDefault(require_equals());
  var _contains = _interopRequireDefault(require_contains());
  var _matches = _interopRequireDefault(require_matches());
  var _isEmail = _interopRequireDefault(require_isEmail());
  var _isURL = _interopRequireDefault(require_isURL());
  var _isMACAddress = _interopRequireDefault(require_isMACAddress());
  var _isIP = _interopRequireDefault(require_isIP());
  var _isIPRange = _interopRequireDefault(require_isIPRange());
  var _isFQDN = _interopRequireDefault(require_isFQDN());
  var _isDate = _interopRequireDefault(require_isDate());
  var _isTime = _interopRequireDefault(require_isTime());
  var _isBoolean = _interopRequireDefault(require_isBoolean());
  var _isLocale = _interopRequireDefault(require_isLocale());
  var _isAlpha = _interopRequireWildcard(require_isAlpha());
  var _isAlphanumeric = _interopRequireWildcard(require_isAlphanumeric());
  var _isNumeric = _interopRequireDefault(require_isNumeric());
  var _isPassportNumber = _interopRequireDefault(require_isPassportNumber());
  var _isPort = _interopRequireDefault(require_isPort());
  var _isLowercase = _interopRequireDefault(require_isLowercase());
  var _isUppercase = _interopRequireDefault(require_isUppercase());
  var _isIMEI = _interopRequireDefault(require_isIMEI());
  var _isAscii = _interopRequireDefault(require_isAscii());
  var _isFullWidth = _interopRequireDefault(require_isFullWidth());
  var _isHalfWidth = _interopRequireDefault(require_isHalfWidth());
  var _isVariableWidth = _interopRequireDefault(require_isVariableWidth());
  var _isMultibyte = _interopRequireDefault(require_isMultibyte());
  var _isSemVer = _interopRequireDefault(require_isSemVer());
  var _isSurrogatePair = _interopRequireDefault(require_isSurrogatePair());
  var _isInt = _interopRequireDefault(require_isInt());
  var _isFloat = _interopRequireWildcard(require_isFloat());
  var _isDecimal = _interopRequireDefault(require_isDecimal());
  var _isHexadecimal = _interopRequireDefault(require_isHexadecimal());
  var _isOctal = _interopRequireDefault(require_isOctal());
  var _isDivisibleBy = _interopRequireDefault(require_isDivisibleBy());
  var _isHexColor = _interopRequireDefault(require_isHexColor());
  var _isRgbColor = _interopRequireDefault(require_isRgbColor());
  var _isHSL = _interopRequireDefault(require_isHSL());
  var _isISRC = _interopRequireDefault(require_isISRC());
  var _isIBAN = _interopRequireWildcard(require_isIBAN());
  var _isBIC = _interopRequireDefault(require_isBIC());
  var _isMD = _interopRequireDefault(require_isMD5());
  var _isHash = _interopRequireDefault(require_isHash());
  var _isJWT = _interopRequireDefault(require_isJWT());
  var _isJSON = _interopRequireDefault(require_isJSON());
  var _isEmpty = _interopRequireDefault(require_isEmpty());
  var _isLength = _interopRequireDefault(require_isLength());
  var _isByteLength = _interopRequireDefault(require_isByteLength());
  var _isUUID = _interopRequireDefault(require_isUUID());
  var _isMongoId = _interopRequireDefault(require_isMongoId());
  var _isAfter = _interopRequireDefault(require_isAfter());
  var _isBefore = _interopRequireDefault(require_isBefore());
  var _isIn = _interopRequireDefault(require_isIn());
  var _isLuhnNumber = _interopRequireDefault(require_isLuhnNumber());
  var _isCreditCard = _interopRequireDefault(require_isCreditCard());
  var _isIdentityCard = _interopRequireDefault(require_isIdentityCard());
  var _isEAN = _interopRequireDefault(require_isEAN());
  var _isISIN = _interopRequireDefault(require_isISIN());
  var _isISBN = _interopRequireDefault(require_isISBN());
  var _isISSN = _interopRequireDefault(require_isISSN());
  var _isTaxID = _interopRequireDefault(require_isTaxID());
  var _isMobilePhone = _interopRequireWildcard(require_isMobilePhone());
  var _isEthereumAddress = _interopRequireDefault(require_isEthereumAddress());
  var _isCurrency = _interopRequireDefault(require_isCurrency());
  var _isBtcAddress = _interopRequireDefault(require_isBtcAddress());
  var _isISO = require_isISO6346();
  var _isISO2 = _interopRequireDefault(require_isISO6391());
  var _isISO3 = _interopRequireDefault(require_isISO8601());
  var _isRFC = _interopRequireDefault(require_isRFC3339());
  var _isISO31661Alpha = _interopRequireDefault(require_isISO31661Alpha2());
  var _isISO31661Alpha2 = _interopRequireDefault(require_isISO31661Alpha3());
  var _isISO4 = _interopRequireDefault(require_isISO4217());
  var _isBase = _interopRequireDefault(require_isBase32());
  var _isBase2 = _interopRequireDefault(require_isBase58());
  var _isBase3 = _interopRequireDefault(require_isBase64());
  var _isDataURI = _interopRequireDefault(require_isDataURI());
  var _isMagnetURI = _interopRequireDefault(require_isMagnetURI());
  var _isMailtoURI = _interopRequireDefault(require_isMailtoURI());
  var _isMimeType = _interopRequireDefault(require_isMimeType());
  var _isLatLong = _interopRequireDefault(require_isLatLong());
  var _isPostalCode = _interopRequireWildcard(require_isPostalCode());
  var _ltrim = _interopRequireDefault(require_ltrim());
  var _rtrim = _interopRequireDefault(require_rtrim());
  var _trim = _interopRequireDefault(require_trim());
  var _escape = _interopRequireDefault(require_escape());
  var _unescape = _interopRequireDefault(require_unescape());
  var _stripLow = _interopRequireDefault(require_stripLow());
  var _whitelist = _interopRequireDefault(require_whitelist());
  var _blacklist = _interopRequireDefault(require_blacklist());
  var _isWhitelisted = _interopRequireDefault(require_isWhitelisted());
  var _normalizeEmail = _interopRequireDefault(require_normalizeEmail());
  var _isSlug = _interopRequireDefault(require_isSlug());
  var _isLicensePlate = _interopRequireDefault(require_isLicensePlate());
  var _isStrongPassword = _interopRequireDefault(require_isStrongPassword());
  var _isVAT = _interopRequireDefault(require_isVAT());
  var version = "13.11.0";
  var validator = {
    version,
    toDate: _toDate.default,
    toFloat: _toFloat.default,
    toInt: _toInt.default,
    toBoolean: _toBoolean.default,
    equals: _equals.default,
    contains: _contains.default,
    matches: _matches.default,
    isEmail: _isEmail.default,
    isURL: _isURL.default,
    isMACAddress: _isMACAddress.default,
    isIP: _isIP.default,
    isIPRange: _isIPRange.default,
    isFQDN: _isFQDN.default,
    isBoolean: _isBoolean.default,
    isIBAN: _isIBAN.default,
    isBIC: _isBIC.default,
    isAlpha: _isAlpha.default,
    isAlphaLocales: _isAlpha.locales,
    isAlphanumeric: _isAlphanumeric.default,
    isAlphanumericLocales: _isAlphanumeric.locales,
    isNumeric: _isNumeric.default,
    isPassportNumber: _isPassportNumber.default,
    isPort: _isPort.default,
    isLowercase: _isLowercase.default,
    isUppercase: _isUppercase.default,
    isAscii: _isAscii.default,
    isFullWidth: _isFullWidth.default,
    isHalfWidth: _isHalfWidth.default,
    isVariableWidth: _isVariableWidth.default,
    isMultibyte: _isMultibyte.default,
    isSemVer: _isSemVer.default,
    isSurrogatePair: _isSurrogatePair.default,
    isInt: _isInt.default,
    isIMEI: _isIMEI.default,
    isFloat: _isFloat.default,
    isFloatLocales: _isFloat.locales,
    isDecimal: _isDecimal.default,
    isHexadecimal: _isHexadecimal.default,
    isOctal: _isOctal.default,
    isDivisibleBy: _isDivisibleBy.default,
    isHexColor: _isHexColor.default,
    isRgbColor: _isRgbColor.default,
    isHSL: _isHSL.default,
    isISRC: _isISRC.default,
    isMD5: _isMD.default,
    isHash: _isHash.default,
    isJWT: _isJWT.default,
    isJSON: _isJSON.default,
    isEmpty: _isEmpty.default,
    isLength: _isLength.default,
    isLocale: _isLocale.default,
    isByteLength: _isByteLength.default,
    isUUID: _isUUID.default,
    isMongoId: _isMongoId.default,
    isAfter: _isAfter.default,
    isBefore: _isBefore.default,
    isIn: _isIn.default,
    isLuhnNumber: _isLuhnNumber.default,
    isCreditCard: _isCreditCard.default,
    isIdentityCard: _isIdentityCard.default,
    isEAN: _isEAN.default,
    isISIN: _isISIN.default,
    isISBN: _isISBN.default,
    isISSN: _isISSN.default,
    isMobilePhone: _isMobilePhone.default,
    isMobilePhoneLocales: _isMobilePhone.locales,
    isPostalCode: _isPostalCode.default,
    isPostalCodeLocales: _isPostalCode.locales,
    isEthereumAddress: _isEthereumAddress.default,
    isCurrency: _isCurrency.default,
    isBtcAddress: _isBtcAddress.default,
    isISO6346: _isISO.isISO6346,
    isFreightContainerID: _isISO.isFreightContainerID,
    isISO6391: _isISO2.default,
    isISO8601: _isISO3.default,
    isRFC3339: _isRFC.default,
    isISO31661Alpha2: _isISO31661Alpha.default,
    isISO31661Alpha3: _isISO31661Alpha2.default,
    isISO4217: _isISO4.default,
    isBase32: _isBase.default,
    isBase58: _isBase2.default,
    isBase64: _isBase3.default,
    isDataURI: _isDataURI.default,
    isMagnetURI: _isMagnetURI.default,
    isMailtoURI: _isMailtoURI.default,
    isMimeType: _isMimeType.default,
    isLatLong: _isLatLong.default,
    ltrim: _ltrim.default,
    rtrim: _rtrim.default,
    trim: _trim.default,
    escape: _escape.default,
    unescape: _unescape.default,
    stripLow: _stripLow.default,
    whitelist: _whitelist.default,
    blacklist: _blacklist.default,
    isWhitelisted: _isWhitelisted.default,
    normalizeEmail: _normalizeEmail.default,
    toString,
    isSlug: _isSlug.default,
    isStrongPassword: _isStrongPassword.default,
    isTaxID: _isTaxID.default,
    isDate: _isDate.default,
    isTime: _isTime.default,
    isLicensePlate: _isLicensePlate.default,
    isVAT: _isVAT.default,
    ibanLocales: _isIBAN.locales
  };
  var _default = validator;
  exports.default = _default;
  module.exports = exports.default;
  module.exports.default = exports.default;
});

// node_modules/@google/generative-ai/dist/index.js
var require_dist = __commonJS((exports) => {
  var getClientHeaders = function(requestOptions) {
    const clientHeaders = [];
    if (requestOptions === null || requestOptions === undefined ? undefined : requestOptions.apiClient) {
      clientHeaders.push(requestOptions.apiClient);
    }
    clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
    return clientHeaders.join(" ");
  };
  async function getHeaders(url) {
    const headers = new Headers;
    headers.append("Content-Type", "application/json");
    headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
    headers.append("x-goog-api-key", url.apiKey);
    return headers;
  }
  async function constructRequest(model, task, apiKey, stream, body, requestOptions) {
    const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
    return {
      url: url.toString(),
      fetchOptions: Object.assign(Object.assign({}, buildFetchOptions(requestOptions)), { method: "POST", headers: await getHeaders(url), body })
    };
  }
  async function makeRequest(model, task, apiKey, stream, body, requestOptions) {
    return _makeRequestInternal(model, task, apiKey, stream, body, requestOptions, fetch);
  }
  async function _makeRequestInternal(model, task, apiKey, stream, body, requestOptions, fetchFn = fetch) {
    const url = new RequestUrl(model, task, apiKey, stream, requestOptions);
    let response;
    try {
      const request = await constructRequest(model, task, apiKey, stream, body, requestOptions);
      response = await fetchFn(request.url, request.fetchOptions);
      if (!response.ok) {
        let message = "";
        try {
          const json2 = await response.json();
          message = json2.error.message;
          if (json2.error.details) {
            message += ` ${JSON.stringify(json2.error.details)}`;
          }
        } catch (e2) {
        }
        throw new Error(`[${response.status} ${response.statusText}] ${message}`);
      }
    } catch (e2) {
      const err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e2.message}`);
      err.stack = e2.stack;
      throw err;
    }
    return response;
  }
  var buildFetchOptions = function(requestOptions) {
    const fetchOptions = {};
    if ((requestOptions === null || requestOptions === undefined ? undefined : requestOptions.timeout) >= 0) {
      const abortController = new AbortController;
      const signal = abortController.signal;
      setTimeout(() => abortController.abort(), requestOptions.timeout);
      fetchOptions.signal = signal;
    }
    return fetchOptions;
  };
  var addHelpers = function(response) {
    response.text = () => {
      if (response.candidates && response.candidates.length > 0) {
        if (response.candidates.length > 1) {
          console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`);
        }
        if (hadBadFinishReason(response.candidates[0])) {
          throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
        }
        return getText(response);
      } else if (response.promptFeedback) {
        throw new GoogleGenerativeAIResponseError(`Text not available. ${formatBlockErrorMessage(response)}`, response);
      }
      return "";
    };
    response.functionCall = () => {
      if (response.candidates && response.candidates.length > 0) {
        if (response.candidates.length > 1) {
          console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
        }
        if (hadBadFinishReason(response.candidates[0])) {
          throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
        }
        console.warn(`response.functionCall() is deprecated. Use response.functionCalls() instead.`);
        return getFunctionCalls(response)[0];
      } else if (response.promptFeedback) {
        throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
      }
      return;
    };
    response.functionCalls = () => {
      if (response.candidates && response.candidates.length > 0) {
        if (response.candidates.length > 1) {
          console.warn(`This response had ${response.candidates.length} ` + `candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`);
        }
        if (hadBadFinishReason(response.candidates[0])) {
          throw new GoogleGenerativeAIResponseError(`${formatBlockErrorMessage(response)}`, response);
        }
        return getFunctionCalls(response);
      } else if (response.promptFeedback) {
        throw new GoogleGenerativeAIResponseError(`Function call not available. ${formatBlockErrorMessage(response)}`, response);
      }
      return;
    };
    return response;
  };
  var getText = function(response) {
    var _a, _b, _c, _d;
    if ((_d = (_c = (_b = (_a = response.candidates) === null || _a === undefined ? undefined : _a[0].content) === null || _b === undefined ? undefined : _b.parts) === null || _c === undefined ? undefined : _c[0]) === null || _d === undefined ? undefined : _d.text) {
      return response.candidates[0].content.parts.map(({ text }) => text).join("");
    } else {
      return "";
    }
  };
  var getFunctionCalls = function(response) {
    var _a, _b, _c, _d;
    const functionCalls = [];
    if ((_b = (_a = response.candidates) === null || _a === undefined ? undefined : _a[0].content) === null || _b === undefined ? undefined : _b.parts) {
      for (const part of (_d = (_c = response.candidates) === null || _c === undefined ? undefined : _c[0].content) === null || _d === undefined ? undefined : _d.parts) {
        if (part.functionCall) {
          functionCalls.push(part.functionCall);
        }
      }
    }
    if (functionCalls.length > 0) {
      return functionCalls;
    } else {
      return;
    }
  };
  var hadBadFinishReason = function(candidate) {
    return !!candidate.finishReason && badFinishReasons.includes(candidate.finishReason);
  };
  var formatBlockErrorMessage = function(response) {
    var _a, _b, _c;
    let message = "";
    if ((!response.candidates || response.candidates.length === 0) && response.promptFeedback) {
      message += "Response was blocked";
      if ((_a = response.promptFeedback) === null || _a === undefined ? undefined : _a.blockReason) {
        message += ` due to ${response.promptFeedback.blockReason}`;
      }
      if ((_b = response.promptFeedback) === null || _b === undefined ? undefined : _b.blockReasonMessage) {
        message += `: ${response.promptFeedback.blockReasonMessage}`;
      }
    } else if ((_c = response.candidates) === null || _c === undefined ? undefined : _c[0]) {
      const firstCandidate = response.candidates[0];
      if (hadBadFinishReason(firstCandidate)) {
        message += `Candidate was blocked due to ${firstCandidate.finishReason}`;
        if (firstCandidate.finishMessage) {
          message += `: ${firstCandidate.finishMessage}`;
        }
      }
    }
    return message;
  };
  var __await = function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a2, b) {
            q.push([n, v, a2, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e2) {
        settle(q[0][3], e2);
      }
    }
    function step(r2) {
      r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
    }
    function fulfill(value15) {
      resume("next", value15);
    }
    function reject(value15) {
      resume("throw", value15);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  var processStream = function(response) {
    const inputStream = response.body.pipeThrough(new TextDecoderStream("utf8", { fatal: true }));
    const responseStream = getResponseStream(inputStream);
    const [stream1, stream2] = responseStream.tee();
    return {
      stream: generateResponseSequence(stream1),
      response: getResponsePromise(stream2)
    };
  };
  async function getResponsePromise(stream) {
    const allResponses = [];
    const reader = stream.getReader();
    while (true) {
      const { done, value: value15 } = await reader.read();
      if (done) {
        return addHelpers(aggregateResponses(allResponses));
      }
      allResponses.push(value15);
    }
  }
  var generateResponseSequence = function(stream) {
    return __asyncGenerator(this, arguments, function* generateResponseSequence_1() {
      const reader = stream.getReader();
      while (true) {
        const { value: value15, done } = yield __await(reader.read());
        if (done) {
          break;
        }
        yield yield __await(addHelpers(value15));
      }
    });
  };
  var getResponseStream = function(inputStream) {
    const reader = inputStream.getReader();
    const stream = new ReadableStream({
      start(controller) {
        let currentText = "";
        return pump();
        function pump() {
          return reader.read().then(({ value: value15, done }) => {
            if (done) {
              if (currentText.trim()) {
                controller.error(new GoogleGenerativeAIError("Failed to parse stream"));
                return;
              }
              controller.close();
              return;
            }
            currentText += value15;
            let match = currentText.match(responseLineRE);
            let parsedResponse;
            while (match) {
              try {
                parsedResponse = JSON.parse(match[1]);
              } catch (e2) {
                controller.error(new GoogleGenerativeAIError(`Error parsing JSON response: "${match[1]}"`));
                return;
              }
              controller.enqueue(parsedResponse);
              currentText = currentText.substring(match[0].length);
              match = currentText.match(responseLineRE);
            }
            return pump();
          });
        }
      }
    });
    return stream;
  };
  var aggregateResponses = function(responses) {
    const lastResponse = responses[responses.length - 1];
    const aggregatedResponse = {
      promptFeedback: lastResponse === null || lastResponse === undefined ? undefined : lastResponse.promptFeedback
    };
    for (const response of responses) {
      if (response.candidates) {
        for (const candidate of response.candidates) {
          const i = candidate.index;
          if (!aggregatedResponse.candidates) {
            aggregatedResponse.candidates = [];
          }
          if (!aggregatedResponse.candidates[i]) {
            aggregatedResponse.candidates[i] = {
              index: candidate.index
            };
          }
          aggregatedResponse.candidates[i].citationMetadata = candidate.citationMetadata;
          aggregatedResponse.candidates[i].finishReason = candidate.finishReason;
          aggregatedResponse.candidates[i].finishMessage = candidate.finishMessage;
          aggregatedResponse.candidates[i].safetyRatings = candidate.safetyRatings;
          if (candidate.content && candidate.content.parts) {
            if (!aggregatedResponse.candidates[i].content) {
              aggregatedResponse.candidates[i].content = {
                role: candidate.content.role || "user",
                parts: []
              };
            }
            const newPart = {};
            for (const part of candidate.content.parts) {
              if (part.text) {
                newPart.text = part.text;
              }
              if (part.functionCall) {
                newPart.functionCall = part.functionCall;
              }
              if (Object.keys(newPart).length === 0) {
                newPart.text = "";
              }
              aggregatedResponse.candidates[i].content.parts.push(newPart);
            }
          }
        }
      }
    }
    return aggregatedResponse;
  };
  async function generateContentStream(apiKey, model, params, requestOptions) {
    const response = await makeRequest(model, Task.STREAM_GENERATE_CONTENT, apiKey, true, JSON.stringify(params), requestOptions);
    return processStream(response);
  }
  async function generateContent(apiKey, model, params, requestOptions) {
    const response = await makeRequest(model, Task.GENERATE_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
    const responseJson = await response.json();
    const enhancedResponse = addHelpers(responseJson);
    return {
      response: enhancedResponse
    };
  }
  var formatNewContent = function(request) {
    let newParts = [];
    if (typeof request === "string") {
      newParts = [{ text: request }];
    } else {
      for (const partOrString of request) {
        if (typeof partOrString === "string") {
          newParts.push({ text: partOrString });
        } else {
          newParts.push(partOrString);
        }
      }
    }
    return assignRoleToPartsAndValidateSendMessageRequest(newParts);
  };
  var assignRoleToPartsAndValidateSendMessageRequest = function(parts) {
    const userContent = { role: "user", parts: [] };
    const functionContent = { role: "function", parts: [] };
    let hasUserContent = false;
    let hasFunctionContent = false;
    for (const part of parts) {
      if ("functionResponse" in part) {
        functionContent.parts.push(part);
        hasFunctionContent = true;
      } else {
        userContent.parts.push(part);
        hasUserContent = true;
      }
    }
    if (hasUserContent && hasFunctionContent) {
      throw new GoogleGenerativeAIError("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");
    }
    if (!hasUserContent && !hasFunctionContent) {
      throw new GoogleGenerativeAIError("No content is provided for sending chat message.");
    }
    if (hasUserContent) {
      return userContent;
    }
    return functionContent;
  };
  var formatGenerateContentInput = function(params) {
    if (params.contents) {
      return params;
    } else {
      const content = formatNewContent(params);
      return { contents: [content] };
    }
  };
  var formatEmbedContentInput = function(params) {
    if (typeof params === "string" || Array.isArray(params)) {
      const content = formatNewContent(params);
      return { content };
    }
    return params;
  };
  var validateChatHistory = function(history) {
    let prevContent;
    for (const currContent of history) {
      const { role, parts } = currContent;
      if (!prevContent && role !== "user") {
        throw new GoogleGenerativeAIError(`First content should be with role 'user', got ${role}`);
      }
      if (!POSSIBLE_ROLES.includes(role)) {
        throw new GoogleGenerativeAIError(`Each item should include role field. Got ${role} but valid roles are: ${JSON.stringify(POSSIBLE_ROLES)}`);
      }
      if (!Array.isArray(parts)) {
        throw new GoogleGenerativeAIError("Content should have 'parts' property with an array of Parts");
      }
      if (parts.length === 0) {
        throw new GoogleGenerativeAIError("Each Content should have at least one part");
      }
      const countFields = {
        text: 0,
        inlineData: 0,
        functionCall: 0,
        functionResponse: 0
      };
      for (const part of parts) {
        for (const key of VALID_PART_FIELDS) {
          if (key in part) {
            countFields[key] += 1;
          }
        }
      }
      const validParts = VALID_PARTS_PER_ROLE[role];
      for (const key of VALID_PART_FIELDS) {
        if (!validParts.includes(key) && countFields[key] > 0) {
          throw new GoogleGenerativeAIError(`Content with role '${role}' can't contain '${key}' part`);
        }
      }
      if (prevContent) {
        const validPreviousContentRoles = VALID_PREVIOUS_CONTENT_ROLES[role];
        if (!validPreviousContentRoles.includes(prevContent.role)) {
          throw new GoogleGenerativeAIError(`Content with role '${role}' can't follow '${prevContent.role}'. Valid previous roles: ${JSON.stringify(VALID_PREVIOUS_CONTENT_ROLES)}`);
        }
      }
      prevContent = currContent;
    }
  };
  async function countTokens(apiKey, model, params, requestOptions) {
    const response = await makeRequest(model, Task.COUNT_TOKENS, apiKey, false, JSON.stringify(Object.assign(Object.assign({}, params), { model })), requestOptions);
    return response.json();
  }
  async function embedContent(apiKey, model, params, requestOptions) {
    const response = await makeRequest(model, Task.EMBED_CONTENT, apiKey, false, JSON.stringify(params), requestOptions);
    return response.json();
  }
  async function batchEmbedContents(apiKey, model, params, requestOptions) {
    const requestsWithModel = params.requests.map((request) => {
      return Object.assign(Object.assign({}, request), { model });
    });
    const response = await makeRequest(model, Task.BATCH_EMBED_CONTENTS, apiKey, false, JSON.stringify({ requests: requestsWithModel }), requestOptions);
    return response.json();
  }
  var POSSIBLE_ROLES = ["user", "model", "function", "system"];
  exports.HarmCategory = undefined;
  (function(HarmCategory) {
    HarmCategory["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
    HarmCategory["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
    HarmCategory["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
    HarmCategory["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
    HarmCategory["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  })(exports.HarmCategory || (exports.HarmCategory = {}));
  exports.HarmBlockThreshold = undefined;
  (function(HarmBlockThreshold) {
    HarmBlockThreshold["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
    HarmBlockThreshold["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
    HarmBlockThreshold["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
    HarmBlockThreshold["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
    HarmBlockThreshold["BLOCK_NONE"] = "BLOCK_NONE";
  })(exports.HarmBlockThreshold || (exports.HarmBlockThreshold = {}));
  exports.HarmProbability = undefined;
  (function(HarmProbability) {
    HarmProbability["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
    HarmProbability["NEGLIGIBLE"] = "NEGLIGIBLE";
    HarmProbability["LOW"] = "LOW";
    HarmProbability["MEDIUM"] = "MEDIUM";
    HarmProbability["HIGH"] = "HIGH";
  })(exports.HarmProbability || (exports.HarmProbability = {}));
  exports.BlockReason = undefined;
  (function(BlockReason) {
    BlockReason["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
    BlockReason["SAFETY"] = "SAFETY";
    BlockReason["OTHER"] = "OTHER";
  })(exports.BlockReason || (exports.BlockReason = {}));
  exports.FinishReason = undefined;
  (function(FinishReason) {
    FinishReason["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
    FinishReason["STOP"] = "STOP";
    FinishReason["MAX_TOKENS"] = "MAX_TOKENS";
    FinishReason["SAFETY"] = "SAFETY";
    FinishReason["RECITATION"] = "RECITATION";
    FinishReason["OTHER"] = "OTHER";
  })(exports.FinishReason || (exports.FinishReason = {}));
  exports.TaskType = undefined;
  (function(TaskType) {
    TaskType["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
    TaskType["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
    TaskType["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
    TaskType["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
    TaskType["CLASSIFICATION"] = "CLASSIFICATION";
    TaskType["CLUSTERING"] = "CLUSTERING";
  })(exports.TaskType || (exports.TaskType = {}));
  exports.FunctionCallingMode = undefined;
  (function(FunctionCallingMode) {
    FunctionCallingMode["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
    FunctionCallingMode["AUTO"] = "AUTO";
    FunctionCallingMode["ANY"] = "ANY";
    FunctionCallingMode["NONE"] = "NONE";
  })(exports.FunctionCallingMode || (exports.FunctionCallingMode = {}));
  exports.FunctionDeclarationSchemaType = undefined;
  (function(FunctionDeclarationSchemaType) {
    FunctionDeclarationSchemaType["STRING"] = "STRING";
    FunctionDeclarationSchemaType["NUMBER"] = "NUMBER";
    FunctionDeclarationSchemaType["INTEGER"] = "INTEGER";
    FunctionDeclarationSchemaType["BOOLEAN"] = "BOOLEAN";
    FunctionDeclarationSchemaType["ARRAY"] = "ARRAY";
    FunctionDeclarationSchemaType["OBJECT"] = "OBJECT";
  })(exports.FunctionDeclarationSchemaType || (exports.FunctionDeclarationSchemaType = {}));

  class GoogleGenerativeAIError extends Error {
    constructor(message) {
      super(`[GoogleGenerativeAI Error]: ${message}`);
    }
  }

  class GoogleGenerativeAIResponseError extends GoogleGenerativeAIError {
    constructor(message, response) {
      super(message);
      this.response = response;
    }
  }
  var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
  var DEFAULT_API_VERSION = "v1beta";
  var PACKAGE_VERSION = "0.7.1";
  var PACKAGE_LOG_HEADER = "genai-js";
  var Task;
  (function(Task2) {
    Task2["GENERATE_CONTENT"] = "generateContent";
    Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
    Task2["COUNT_TOKENS"] = "countTokens";
    Task2["EMBED_CONTENT"] = "embedContent";
    Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
  })(Task || (Task = {}));

  class RequestUrl {
    constructor(model, task, apiKey, stream, requestOptions) {
      this.model = model;
      this.task = task;
      this.apiKey = apiKey;
      this.stream = stream;
      this.requestOptions = requestOptions;
    }
    toString() {
      var _a, _b;
      const apiVersion = ((_a = this.requestOptions) === null || _a === undefined ? undefined : _a.apiVersion) || DEFAULT_API_VERSION;
      const baseUrl = ((_b = this.requestOptions) === null || _b === undefined ? undefined : _b.baseUrl) || DEFAULT_BASE_URL;
      let url = `${baseUrl}/${apiVersion}/${this.model}:${this.task}`;
      if (this.stream) {
        url += "?alt=sse";
      }
      return url;
    }
  }
  var badFinishReasons = [exports.FinishReason.RECITATION, exports.FinishReason.SAFETY];
  var responseLineRE = /^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;
  var VALID_PART_FIELDS = [
    "text",
    "inlineData",
    "functionCall",
    "functionResponse"
  ];
  var VALID_PARTS_PER_ROLE = {
    user: ["text", "inlineData"],
    function: ["functionResponse"],
    model: ["text", "functionCall"],
    system: ["text"]
  };
  var VALID_PREVIOUS_CONTENT_ROLES = {
    user: ["model"],
    function: ["model"],
    model: ["user", "function"],
    system: []
  };
  var SILENT_ERROR = "SILENT_ERROR";

  class ChatSession {
    constructor(apiKey, model, params, requestOptions) {
      this.model = model;
      this.params = params;
      this.requestOptions = requestOptions;
      this._history = [];
      this._sendPromise = Promise.resolve();
      this._apiKey = apiKey;
      if (params === null || params === undefined ? undefined : params.history) {
        validateChatHistory(params.history);
        this._history = params.history;
      }
    }
    async getHistory() {
      await this._sendPromise;
      return this._history;
    }
    async sendMessage(request) {
      var _a, _b, _c, _d, _e;
      await this._sendPromise;
      const newContent = formatNewContent(request);
      const generateContentRequest = {
        safetySettings: (_a = this.params) === null || _a === undefined ? undefined : _a.safetySettings,
        generationConfig: (_b = this.params) === null || _b === undefined ? undefined : _b.generationConfig,
        tools: (_c = this.params) === null || _c === undefined ? undefined : _c.tools,
        toolConfig: (_d = this.params) === null || _d === undefined ? undefined : _d.toolConfig,
        systemInstruction: (_e = this.params) === null || _e === undefined ? undefined : _e.systemInstruction,
        contents: [...this._history, newContent]
      };
      let finalResult;
      this._sendPromise = this._sendPromise.then(() => generateContent(this._apiKey, this.model, generateContentRequest, this.requestOptions)).then((result) => {
        var _a2;
        if (result.response.candidates && result.response.candidates.length > 0) {
          this._history.push(newContent);
          const responseContent = Object.assign({
            parts: [],
            role: "model"
          }, (_a2 = result.response.candidates) === null || _a2 === undefined ? undefined : _a2[0].content);
          this._history.push(responseContent);
        } else {
          const blockErrorMessage = formatBlockErrorMessage(result.response);
          if (blockErrorMessage) {
            console.warn(`sendMessage() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
          }
        }
        finalResult = result;
      });
      await this._sendPromise;
      return finalResult;
    }
    async sendMessageStream(request) {
      var _a, _b, _c, _d, _e;
      await this._sendPromise;
      const newContent = formatNewContent(request);
      const generateContentRequest = {
        safetySettings: (_a = this.params) === null || _a === undefined ? undefined : _a.safetySettings,
        generationConfig: (_b = this.params) === null || _b === undefined ? undefined : _b.generationConfig,
        tools: (_c = this.params) === null || _c === undefined ? undefined : _c.tools,
        toolConfig: (_d = this.params) === null || _d === undefined ? undefined : _d.toolConfig,
        systemInstruction: (_e = this.params) === null || _e === undefined ? undefined : _e.systemInstruction,
        contents: [...this._history, newContent]
      };
      const streamPromise = generateContentStream(this._apiKey, this.model, generateContentRequest, this.requestOptions);
      this._sendPromise = this._sendPromise.then(() => streamPromise).catch((_ignored) => {
        throw new Error(SILENT_ERROR);
      }).then((streamResult) => streamResult.response).then((response) => {
        if (response.candidates && response.candidates.length > 0) {
          this._history.push(newContent);
          const responseContent = Object.assign({}, response.candidates[0].content);
          if (!responseContent.role) {
            responseContent.role = "model";
          }
          this._history.push(responseContent);
        } else {
          const blockErrorMessage = formatBlockErrorMessage(response);
          if (blockErrorMessage) {
            console.warn(`sendMessageStream() was unsuccessful. ${blockErrorMessage}. Inspect response object for details.`);
          }
        }
      }).catch((e2) => {
        if (e2.message !== SILENT_ERROR) {
          console.error(e2);
        }
      });
      return streamPromise;
    }
  }

  class GenerativeModel {
    constructor(apiKey, modelParams, requestOptions) {
      this.apiKey = apiKey;
      if (modelParams.model.includes("/")) {
        this.model = modelParams.model;
      } else {
        this.model = `models/${modelParams.model}`;
      }
      this.generationConfig = modelParams.generationConfig || {};
      this.safetySettings = modelParams.safetySettings || [];
      this.tools = modelParams.tools;
      this.toolConfig = modelParams.toolConfig;
      this.systemInstruction = modelParams.systemInstruction;
      this.requestOptions = requestOptions || {};
    }
    async generateContent(request) {
      const formattedParams = formatGenerateContentInput(request);
      return generateContent(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction }, formattedParams), this.requestOptions);
    }
    async generateContentStream(request) {
      const formattedParams = formatGenerateContentInput(request);
      return generateContentStream(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction }, formattedParams), this.requestOptions);
    }
    startChat(startChatParams) {
      return new ChatSession(this.apiKey, this.model, Object.assign({ generationConfig: this.generationConfig, safetySettings: this.safetySettings, tools: this.tools, toolConfig: this.toolConfig, systemInstruction: this.systemInstruction }, startChatParams), this.requestOptions);
    }
    async countTokens(request) {
      const formattedParams = formatGenerateContentInput(request);
      return countTokens(this.apiKey, this.model, formattedParams, this.requestOptions);
    }
    async embedContent(request) {
      const formattedParams = formatEmbedContentInput(request);
      return embedContent(this.apiKey, this.model, formattedParams, this.requestOptions);
    }
    async batchEmbedContents(batchEmbedContentRequest) {
      return batchEmbedContents(this.apiKey, this.model, batchEmbedContentRequest, this.requestOptions);
    }
  }

  class GoogleGenerativeAI {
    constructor(apiKey) {
      this.apiKey = apiKey;
    }
    getGenerativeModel(modelParams, requestOptions) {
      if (!modelParams.model) {
        throw new GoogleGenerativeAIError(`Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })`);
      }
      return new GenerativeModel(this.apiKey, modelParams, requestOptions);
    }
  }
  exports.ChatSession = ChatSession;
  exports.GenerativeModel = GenerativeModel;
  exports.GoogleGenerativeAI = GoogleGenerativeAI;
  exports.POSSIBLE_ROLES = POSSIBLE_ROLES;
});

// node_modules/eventemitter3/index.mjs
var import_ = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_.default;

// node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return IsNumber(value) && Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/import/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    const isNumber = IsNumber(value);
    return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/import/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => {
    {
      return Set2;
    }
  },
  Has: () => {
    {
      return Has;
    }
  },
  Get: () => {
    {
      return Get;
    }
  },
  Entries: () => {
    {
      return Entries;
    }
  },
  Delete: () => {
    {
      return Delete;
    }
  },
  Clear: () => {
    {
      return Clear;
    }
  }
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/import/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => {
    {
      return Set3;
    }
  },
  Has: () => {
    {
      return Has2;
    }
  },
  Get: () => {
    {
      return Get2;
    }
  },
  Entries: () => {
    {
      return Entries2;
    }
  },
  Delete: () => {
    {
      return Delete2;
    }
  },
  Clear: () => {
    {
      return Clear2;
    }
  }
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/import/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => {
    {
      return IsUndefined2;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol2;
    }
  },
  IsString: () => {
    {
      return IsString2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp;
    }
  },
  IsObject: () => {
    {
      return IsObject2;
    }
  },
  IsNumber: () => {
    {
      return IsNumber2;
    }
  },
  IsNull: () => {
    {
      return IsNull2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction2;
    }
  },
  IsDate: () => {
    {
      return IsDate2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean2;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt2;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator2;
    }
  },
  IsArray: () => {
    {
      return IsArray2;
    }
  }
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/import/type/clone/value.mjs
var ArrayType = function(value) {
  return value.map((value2) => Visit(value2));
};
var DateType = function(value) {
  return new Date(value.getTime());
};
var Uint8ArrayType = function(value) {
  return new Uint8Array(value);
};
var RegExpType = function(value) {
  return new RegExp(value.source, value.flags);
};
var ObjectType = function(value) {
  const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  return { ...clonedProperties, ...clonedSymbols };
};
var Visit = function(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
};
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs
var DiscardKey = function(value2, key) {
  const { [key]: _, ...rest } = value2;
  return rest;
};
function Discard(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
}
// node_modules/@sinclair/typebox/build/import/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError;
    }
  },
  IsVoid: () => {
    {
      return IsVoid;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral;
    }
  },
  IsUnion: () => {
    {
      return IsUnion;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined3;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array3;
    }
  },
  IsTuple: () => {
    {
      return IsTuple;
    }
  },
  IsTransform: () => {
    {
      return IsTransform;
    }
  },
  IsThis: () => {
    {
      return IsThis;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol3;
    }
  },
  IsString: () => {
    {
      return IsString3;
    }
  },
  IsSchema: () => {
    {
      return IsSchema;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp2;
    }
  },
  IsRef: () => {
    {
      return IsRef;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive;
    }
  },
  IsRecord: () => {
    {
      return IsRecord;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly;
    }
  },
  IsProperties: () => {
    {
      return IsProperties;
    }
  },
  IsPromise: () => {
    {
      return IsPromise2;
    }
  },
  IsOptional: () => {
    {
      return IsOptional;
    }
  },
  IsObject: () => {
    {
      return IsObject3;
    }
  },
  IsNumber: () => {
    {
      return IsNumber3;
    }
  },
  IsNull: () => {
    {
      return IsNull3;
    }
  },
  IsNot: () => {
    {
      return IsNot;
    }
  },
  IsNever: () => {
    {
      return IsNever;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf;
    }
  },
  IsKind: () => {
    {
      return IsKind;
    }
  },
  IsIterator: () => {
    {
      return IsIterator3;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect;
    }
  },
  IsInteger: () => {
    {
      return IsInteger2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction3;
    }
  },
  IsDate: () => {
    {
      return IsDate3;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean3;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt3;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator3;
    }
  },
  IsArray: () => {
    {
      return IsArray3;
    }
  },
  IsAny: () => {
    {
      return IsAny;
    }
  }
});
var IsPattern = function(value2) {
  try {
    new RegExp(value2);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree = function(value2) {
  if (!IsString2(value2))
    return false;
  for (let i = 0;i < value2.length; i++) {
    const code = value2.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties = function(value2) {
  return IsOptionalBoolean(value2) || IsSchema(value2);
};
var IsOptionalBigInt = function(value2) {
  return IsUndefined2(value2) || IsBigInt2(value2);
};
var IsOptionalNumber = function(value2) {
  return IsUndefined2(value2) || IsNumber2(value2);
};
var IsOptionalBoolean = function(value2) {
  return IsUndefined2(value2) || IsBoolean2(value2);
};
var IsOptionalString = function(value2) {
  return IsUndefined2(value2) || IsString2(value2);
};
var IsOptionalPattern = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
};
var IsOptionalFormat = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2);
};
var IsOptionalSchema = function(value2) {
  return IsUndefined2(value2) || IsSchema(value2);
};
function IsReadonly(value2) {
  return IsObject2(value2) && value2[ReadonlyKind] === "Readonly";
}
function IsOptional(value2) {
  return IsObject2(value2) && value2[OptionalKind] === "Optional";
}
function IsAny(value2) {
  return IsKindOf(value2, "Any") && IsOptionalString(value2.$id);
}
function IsArray3(value2) {
  return IsKindOf(value2, "Array") && value2.type === "array" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);
}
function IsAsyncIterator3(value2) {
  return IsKindOf(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsBigInt3(value2) {
  return IsKindOf(value2, "BigInt") && value2.type === "bigint" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);
}
function IsBoolean3(value2) {
  return IsKindOf(value2, "Boolean") && value2.type === "boolean" && IsOptionalString(value2.$id);
}
function IsConstructor(value2) {
  return IsKindOf(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsDate3(value2) {
  return IsKindOf(value2, "Date") && value2.type === "Date" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);
}
function IsFunction3(value2) {
  return IsKindOf(value2, "Function") && value2.type === "Function" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsInteger2(value2) {
  return IsKindOf(value2, "Integer") && value2.type === "integer" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsProperties(value2) {
  return IsObject2(value2) && Object.entries(value2).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
}
function IsIntersect(value2) {
  return IsKindOf(value2, "Intersect") && (IsString2(value2.type) && value2.type !== "object" ? false : true) && IsArray2(value2.allOf) && value2.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value2.type) && (IsOptionalBoolean(value2.unevaluatedProperties) || IsOptionalSchema(value2.unevaluatedProperties)) && IsOptionalString(value2.$id);
}
function IsIterator3(value2) {
  return IsKindOf(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsKindOf(value2, kind) {
  return IsObject2(value2) && Kind in value2 && value2[Kind] === kind;
}
function IsLiteralString(value2) {
  return IsLiteral(value2) && IsString2(value2.const);
}
function IsLiteralNumber(value2) {
  return IsLiteral(value2) && IsNumber2(value2.const);
}
function IsLiteralBoolean(value2) {
  return IsLiteral(value2) && IsBoolean2(value2.const);
}
function IsLiteral(value2) {
  return IsKindOf(value2, "Literal") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);
}
function IsLiteralValue(value2) {
  return IsBoolean2(value2) || IsNumber2(value2) || IsString2(value2);
}
function IsMappedKey(value2) {
  return IsKindOf(value2, "MappedKey") && IsArray2(value2.keys) && value2.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult(value2) {
  return IsKindOf(value2, "MappedResult") && IsProperties(value2.properties);
}
function IsNever(value2) {
  return IsKindOf(value2, "Never") && IsObject2(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
}
function IsNot(value2) {
  return IsKindOf(value2, "Not") && IsSchema(value2.not);
}
function IsNull3(value2) {
  return IsKindOf(value2, "Null") && value2.type === "null" && IsOptionalString(value2.$id);
}
function IsNumber3(value2) {
  return IsKindOf(value2, "Number") && value2.type === "number" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsObject3(value2) {
  return IsKindOf(value2, "Object") && value2.type === "object" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);
}
function IsPromise2(value2) {
  return IsKindOf(value2, "Promise") && value2.type === "Promise" && IsOptionalString(value2.$id) && IsSchema(value2.item);
}
function IsRecord(value2) {
  return IsKindOf(value2, "Record") && value2.type === "object" && IsOptionalString(value2.$id) && IsAdditionalProperties(value2.additionalProperties) && IsObject2(value2.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
  })(value2);
}
function IsRecursive(value2) {
  return IsObject2(value2) && Hint in value2 && value2[Hint] === "Recursive";
}
function IsRef(value2) {
  return IsKindOf(value2, "Ref") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsRegExp2(value2) {
  return IsKindOf(value2, "RegExp") && IsOptionalString(value2.$id) && IsString2(value2.source) && IsString2(value2.flags) && IsOptionalNumber(value2.maxLength) && IsOptionalNumber(value2.minLength);
}
function IsString3(value2) {
  return IsKindOf(value2, "String") && value2.type === "string" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);
}
function IsSymbol3(value2) {
  return IsKindOf(value2, "Symbol") && value2.type === "symbol" && IsOptionalString(value2.$id);
}
function IsTemplateLiteral(value2) {
  return IsKindOf(value2, "TemplateLiteral") && value2.type === "string" && IsString2(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
}
function IsThis(value2) {
  return IsKindOf(value2, "This") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsTransform(value2) {
  return IsObject2(value2) && TransformKind in value2;
}
function IsTuple(value2) {
  return IsKindOf(value2, "Tuple") && value2.type === "array" && IsOptionalString(value2.$id) && IsNumber2(value2.minItems) && IsNumber2(value2.maxItems) && value2.minItems === value2.maxItems && (IsUndefined2(value2.items) && IsUndefined2(value2.additionalItems) && value2.minItems === 0 || IsArray2(value2.items) && value2.items.every((schema) => IsSchema(schema)));
}
function IsUndefined3(value2) {
  return IsKindOf(value2, "Undefined") && value2.type === "undefined" && IsOptionalString(value2.$id);
}
function IsUnionLiteral(value2) {
  return IsUnion(value2) && value2.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion(value2) {
  return IsKindOf(value2, "Union") && IsOptionalString(value2.$id) && IsObject2(value2) && IsArray2(value2.anyOf) && value2.anyOf.every((schema) => IsSchema(schema));
}
function IsUint8Array3(value2) {
  return IsKindOf(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);
}
function IsUnknown(value2) {
  return IsKindOf(value2, "Unknown") && IsOptionalString(value2.$id);
}
function IsUnsafe(value2) {
  return IsKindOf(value2, "Unsafe");
}
function IsVoid(value2) {
  return IsKindOf(value2, "Void") && value2.type === "void" && IsOptionalString(value2.$id);
}
function IsKind(value2) {
  return IsObject2(value2) && Kind in value2 && IsString2(value2[Kind]) && !KnownTypes.includes(value2[Kind]);
}
function IsSchema(value2) {
  return IsObject2(value2) && (IsAny(value2) || IsArray3(value2) || IsBoolean3(value2) || IsBigInt3(value2) || IsAsyncIterator3(value2) || IsConstructor(value2) || IsDate3(value2) || IsFunction3(value2) || IsInteger2(value2) || IsIntersect(value2) || IsIterator3(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull3(value2) || IsNumber3(value2) || IsObject3(value2) || IsPromise2(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp2(value2) || IsString3(value2) || IsSymbol3(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined3(value2) || IsUnion(value2) || IsUint8Array3(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];

// node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs
var RemoveOptional = function(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
};
var AddOptional = function(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
};
var OptionalWithFlag = function(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
};
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs
var FromProperties = function(P, F) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Optional(P[K2], F) };
  }, {});
};
var FromMappedResult = function(R, F) {
  return FromProperties(R.properties, F);
};
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional = function(T) {
  return T.every((L) => IsOptional(L));
};
var RemoveOptionalFromType = function(T) {
  return Discard(T, [OptionalKind]);
};
var RemoveOptionalFromRest = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
};
var ResolveIntersect = function(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
};
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs
var IsUnionOptional = function(T) {
  return T.some((L) => IsOptional(L));
};
var RemoveOptionalFromRest2 = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
};
var RemoveOptionalFromType2 = function(T) {
  return Discard(T, [OptionalKind]);
};
var ResolveUnion = function(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
};
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs
var Unescape = function(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
};
var IsNonEscaped = function(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
};
var IsOpenParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
};
var IsCloseParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
};
var IsSeparator = function(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
};
var IsGroup = function(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
};
var InGroup = function(pattern) {
  return pattern.slice(1, pattern.length - 1);
};
var IsPrecedenceOr = function(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd = function(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
};
var Or = function(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And = function(pattern) {
  function Group(value2, index) {
    if (!IsOpenParen(value2, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen(value2, scan))
        count += 1;
      if (IsCloseParen(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs
var IsNumberExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs
function Literal(value2, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value2,
    type: typeof value2
  };
}
// node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs
function Boolean(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/import/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/import/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal(literal3.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs
var Escape = function(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit2 = function(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
};
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern2 = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral = function(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
};
var FromUnion2 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, ...IndexPropertyKeys(L)];
  }, []);
};
var FromLiteral = function(T) {
  return [T.toString()];
};
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs
var FromProperties2 = function(T, P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };
  }, {});
};
var FromMappedResult2 = function(T, R, options) {
  return FromProperties2(T, R.properties, options);
};
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs
var FromRest = function(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
};
var FromIntersectRest = function(T) {
  return T.filter((L) => !IsNever(L));
};
var FromIntersect = function(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
};
var FromUnionRest = function(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
};
var FromUnion3 = function(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
};
var FromTuple = function(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
};
var FromArray = function(T, K) {
  return K === "[number]" ? T : Never();
};
var FromProperty = function(T, K) {
  return K in T ? T[K] : Never();
};
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
var FromSchema = function(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
};
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey = function(T, K, options) {
  return { [K]: Index(T, [K], options) };
};
var MappedIndexPropertyKeys = function(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
};
var MappedIndexProperties = function(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
};
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/object/object.mjs
var _Object = function(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
};
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs
var RemoveReadonly = function(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
};
var AddReadonly = function(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
};
var ReadonlyWithFlag = function(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
};
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs
var FromProperties3 = function(K, F) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Readonly(K[K2], F) };
  }, {});
};
var FromMappedResult3 = function(R, F) {
  return FromProperties3(R.properties, F);
};
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/import/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
var SetIntersectManyResolve = function(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
};
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  return T.reduce((Acc, L) => [...Acc, ...L], []);
}
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs
var FromMappedResult4 = function(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
};
var MappedKeyToKnownMappedResultProperties = function(K) {
  return { [K]: Literal(K) };
};
var MappedKeyToUnknownMappedResultProperties = function(P) {
  return P.reduce((Acc, L) => {
    return { ...Acc, [L]: Literal(L) };
  }, {});
};
var MappedKeyToMappedResultProperties = function(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
};
var FromMappedKey = function(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
};
var FromRest2 = function(K, T) {
  return T.map((L) => FromSchemaType(K, L));
};
var FromProperties4 = function(K, T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
    return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };
  }, {});
};
var FromSchemaType = function(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
};
function MappedFunctionReturnType(K, T, Acc = {}) {
  return K.reduce((Acc2, L) => {
    return { ...Acc2, [L]: FromSchemaType(L, T) };
  }, {});
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs
var FromRest3 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, KeyOfPropertyKeys(L)];
  }, []);
};
var FromIntersect2 = function(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
};
var FromUnion4 = function(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
};
var FromTuple2 = function(T) {
  return T.map((_, I) => I.toString());
};
var FromArray2 = function(_) {
  return ["[number]"];
};
var FromProperties5 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties = function(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs
var FromProperties6 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: KeyOf(K[K2], options) };
  }, {});
};
var FromMappedResult5 = function(R, options) {
  return FromProperties6(R.properties, options);
};
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs
var Intersect2 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
};
var Union2 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
};
var Not = function(schema) {
  return !ExtendsUndefinedCheck(schema.not);
};
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/import/errors/function.mjs
function DefaultErrorFunction(error8) {
  switch (error8.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error8.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error8.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error8.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error8.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error8.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error8.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error8.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error8.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error8.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error8.schema.const === "string" ? `'${error8.schema.const}'` : error8.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error8.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error8.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error8.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error8.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error8.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error8.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error8.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error8.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error8.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error8.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error8.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}

class TypeDereferenceError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs
function* NumberToBytes(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value3 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Array);
  for (const item of value3) {
    Visit3(item);
  }
};
var BooleanType = function(value3) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value3 ? 1 : 0);
};
var BigIntType = function(value3) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var DateType2 = function(value3) {
  FNV1A64(ByteMarker.Date);
  Visit3(value3.getTime());
};
var NullType = function(value3) {
  FNV1A64(ByteMarker.Null);
};
var NumberType = function(value3) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var ObjectType2 = function(value3) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value3).sort()) {
    Visit3(key);
    Visit3(value3[key]);
  }
};
var StringType = function(value3) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value3.length; i++) {
    for (const byte of NumberToBytes(value3.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
};
var SymbolType = function(value3) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value3.description);
};
var Uint8ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value3.length; i++) {
    FNV1A64(value3[i]);
  }
};
var UndefinedType = function(value3) {
  return FNV1A64(ByteMarker.Undefined);
};
var Visit3 = function(value3) {
  if (IsArray(value3))
    return ArrayType2(value3);
  if (IsBoolean(value3))
    return BooleanType(value3);
  if (IsBigInt(value3))
    return BigIntType(value3);
  if (IsDate(value3))
    return DateType2(value3);
  if (IsNull(value3))
    return NullType(value3);
  if (IsNumber(value3))
    return NumberType(value3);
  if (IsStandardObject(value3))
    return ObjectType2(value3);
  if (IsString(value3))
    return StringType(value3);
  if (IsSymbol(value3))
    return SymbolType(value3);
  if (IsUint8Array(value3))
    return Uint8ArrayType2(value3);
  if (IsUndefined(value3))
    return UndefinedType(value3);
  throw new ValueHashError(value3);
};
var FNV1A64 = function(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
};
function Hash(value3) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value3);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  value;
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// node_modules/@sinclair/typebox/build/import/errors/errors.mjs
var EscapeKey = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined = function(value3) {
  return value3 !== undefined;
};
var Create = function(errorType, schema, path, value3) {
  return { type: errorType, schema, path, value: value3, message: GetErrorFunction()({ errorType, path, schema, value: value3 }) };
};
function* FromAny(schema, references, path, value3) {
}
function* FromArray3(schema, references, path, value3) {
  if (!IsArray(value3)) {
    return yield Create(ValueErrorType.Array, schema, path, value3);
  }
  if (IsDefined(schema.minItems) && !(value3.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value3);
  }
  if (IsDefined(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value3);
  }
  for (let i = 0;i < value3.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value3[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value3);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4, index) => Visit4(containsSchema, references, `${path}${index}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value3);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value3);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value3);
  }
}
function* FromAsyncIterator(schema, references, path, value3) {
  if (!IsAsyncIterator(value3))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value3);
}
function* FromBigInt(schema, references, path, value3) {
  if (!IsBigInt(value3))
    return yield Create(ValueErrorType.BigInt, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value3);
  }
}
function* FromBoolean(schema, references, path, value3) {
  if (!IsBoolean(value3))
    yield Create(ValueErrorType.Boolean, schema, path, value3);
}
function* FromConstructor(schema, references, path, value3) {
  yield* Visit4(schema.returns, references, path, value3.prototype);
}
function* FromDate(schema, references, path, value3) {
  if (!IsDate(value3))
    return yield Create(ValueErrorType.Date, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value3);
  }
}
function* FromFunction(schema, references, path, value3) {
  if (!IsFunction(value3))
    yield Create(ValueErrorType.Function, schema, path, value3);
}
function* FromInteger(schema, references, path, value3) {
  if (!IsInteger(value3))
    return yield Create(ValueErrorType.Integer, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value3);
  }
}
function* FromIntersect3(schema, references, path, value3) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value3).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value3);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value3) {
  if (!IsIterator(value3))
    yield Create(ValueErrorType.Iterator, schema, path, value3);
}
function* FromLiteral2(schema, references, path, value3) {
  if (!(value3 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value3);
}
function* FromNever(schema, references, path, value3) {
  yield Create(ValueErrorType.Never, schema, path, value3);
}
function* FromNot(schema, references, path, value3) {
  if (Visit4(schema.not, references, path, value3).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value3);
}
function* FromNull(schema, references, path, value3) {
  if (!IsNull(value3))
    yield Create(ValueErrorType.Null, schema, path, value3);
}
function* FromNumber(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return yield Create(ValueErrorType.Number, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value3);
  }
}
function* FromObject(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value3)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value3) {
  if (!IsPromise(value3))
    yield Create(ValueErrorType.Promise, schema, path, value3);
}
function* FromRecord(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromRegExp(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value3)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value3);
  }
}
function* FromString(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value3);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value3);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value3)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value3);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value3) {
  if (!IsSymbol(value3))
    yield Create(ValueErrorType.Symbol, schema, path, value3);
}
function* FromTemplateLiteral2(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value3)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value3);
  }
}
function* FromThis(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromTuple3(schema, references, path, value3) {
  if (!IsArray(value3))
    return yield Create(ValueErrorType.Tuple, schema, path, value3);
  if (schema.items === undefined && !(value3.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!(value3.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value3[i]);
  }
}
function* FromUndefined(schema, references, path, value3) {
  if (!IsUndefined(value3))
    yield Create(ValueErrorType.Undefined, schema, path, value3);
}
function* FromUnion5(schema, references, path, value3) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value3);
  }
}
function* FromUint8Array(schema, references, path, value3) {
  if (!IsUint8Array(value3))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value3);
  if (IsDefined(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value3);
  }
  if (IsDefined(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value3);
  }
}
function* FromUnknown(schema, references, path, value3) {
}
function* FromVoid(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsVoidLike(value3))
    yield Create(ValueErrorType.Void, schema, path, value3);
}
function* FromKind(schema, references, path, value3) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value3))
    yield Create(ValueErrorType.Kind, schema, path, value3);
}
function* Visit4(schema, references, path, value3) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value3);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value3);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value3);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value3);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value3);
    case "Date":
      return yield* FromDate(schema_, references_, path, value3);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value3);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value3);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value3);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value3);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value3);
    case "Never":
      return yield* FromNever(schema_, references_, path, value3);
    case "Not":
      return yield* FromNot(schema_, references_, path, value3);
    case "Null":
      return yield* FromNull(schema_, references_, path, value3);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value3);
    case "Object":
      return yield* FromObject(schema_, references_, path, value3);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value3);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value3);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value3);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value3);
    case "String":
      return yield* FromString(schema_, references_, path, value3);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value3);
    case "This":
      return yield* FromThis(schema_, references_, path, value3);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value3);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value3);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value3);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value3);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value3);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value3);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  iterator;
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/import/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs
var IntoBooleanResult = function(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
};
var Throw = function(message) {
  throw new ExtendsResolverError(message);
};
var IsStructuralRight = function(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
};
var StructuralRight = function(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
};
var FromAnyRight = function(left, right) {
  return ExtendsResult.True;
};
var FromAny2 = function(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
};
var FromArrayRight = function(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromArray4 = function(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromAsyncIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromBigInt2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBooleanRight = function(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBoolean2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromConstructor2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromDate2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromFunction2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromIntegerRight = function(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromInteger2 = function(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
};
var FromIntersectRight = function(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIntersect4 = function(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromLiteral3 = function(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
};
var FromNeverRight = function(left, right) {
  return ExtendsResult.False;
};
var FromNever2 = function(left, right) {
  return ExtendsResult.True;
};
var UnwrapTNot = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
};
var FromNot2 = function(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
};
var FromNull2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumberRight = function(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumber2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
};
var IsObjectPropertyCount = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectSymbolLike = function(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBooleanLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBigIntLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectDateLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectUint8ArrayLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectFunctionLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectConstructorLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectArrayLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectPromiseLike = function(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
};
var Property = function(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
};
var FromObjectRight = function(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
};
var FromObject2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
};
var FromPromise2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
};
var RecordKey = function(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
};
var RecordValue = function(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
};
var FromRecordRight = function(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
};
var FromRecord2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
};
var FromRegExp2 = function(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
};
var FromStringRight = function(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromString2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromSymbol2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromTemplateLiteral3 = function(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple = function(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
};
var FromTupleRight = function(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
};
var FromTuple4 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUint8Array2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUndefined2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnionRight = function(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnion6 = function(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnknownRight = function(left, right) {
  return ExtendsResult.True;
};
var FromUnknown2 = function(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoidRight = function(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoid2 = function(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
};
var Visit5 = function(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
};
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs
var FromProperties7 = function(P, Right, True, False, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };
  }, {});
};
var FromMappedResult6 = function(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs
var ExtendsResolve = function(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
};
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey = function(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
};
var FromPropertyKeys = function(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
};
var FromMappedKey2 = function(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
};
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/value/check/check.mjs
var IsAnyOrUnknown = function(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
};
var IsDefined2 = function(value3) {
  return value3 !== undefined;
};
var FromAny3 = function(schema, references, value3) {
  return true;
};
var FromArray5 = function(schema, references, value3) {
  if (!IsArray(value3))
    return false;
  if (IsDefined2(schema.minItems) && !(value3.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit6(schema.items, references, value4))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4) => Visit6(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator3 = function(schema, references, value3) {
  return IsAsyncIterator(value3);
};
var FromBigInt3 = function(schema, references, value3) {
  if (!IsBigInt(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean3 = function(schema, references, value3) {
  return IsBoolean(value3);
};
var FromConstructor3 = function(schema, references, value3) {
  return Visit6(schema.returns, references, value3.prototype);
};
var FromDate3 = function(schema, references, value3) {
  if (!IsDate(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction3 = function(schema, references, value3) {
  return IsFunction(value3);
};
var FromInteger3 = function(schema, references, value3) {
  if (!IsInteger(value3)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect5 = function(schema, references, value3) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value3));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value3[key]));
    return check1 && check2;
  } else {
    return check1;
  }
};
var FromIterator3 = function(schema, references, value3) {
  return IsIterator(value3);
};
var FromLiteral4 = function(schema, references, value3) {
  return value3 === schema.const;
};
var FromNever3 = function(schema, references, value3) {
  return false;
};
var FromNot3 = function(schema, references, value3) {
  return !Visit6(schema.not, references, value3);
};
var FromNull3 = function(schema, references, value3) {
  return IsNull(value3);
};
var FromNumber3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey) && !Visit6(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
};
var FromPromise3 = function(schema, references, value3) {
  return IsPromise(value3);
};
var FromRecord3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value4) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value4) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
};
var FromRef2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromRegExp3 = function(schema, references, value3) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  return regex.test(value3);
};
var FromString3 = function(schema, references, value3) {
  if (!IsString(value3)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value3);
  }
  return true;
};
var FromSymbol3 = function(schema, references, value3) {
  return IsSymbol(value3);
};
var FromTemplateLiteral4 = function(schema, references, value3) {
  return IsString(value3) && new RegExp(schema.pattern).test(value3);
};
var FromThis2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromTuple5 = function(schema, references, value3) {
  if (!IsArray(value3)) {
    return false;
  }
  if (schema.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value3[i]))
      return false;
  }
  return true;
};
var FromUndefined3 = function(schema, references, value3) {
  return IsUndefined(value3);
};
var FromUnion7 = function(schema, references, value3) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value3));
};
var FromUint8Array3 = function(schema, references, value3) {
  if (!IsUint8Array(value3)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown3 = function(schema, references, value3) {
  return true;
};
var FromVoid3 = function(schema, references, value3) {
  return TypeSystemPolicy.IsVoidLike(value3);
};
var FromKind2 = function(schema, references, value3) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value3);
};
var Visit6 = function(schema, references, value3) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value3);
    case "Array":
      return FromArray5(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value3);
    case "BigInt":
      return FromBigInt3(schema_, references_, value3);
    case "Boolean":
      return FromBoolean3(schema_, references_, value3);
    case "Constructor":
      return FromConstructor3(schema_, references_, value3);
    case "Date":
      return FromDate3(schema_, references_, value3);
    case "Function":
      return FromFunction3(schema_, references_, value3);
    case "Integer":
      return FromInteger3(schema_, references_, value3);
    case "Intersect":
      return FromIntersect5(schema_, references_, value3);
    case "Iterator":
      return FromIterator3(schema_, references_, value3);
    case "Literal":
      return FromLiteral4(schema_, references_, value3);
    case "Never":
      return FromNever3(schema_, references_, value3);
    case "Not":
      return FromNot3(schema_, references_, value3);
    case "Null":
      return FromNull3(schema_, references_, value3);
    case "Number":
      return FromNumber3(schema_, references_, value3);
    case "Object":
      return FromObject3(schema_, references_, value3);
    case "Promise":
      return FromPromise3(schema_, references_, value3);
    case "Record":
      return FromRecord3(schema_, references_, value3);
    case "Ref":
      return FromRef2(schema_, references_, value3);
    case "RegExp":
      return FromRegExp3(schema_, references_, value3);
    case "String":
      return FromString3(schema_, references_, value3);
    case "Symbol":
      return FromSymbol3(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value3);
    case "This":
      return FromThis2(schema_, references_, value3);
    case "Tuple":
      return FromTuple5(schema_, references_, value3);
    case "Undefined":
      return FromUndefined3(schema_, references_, value3);
    case "Union":
      return FromUnion7(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value3);
    case "Unknown":
      return FromUnknown3(schema_, references_, value3);
    case "Void":
      return FromVoid3(schema_, references_, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value3);
  }
};
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs
var ObjectType3 = function(value3) {
  const keys = [...Object.getOwnPropertyNames(value3), ...Object.getOwnPropertySymbols(value3)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone2(value3[key]) }), {});
};
var ArrayType3 = function(value3) {
  return value3.map((element) => Clone2(element));
};
var TypedArrayType = function(value3) {
  return value3.slice();
};
var DateType3 = function(value3) {
  return new Date(value3.toISOString());
};
var ValueType = function(value3) {
  return value3;
};
function Clone2(value3) {
  if (IsArray(value3))
    return ArrayType3(value3);
  if (IsDate(value3))
    return DateType3(value3);
  if (IsStandardObject(value3))
    return ObjectType3(value3);
  if (IsTypedArray(value3))
    return TypedArrayType(value3);
  if (IsValueType(value3))
    return ValueType(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/import/value/create/create.mjs
var FromDefault = function(value3) {
  return typeof value3 === "function" ? value3 : Clone2(value3);
};
var FromAny4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromArray6 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
};
var FromConstructor4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = Visit7(schema.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value3)) {
            const self = this;
            self[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
};
var FromInteger4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value3))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
};
var FromIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
};
var FromNull4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
};
var FromNumber4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    return FromDefault(schema.default) || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit7(schema2, references) } : { ...acc };
    }, {});
  }
};
var FromPromise4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
};
var FromRecord4 = function(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit7(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
};
var FromRef3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromRegExp4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString4 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
};
var FromThis3 = function(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromTuple6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
};
var FromUndefined4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromUnion8 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
};
var FromUint8Array4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromVoid4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromKind3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit7 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
};
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs
var ScoreUnion = function(schema, references, value3) {
  if (schema[Kind] === "Object" && typeof value3 === "object" && !IsNull(value3)) {
    const object3 = schema;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object3.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal7 = schema2[Kind] === "Literal" && schema2.const === value3[key] ? max : 0;
      const checks = Check(schema2, references, value3[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal7 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value3) ? 1 : 0;
  }
};
var SelectUnion = function(union9, references, value3) {
  let [select, best] = [union9.anyOf[0], 0];
  for (const schema of union9.anyOf) {
    const score = ScoreUnion(schema, references, value3);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion = function(union9, references, value3) {
  if ("default" in union9) {
    return typeof value3 === "function" ? union9.default : Clone2(union9.default);
  } else {
    const schema = SelectUnion(union9, references, value3);
    return Cast(schema, references, value3);
  }
};
var DefaultClone = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : Create2(schema, references);
};
var Default = function(schema, references, value3) {
  return Check(schema, references, value3) ? value3 : Create2(schema, references);
};
var FromArray7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  const created = IsArray(value3) ? Clone2(value3) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit8(schema.items, references, value4));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value3.prototype[key]);
  }
  return result;
};
var FromIntersect7 = function(schema, references, value3) {
  const created = Create2(schema, references);
  const mapped9 = IsStandardObject(created) && IsStandardObject(value3) ? { ...created, ...value3 } : value3;
  return Check(schema, references, mapped9) ? mapped9 : Create2(schema, references);
};
var FromNever5 = function(schema, references, value3) {
  throw new ValueCastError(schema, "Never types cannot be cast");
};
var FromObject5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value3[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
};
var FromRecord5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
};
var FromRef4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromThis4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromTuple7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (!IsArray(value3))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value3[index]));
};
var FromUnion9 = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : CastUnion(schema, references, value3);
};
var Visit8 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value3);
    case "Constructor":
      return FromConstructor5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect7(schema_, references_, value3);
    case "Never":
      return FromNever5(schema_, references_, value3);
    case "Object":
      return FromObject5(schema_, references_, value3);
    case "Record":
      return FromRecord5(schema_, references_, value3);
    case "Ref":
      return FromRef4(schema_, references_, value3);
    case "This":
      return FromThis4(schema_, references_, value3);
    case "Tuple":
      return FromTuple7(schema_, references_, value3);
    case "Union":
      return FromUnion9(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value3);
    default:
      return Default(schema_, references_, value3);
  }
};
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs
var IsCheckable = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var FromArray8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  return value3.map((value4) => Visit9(schema.items, references, value4));
};
var FromIntersect8 = function(schema, references, value3) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value3)));
  const composite = intersections.reduce((acc, value4) => IsObject(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject(value3) || !IsObject(composite) || !IsSchema(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value3[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite;
};
var FromObject6 = function(schema, references, value3) {
  if (!IsObject(value3) || IsArray(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema.properties) {
      value3[key] = Visit9(schema.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRecord6 = function(schema, references, value3) {
  if (!IsObject(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.keys(value3);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit9(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRef5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromThis5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromTuple8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value3.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value3[i] = Visit9(schema.items[i], references, value3[i]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
};
var FromUnion10 = function(schema, references, value3) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, value3)) {
      return Visit9(inner, references, value3);
    }
  }
  return value3;
};
var Visit9 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect8(schema_, references_, value3);
    case "Object":
      return FromObject6(schema_, references_, value3);
    case "Record":
      return FromRecord6(schema_, references_, value3);
    case "Ref":
      return FromRef5(schema_, references_, value3);
    case "This":
      return FromThis5(schema_, references_, value3);
    case "Tuple":
      return FromTuple8(schema_, references_, value3);
    case "Union":
      return FromUnion10(schema_, references_, value3);
    default:
      return value3;
  }
};
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs
var IsStringNumeric = function(value3) {
  return IsString(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
};
var IsValueToString = function(value3) {
  return IsBigInt(value3) || IsBoolean(value3) || IsNumber(value3);
};
var IsValueTrue = function(value3) {
  return value3 === true || IsNumber(value3) && value3 === 1 || IsBigInt(value3) && value3 === BigInt("1") || IsString(value3) && (value3.toLowerCase() === "true" || value3 === "1");
};
var IsValueFalse = function(value3) {
  return value3 === false || IsNumber(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt(value3) && value3 === BigInt("0") || IsString(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
};
var IsTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsDateTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateString = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
};
var TryConvertLiteralString = function(value3, target) {
  const conversion = TryConvertString(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralNumber = function(value3, target) {
  const conversion = TryConvertNumber(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralBoolean = function(value3, target) {
  const conversion = TryConvertBoolean(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteral = function(schema, value3) {
  return IsString(schema.const) ? TryConvertLiteralString(value3, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value3, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value3, schema.const) : Clone2(value3);
};
var TryConvertBoolean = function(value3) {
  return IsValueTrue(value3) ? true : IsValueFalse(value3) ? false : value3;
};
var TryConvertBigInt = function(value3) {
  return IsStringNumeric(value3) ? BigInt(parseInt(value3)) : IsNumber(value3) ? BigInt(value3 | 0) : IsValueFalse(value3) ? BigInt(0) : IsValueTrue(value3) ? BigInt(1) : value3;
};
var TryConvertString = function(value3) {
  return IsValueToString(value3) ? value3.toString() : IsSymbol(value3) && value3.description !== undefined ? value3.description.toString() : value3;
};
var TryConvertNumber = function(value3) {
  return IsStringNumeric(value3) ? parseFloat(value3) : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertInteger = function(value3) {
  return IsStringNumeric(value3) ? parseInt(value3) : IsNumber(value3) ? value3 | 0 : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertNull = function(value3) {
  return IsString(value3) && value3.toLowerCase() === "null" ? null : value3;
};
var TryConvertUndefined = function(value3) {
  return IsString(value3) && value3 === "undefined" ? undefined : value3;
};
var TryConvertDate = function(value3) {
  return IsDate(value3) ? value3 : IsNumber(value3) ? new Date(value3) : IsValueTrue(value3) ? new Date(1) : IsValueFalse(value3) ? new Date(0) : IsStringNumeric(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone(value3) ? new Date(value3) : IsDateString(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
};
var Default2 = function(value3) {
  return value3;
};
var FromArray9 = function(schema, references, value3) {
  const elements = IsArray(value3) ? value3 : [value3];
  return elements.map((element) => Visit10(schema.items, references, element));
};
var FromBigInt5 = function(schema, references, value3) {
  return TryConvertBigInt(value3);
};
var FromBoolean5 = function(schema, references, value3) {
  return TryConvertBoolean(value3);
};
var FromDate5 = function(schema, references, value3) {
  return TryConvertDate(value3);
};
var FromInteger5 = function(schema, references, value3) {
  return TryConvertInteger(value3);
};
var FromIntersect9 = function(schema, references, value3) {
  return schema.allOf.reduce((value4, schema2) => Visit10(schema2, references, value4), value3);
};
var FromLiteral6 = function(schema, references, value3) {
  return TryConvertLiteral(schema, value3);
};
var FromNull5 = function(schema, references, value3) {
  return TryConvertNull(value3);
};
var FromNumber5 = function(schema, references, value3) {
  return TryConvertNumber(value3);
};
var FromObject7 = function(schema, references, value3) {
  const isConvertable = IsObject(value3);
  if (!isConvertable)
    return value3;
  return Object.getOwnPropertyNames(schema.properties).reduce((value4, key) => {
    return !IsUndefined(value4[key]) ? { ...value4, [key]: Visit10(schema.properties[key], references, value4[key]) } : { ...value4 };
  }, value3);
};
var FromRecord7 = function(schema, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
};
var FromRef6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromString5 = function(schema, references, value3) {
  return TryConvertString(value3);
};
var FromSymbol5 = function(schema, references, value3) {
  return IsString(value3) || IsNumber(value3) ? Symbol(value3) : value3;
};
var FromThis6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromTuple9 = function(schema, references, value3) {
  const isConvertable = IsArray(value3) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value4) : value4;
  });
};
var FromUndefined5 = function(schema, references, value3) {
  return TryConvertUndefined(value3);
};
var FromUnion11 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value3);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value3;
};
var Visit10 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value3);
    case "BigInt":
      return FromBigInt5(schema_, references_, value3);
    case "Boolean":
      return FromBoolean5(schema_, references_, value3);
    case "Date":
      return FromDate5(schema_, references_, value3);
    case "Integer":
      return FromInteger5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect9(schema_, references_, value3);
    case "Literal":
      return FromLiteral6(schema_, references_, value3);
    case "Null":
      return FromNull5(schema_, references_, value3);
    case "Number":
      return FromNumber5(schema_, references_, value3);
    case "Object":
      return FromObject7(schema_, references_, value3);
    case "Record":
      return FromRecord7(schema_, references_, value3);
    case "Ref":
      return FromRef6(schema_, references_, value3);
    case "String":
      return FromString5(schema_, references_, value3);
    case "Symbol":
      return FromSymbol5(schema_, references_, value3);
    case "This":
      return FromThis6(schema_, references_, value3);
    case "Tuple":
      return FromTuple9(schema_, references_, value3);
    case "Undefined":
      return FromUndefined5(schema_, references_, value3);
    case "Union":
      return FromUnion11(schema_, references_, value3);
    default:
      return Default2(value3);
  }
};
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/default/default.mjs
var ValueOrDefault = function(schema, value3) {
  return value3 === undefined && "default" in schema ? Clone2(schema.default) : value3;
};
var IsCheckable2 = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var IsDefaultSchema = function(value3) {
  return IsSchema(value3) && "default" in value3;
};
var FromArray10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromIntersect10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value3));
};
var FromThis7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, value3);
};
var FromTuple10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion12 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit11 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect10(schema_, references_, value3);
    case "Object":
      return FromObject8(schema_, references_, value3);
    case "Record":
      return FromRecord8(schema_, references_, value3);
    case "Ref":
      return FromRef7(schema_, references_, value3);
    case "This":
      return FromThis7(schema_, references_, value3);
    case "Tuple":
      return FromTuple10(schema_, references_, value3);
    case "Union":
      return FromUnion12(schema_, references_, value3);
    default:
      return ValueOrDefault(schema_, value3);
  }
};
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError;
    }
  },
  Set: () => {
    {
      return Set4;
    }
  },
  Has: () => {
    {
      return Has3;
    }
  },
  Get: () => {
    {
      return Get3;
    }
  },
  Format: () => {
    {
      return Format;
    }
  },
  Delete: () => {
    {
      return Delete3;
    }
  }
});
var Escape2 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value3, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value3, pointer, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value3, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value3, pointer);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value3, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value3, pointer) {
  if (pointer === "")
    return value3;
  let current = value3;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  value;
  path;
  update;
  constructor(value3, path, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  value;
  path;
  constructor(value3, path) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs
var CreateUpdate = function(path, value3) {
  return { type: "update", path, value: value3 };
};
var CreateInsert = function(path, value3) {
  return { type: "insert", path, value: value3 };
};
var CreateDelete = function(path) {
  return { type: "delete", path };
};
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
var IsRootUpdate = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity = function(edits) {
  return edits.length === 0;
};
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  value;
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  value;
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs
var ObjectType5 = function(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
};
var DateType4 = function(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
};
var ArrayType5 = function(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var TypedArrayType3 = function(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var ValueType3 = function(left, right) {
  return left === right;
};
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs
var ObjectType6 = function(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType6 = function(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType4 = function(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
};
var ValueType4 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
};
var Visit13 = function(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
};
var IsNonMutableValue = function(value3) {
  return IsTypedArray(value3) || IsValueType(value3);
};
var IsMismatchedValue = function(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
};
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs
var Default4 = function(schema, path, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value3) : value3;
  } catch (error19) {
    throw new TransformDecodeError(schema, path, value3, error19);
  }
};
var FromArray11 = function(schema, references, path, value3) {
  return IsArray(value3) ? Default4(schema, path, value3.map((value4, index) => Visit14(schema.items, references, `${path}/${index}`, value4))) : Default4(schema, path, value3);
};
var FromIntersect11 = function(schema, references, path, value3) {
  if (!IsStandardObject(value3) || IsValueType(value3))
    return Default4(schema, path, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(Index(schema, [key]), references, `${path}/${key}`, value4[key]) } : value4;
  }, value3);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(unevaluatedProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, path, unknownProperties);
};
var FromNot5 = function(schema, references, path, value3) {
  return Default4(schema, path, Visit14(schema.not, references, path, value3));
};
var FromObject9 = function(schema, references, path, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, path, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(schema.properties[key], references, `${path}/${key}`, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, path, unknownProperties);
};
var FromRecord9 = function(schema, references, path, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, path, value3);
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit14(schema.patternProperties[pattern3], references, `${path}/${key}`, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default4(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, path, unknownProperties);
};
var FromRef8 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value3));
};
var FromThis8 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value3));
};
var FromTuple11 = function(schema, references, path, value3) {
  return IsArray(value3) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value3[index]))) : Default4(schema, path, value3);
};
var FromUnion13 = function(schema, references, path, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const decoded = Visit14(subschema, references, path, value3);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value3);
};
var Visit14 = function(schema, references, path, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value3);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value3);
    case "Not":
      return FromNot5(schema_, references_, path, value3);
    case "Object":
      return FromObject9(schema_, references_, path, value3);
    case "Record":
      return FromRecord9(schema_, references_, path, value3);
    case "Ref":
      return FromRef8(schema_, references_, path, value3);
    case "Symbol":
      return Default4(schema_, path, value3);
    case "This":
      return FromThis8(schema_, references_, path, value3);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value3);
    case "Union":
      return FromUnion13(schema_, references_, path, value3);
    default:
      return Default4(schema_, path, value3);
  }
};
function TransformDecode(schema, references, value3) {
  return Visit14(schema, references, "", value3);
}

class TransformDecodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error19) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value3;
    this.error = error19;
  }
}

class TransformDecodeError extends TypeBoxError {
  schema;
  path;
  value;
  error;
  constructor(schema, path, value3, error19) {
    super(error19 instanceof Error ? error19.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value3;
    this.error = error19;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs
var Default5 = function(schema, path, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value3) : value3;
  } catch (error20) {
    throw new TransformEncodeError(schema, path, value3, error20);
  }
};
var FromArray12 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  return IsArray(defaulted) ? defaulted.map((value4, index) => Visit15(schema.items, references, `${path}/${index}`, value4)) : defaulted;
};
var FromIntersect12 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3) || IsValueType(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in defaulted ? { ...value4, [key]: Visit15(Index(schema, [key]), references, `${path}/${key}`, value4[key]) } : value4;
  }, defaulted);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(unevaluatedProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
};
var FromNot6 = function(schema, references, path, value3) {
  return Default5(schema.not, path, Default5(schema, path, value3));
};
var FromObject10 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit15(schema.properties[key], references, `${path}/${key}`, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
};
var FromRecord10 = function(schema, references, path, value3) {
  const defaulted = Default5(schema, path, value3);
  if (!IsStandardObject(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit15(schema.patternProperties[pattern3], references, `${path}/${key}`, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default5(additionalProperties, `${path}/${key}`, value4[key]) } : value4;
  }, knownProperties);
};
var FromRef9 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value3);
  return Default5(schema, path, resolved);
};
var FromThis9 = function(schema, references, path, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value3);
  return Default5(schema, path, resolved);
};
var FromTuple12 = function(schema, references, path, value3) {
  const value1 = Default5(schema, path, value3);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
};
var FromUnion14 = function(schema, references, path, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const value1 = Visit15(subschema, references, path, value3);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value3);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value3);
};
var Visit15 = function(schema, references, path, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value3);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value3);
    case "Not":
      return FromNot6(schema_, references_, path, value3);
    case "Object":
      return FromObject10(schema_, references_, path, value3);
    case "Record":
      return FromRecord10(schema_, references_, path, value3);
    case "Ref":
      return FromRef9(schema_, references_, path, value3);
    case "This":
      return FromThis9(schema_, references_, path, value3);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value3);
    case "Union":
      return FromUnion14(schema_, references_, path, value3);
    default:
      return Default5(schema_, path, value3);
  }
};
function TransformEncode(schema, references, value3) {
  return Visit15(schema, references, "", value3);
}

class TransformEncodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error20) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value3;
    this.error = error20;
  }
}

class TransformEncodeError extends TypeBoxError {
  schema;
  path;
  value;
  error;
  constructor(schema, path, value3, error20) {
    super(`${error20 instanceof Error ? error20.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value3;
    this.error = error20;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/has.mjs
var FromArray13 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromAsyncIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromConstructor6 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromFunction5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromIntersect13 = function(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
};
var FromIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromNot7 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.not, references);
};
var FromObject11 = function(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
};
var FromPromise5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.item, references);
};
var FromRecord11 = function(schema, references) {
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern3];
  return IsTransform(schema) || Visit16(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
};
var FromRef10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromThis10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromTuple13 = function(schema, references) {
  return IsTransform(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
};
var FromUnion15 = function(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
};
var Visit16 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
};
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// node_modules/@sinclair/typebox/build/import/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => {
    {
      return Patch2;
    }
  },
  Mutate: () => {
    {
      return Mutate2;
    }
  },
  Hash: () => {
    {
      return Hash2;
    }
  },
  Errors: () => {
    {
      return Errors2;
    }
  },
  Equal: () => {
    {
      return Equal2;
    }
  },
  Encode: () => {
    {
      return Encode;
    }
  },
  Diff: () => {
    {
      return Diff2;
    }
  },
  Default: () => {
    {
      return Default6;
    }
  },
  Decode: () => {
    {
      return Decode;
    }
  },
  Create: () => {
    {
      return Create3;
    }
  },
  Convert: () => {
    {
      return Convert2;
    }
  },
  Clone: () => {
    {
      return Clone3;
    }
  },
  Clean: () => {
    {
      return Clean2;
    }
  },
  Check: () => {
    {
      return Check2;
    }
  },
  Cast: () => {
    {
      return Cast2;
    }
  }
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value3) {
  return Clone2(value3);
}
function Decode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value3))
    throw new TransformDecodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return TransformDecode(schema, references, value3);
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = TransformEncode(schema, references, value3);
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value3) {
  return Hash(value3);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
var FromRest4 = function(T) {
  return T.map((L) => AwaitedResolve(L));
};
var FromIntersect14 = function(T) {
  return Intersect(FromRest4(T));
};
var FromUnion16 = function(T) {
  return Union(FromRest4(T));
};
var FromPromise6 = function(T) {
  return AwaitedResolve(T);
};
var AwaitedResolve = function(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
};
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
var CompositeKeys = function(T) {
  return SetDistinct(T.reduce((Acc, L) => {
    return [...Acc, ...KeyOfPropertyKeys(L)];
  }, []));
};
var FilterNever = function(T) {
  return T.filter((L) => !IsNever(L));
};
var CompositeProperty = function(T, K) {
  return FilterNever(T.reduce((Acc, L) => {
    return [...Acc, ...IndexFromPropertyKeys(L, [K])];
  }, []));
};
var CompositeProperties = function(T, K) {
  return K.reduce((Acc, L) => {
    return { ...Acc, [L]: IntersectEvaluated(CompositeProperty(T, L)) };
  }, {});
};
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/import/type/const/const.mjs
var FromArray14 = function(T) {
  return T.map((L) => FromValue(L, false));
};
var FromProperties8 = function(value5) {
  return globalThis.Object.getOwnPropertyNames(value5).reduce((acc, key) => {
    return { ...acc, [key]: Readonly(FromValue(value5[key], false)) };
  }, {});
};
var ConditionalReadonly = function(T, root) {
  return root === true ? T : Readonly(T);
};
var FromValue = function(value5, root) {
  return IsAsyncIterator2(value5) ? ConditionalReadonly(Any(), root) : IsIterator2(value5) ? ConditionalReadonly(Any(), root) : IsArray2(value5) ? Readonly(Tuple(FromArray14(value5))) : IsUint8Array2(value5) ? Uint8Array2() : IsDate2(value5) ? Date2() : IsObject2(value5) ? ConditionalReadonly(Object2(FromProperties8(value5)), root) : IsFunction2(value5) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value5) ? Undefined() : IsNull2(value5) ? Null() : IsSymbol2(value5) ? Symbol2() : IsBigInt2(value5) ? BigInt2() : IsNumber2(value5) ? Literal(value5) : IsBoolean2(value5) ? Literal(value5) : IsString2(value5) ? Literal(value5) : Object2({});
};
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
var FromRest5 = function(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
};
var FromProperties9 = function(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref2(properties[key], references) };
  }, {});
};
var FromConstructor7 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromFunction6 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromIntersect15 = function(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
};
var FromUnion17 = function(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
};
var FromTuple14 = function(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
};
var FromArray15 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromObject12 = function(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
};
var FromPromise7 = function(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
};
var FromAsyncIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromRef11 = function(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard8 = Discard(target, ["$id"]);
  return Deref2(discard8, references);
};
var DerefResolve = function(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
};
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value7) => Literal(value7));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
var ExcludeRest = function(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
};
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
var FromProperties10 = function(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude(P[K2], U) };
  }, {});
};
var FromMappedResult7 = function(R, T) {
  return FromProperties10(R.properties, T);
};
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
var ExtractRest = function(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
};
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
var FromProperties11 = function(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract(P[K2], T) };
  }, {});
};
var FromMappedResult8 = function(R, T) {
  return FromProperties11(R.properties, T);
};
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey = function(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
};
var MappedIntrinsicPropertyKeys = function(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
};
var MappedIntrinsicProperties = function(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
};
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize = function(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toLowerCase(), rest].join("");
};
var ApplyCapitalize = function(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toUpperCase(), rest].join("");
};
var ApplyUppercase = function(value7) {
  return value7.toUpperCase();
};
var ApplyLowercase = function(value7) {
  return value7.toLowerCase();
};
var FromTemplateLiteral6 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite3)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value7) => Literal(value7));
  const mapped12 = FromRest6(literals, mode);
  const union15 = Union(mapped12);
  return TemplateLiteral([union15], options);
};
var FromLiteralValue = function(value7, mode) {
  return typeof value7 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value7) : mode === "Capitalize" ? ApplyCapitalize(value7) : mode === "Uppercase" ? ApplyUppercase(value7) : mode === "Lowercase" ? ApplyLowercase(value7) : value7 : value7.toString();
};
var FromRest6 = function(T, M) {
  return T.map((L) => Intrinsic(L, M));
};
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
var FromProperties12 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit(P[K2], K, options) };
  }, {});
};
var FromMappedResult9 = function(R, K, options) {
  return FromProperties12(R.properties, K, options);
};
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
var FromIntersect16 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromUnion18 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromProperty2 = function(T, K) {
  const { [K]: _, ...R } = T;
  return R;
};
var FromProperties13 = function(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty2(T2, K2);
  }, T);
};
var OmitResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
};
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey2 = function(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
};
var FromPropertyKeys2 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
};
var FromMappedKey3 = function(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
};
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
var FromRest7 = function(T) {
  return T.map((L) => PartialResolve(L));
};
var FromProperties14 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional(T[K]) };
  }, {});
};
var PartialResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
};
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
var FromProperties15 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial(K[K2], options) };
  }, {});
};
var FromMappedResult10 = function(R, options) {
  return FromProperties15(R.properties, options);
};
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
var FromProperties16 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick(P[K2], K, options) };
  }, {});
};
var FromMappedResult11 = function(R, K, options) {
  return FromProperties16(R.properties, K, options);
};
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
var FromIntersect17 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromUnion19 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromProperties17 = function(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
};
var PickResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
};
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey3 = function(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
};
var FromPropertyKeys3 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
};
var FromMappedKey4 = function(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
};
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/import/type/record/record.mjs
var RecordCreateFromPattern = function(pattern3, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType(T) }
  };
};
var RecordCreateFromKeys = function(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType(T) }), {});
  return Object2(P, { ...options, [Hint]: "Record" });
};
var FromTemplateLiteralKey = function(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
};
var FromUnionKey = function(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
};
var FromLiteralKey = function(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
};
var FromRegExpKey = function(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
};
var FromStringKey = function(K, T, options) {
  const pattern3 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern3, T, options);
};
var FromIntegerKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
var FromNumberKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/import/type/required/required.mjs
var FromRest8 = function(T) {
  return T.map((L) => RequiredResolve(L));
};
var FromProperties18 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };
  }, {});
};
var RequiredResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
};
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
var FromProperties19 = function(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required(P[K2], options) };
  }, {});
};
var FromMappedResult12 = function(R, options) {
  return FromProperties19(R.properties, options);
};
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
var RestResolve = function(T) {
  return IsIntersect(T) ? [...T.allOf] : IsUnion(T) ? [...T.anyOf] : IsTuple(T) ? [...T.items ?? []] : [];
};
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}

class TransformDecodeBuilder {
  schema;
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  schema;
  decode;
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value11) => schema2[TransformKind].Encode(encode2(value11));
    const Decode2 = (value11) => this.decode(schema2[TransformKind].Decode(value11));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
// node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => {
    {
      return Void;
    }
  },
  Uppercase: () => {
    {
      return Uppercase;
    }
  },
  Unsafe: () => {
    {
      return Unsafe;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Union: () => {
    {
      return Union;
    }
  },
  Undefined: () => {
    {
      return Undefined;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array2;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  Transform: () => {
    {
      return Transform;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral;
    }
  },
  Symbol: () => {
    {
      return Symbol2;
    }
  },
  String: () => {
    {
      return String2;
    }
  },
  Strict: () => {
    {
      return Strict;
    }
  },
  ReturnType: () => {
    {
      return ReturnType;
    }
  },
  Rest: () => {
    {
      return Rest;
    }
  },
  Required: () => {
    {
      return Required;
    }
  },
  RegExp: () => {
    {
      return RegExp2;
    }
  },
  Ref: () => {
    {
      return Ref;
    }
  },
  Recursive: () => {
    {
      return Recursive;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional;
    }
  },
  Readonly: () => {
    {
      return Readonly;
    }
  },
  Promise: () => {
    {
      return Promise2;
    }
  },
  Pick: () => {
    {
      return Pick;
    }
  },
  Partial: () => {
    {
      return Partial;
    }
  },
  Parameters: () => {
    {
      return Parameters;
    }
  },
  Optional: () => {
    {
      return Optional;
    }
  },
  Omit: () => {
    {
      return Omit;
    }
  },
  Object: () => {
    {
      return Object2;
    }
  },
  Number: () => {
    {
      return Number2;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  Not: () => {
    {
      return Not2;
    }
  },
  Never: () => {
    {
      return Never;
    }
  },
  Mapped: () => {
    {
      return Mapped;
    }
  },
  Lowercase: () => {
    {
      return Lowercase;
    }
  },
  Literal: () => {
    {
      return Literal;
    }
  },
  KeyOf: () => {
    {
      return KeyOf;
    }
  },
  Iterator: () => {
    {
      return Iterator;
    }
  },
  Intersect: () => {
    {
      return Intersect;
    }
  },
  Integer: () => {
    {
      return Integer;
    }
  },
  InstanceType: () => {
    {
      return InstanceType;
    }
  },
  Index: () => {
    {
      return Index;
    }
  },
  Function: () => {
    {
      return Function2;
    }
  },
  Extract: () => {
    {
      return Extract;
    }
  },
  Extends: () => {
    {
      return Extends;
    }
  },
  Exclude: () => {
    {
      return Exclude;
    }
  },
  Enum: () => {
    {
      return Enum;
    }
  },
  Deref: () => {
    {
      return Deref2;
    }
  },
  Date: () => {
    {
      return Date2;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters;
    }
  },
  Constructor: () => {
    {
      return Constructor;
    }
  },
  Const: () => {
    {
      return Const;
    }
  },
  Composite: () => {
    {
      return Composite;
    }
  },
  Capitalize: () => {
    {
      return Capitalize;
    }
  },
  Boolean: () => {
    {
      return Boolean;
    }
  },
  BigInt: () => {
    {
      return BigInt2;
    }
  },
  Awaited: () => {
    {
      return Awaited;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator;
    }
  },
  Array: () => {
    {
      return Array2;
    }
  },
  Any: () => {
    {
      return Any;
    }
  }
});

// node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs
class TypeCheck {
  schema;
  references;
  checkFunc;
  code;
  hasTransform;
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value11) {
    return Errors(this.schema, this.references, value11);
  }
  Check(value11) {
    return this.checkFunc(value11);
  }
  Decode(value11) {
    if (!this.checkFunc(value11))
      throw new TransformDecodeCheckError(this.schema, value11, this.Errors(value11).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value11) : value11;
  }
  Encode(value11) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value11) : value11;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value11, this.Errors(value11).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value11) {
    if (value11.length === 0)
      return false;
    return Character.IsNumeric(value11.charCodeAt(0));
  }
  function IsAccessor(value11) {
    if (IsFirstCharacterNumeric(value11))
      return false;
    for (let i = 0;i < value11.length; i++) {
      const code = value11.charCodeAt(i);
      const check11 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check11)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object13, key) {
    return IsAccessor(key) ? `${object13}.${key}` : `${object13}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  schema;
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value11, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value11} ? ${expression} : true)` : `(${MemberExpression.Encode(value11, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}))` : `(typeof ${value11} === 'object' && ${value11} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}) && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))` : `(typeof ${value11} === 'object' && ${value11} !== null && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value11) {
    return !TypeSystemPolicy.AllowNaN ? `(typeof ${value11} === 'number' && Number.isFinite(${value11}))` : `typeof ${value11} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value11) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value11} === undefined || ${value11} === null)` : `${value11} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value11) {
    yield "true";
  }
  function* FromArray16(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value11}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value11}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value11}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check11 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check11}})(${value11})`;
    }
    if (schema3.uniqueItems === true) {
      const check11 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check11} }`;
      yield `((${parameter}) => { ${block} )(${value11})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value11})`;
  }
  function* FromBigInt6(schema3, references, value11) {
    yield `(typeof ${value11} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value11} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value11} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value11} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value11} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value11} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value11) {
    yield `(typeof ${value11} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value11) {
    yield* Visit17(schema3.returns, references, `${value11}.prototype`);
  }
  function* FromDate6(schema3, references, value11) {
    yield `(${value11} instanceof Date) && Number.isFinite(${value11}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value11}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value11}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value11}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value11}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value11}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value11) {
    yield `(typeof ${value11} === 'function')`;
  }
  function* FromInteger6(schema3, references, value11) {
    yield `(typeof ${value11} === 'number' && Number.isInteger(${value11}))`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value11) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value11)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value11}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value11})`;
  }
  function* FromLiteral7(schema3, references, value11) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value11} === ${schema3.const})`;
    } else {
      yield `(${value11} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value11) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value11) {
    const expression = CreateExpression(schema3.not, references, value11);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value11) {
    yield `(${value11} === null)`;
  }
  function* FromNumber6(schema3, references, value11) {
    yield Policy.IsNumberLike(value11);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value11) {
    yield Policy.IsObjectLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value11, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value11})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value11, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value11}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value11}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value11) {
    yield `(typeof value === 'object' && typeof ${value11}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value11) {
    yield Policy.IsRecordLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value11) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value11}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value11) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
    yield* Visit17(target, references, value11);
  }
  function* FromRegExp5(schema3, references, value11) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value11})`;
  }
  function* FromString6(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value11})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value11})`;
    }
  }
  function* FromSymbol6(schema3, references, value11) {
    yield `(typeof ${value11} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value11})`;
  }
  function* FromThis11(schema3, references, value11) {
    yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
  }
  function* FromTuple15(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    if (schema3.items === undefined)
      return yield `${value11}.length === 0`;
    yield `(${value11}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value11}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value11) {
    yield `${value11} === undefined`;
  }
  function* FromUnion20(schema3, references, value11) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value11));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value11) {
    yield `${value11} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value11}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value11}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value11) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value11) {
    yield Policy.IsVoidLike(value11);
  }
  function* FromKind4(schema3, references, value11) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value11})`;
  }
  function* Visit17(schema3, references, value11, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value11})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value11})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value11);
      case "Array":
        return yield* FromArray16(schema_, references_, value11);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value11);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value11);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value11);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value11);
      case "Date":
        return yield* FromDate6(schema_, references_, value11);
      case "Function":
        return yield* FromFunction7(schema_, references_, value11);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value11);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value11);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value11);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value11);
      case "Never":
        return yield* FromNever6(schema_, references_, value11);
      case "Not":
        return yield* FromNot8(schema_, references_, value11);
      case "Null":
        return yield* FromNull6(schema_, references_, value11);
      case "Number":
        return yield* FromNumber6(schema_, references_, value11);
      case "Object":
        return yield* FromObject13(schema_, references_, value11);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value11);
      case "Record":
        return yield* FromRecord12(schema_, references_, value11);
      case "Ref":
        return yield* FromRef12(schema_, references_, value11);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value11);
      case "String":
        return yield* FromString6(schema_, references_, value11);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value11);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value11);
      case "This":
        return yield* FromThis11(schema_, references_, value11);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value11);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value11);
      case "Union":
        return yield* FromUnion20(schema_, references_, value11);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value11);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value11);
      case "Void":
        return yield* FromVoid5(schema_, references_, value11);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value11);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value11, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value11, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value11, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value11, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type74) {
    const annotation = state.language === "typescript" ? `: ${type74}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type74) {
    return state.language === "typescript" ? `: ${type74}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value11) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value11);
    }
    function formatRegistryFunction(format, value11) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value11);
    }
    function hashFunction(value11) {
      return Hash(value11);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/index.mjs
var import_cookie = __toESM(require_cookie(), 1);
var import_cookie2 = __toESM(require_cookie(), 1);
var import_fast_decode_uri_component = __toESM(require_fast_decode_uri_component(), 1);
var removeTrailingEquals = function(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("=")) {
    trimmedDigest = trimmedDigest.slice(0, -1);
  }
  return trimmedDigest;
};
var import_fast_querystring = __toESM(require_lib(), 1);
var import_fast_decode_uri_component2 = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_querystring2 = __toESM(require_lib(), 1);
var isLeapYear = function(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
var date5 = function(str) {
  const matches = DATE.exec(str);
  if (!matches)
    return false;
  const year = +matches[1];
  const month = +matches[2];
  const day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
};
var getTime = function(strictTimeZone) {
  return function time(str) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hr = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tz = matches[4];
    const tzSign = matches[5] === "-" ? -1 : 1;
    const tzH = +(matches[6] || 0);
    const tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    const utcMin = min - tzM * tzSign;
    const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
};
var getDateTime = function(strictTimeZone) {
  const time = getTime(strictTimeZone);
  return function date_time(str) {
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date5(dateTime[0]) && time(dateTime[1]);
  };
};
var uri = function(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
};
var byte = function(str) {
  BYTE.lastIndex = 0;
  return BYTE.test(str);
};
var validateInt32 = function(value15) {
  return Number.isInteger(value15) && value15 <= MAX_INT32 && value15 >= MIN_INT32;
};
var validateInt64 = function(value15) {
  return Number.isInteger(value15);
};
var validateNumber = function() {
  return true;
};
var regex = function(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    new RegExp(str);
    return true;
  } catch (e2) {
    return false;
  }
};
var e = (e2, t3) => ({ part: e2, store: null, inert: t3 !== undefined ? new Map(t3.map((e3) => [e3.part.charCodeAt(0), e3])) : null, params: null, wildcardStore: null });
var t = (e2, t3) => ({ ...e2, part: t3 });
var r = (e2) => ({ paramName: e2, store: null, inert: null });
var Memoirist = class _Memoirist {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add(a2, l, i) {
    let s;
    if (typeof l != "string")
      throw TypeError("Route path must be a string");
    l === "" ? l = "/" : l[0] !== "/" && (l = `/${l}`), this.history.push([a2, l, i]);
    let n = l[l.length - 1] === "*";
    n && (l = l.slice(0, -1));
    let o = l.split(_Memoirist.regex.static), u = l.match(_Memoirist.regex.params) || [];
    o[o.length - 1] === "" && o.pop(), s = this.root[a2] ? this.root[a2] : this.root[a2] = e("/");
    let p = 0;
    for (let a3 = 0;a3 < o.length; ++a3) {
      let i2 = o[a3];
      if (a3 > 0) {
        let t3 = u[p++].slice(1);
        if (s.params === null)
          s.params = r(t3);
        else if (s.params.paramName !== t3)
          throw Error(`Cannot create route "${l}" with parameter "${t3}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
        let a4 = s.params;
        if (a4.inert === null) {
          s = a4.inert = e(i2);
          continue;
        }
        s = a4.inert;
      }
      for (let r2 = 0;; ) {
        if (r2 === i2.length) {
          if (r2 < s.part.length) {
            let a4 = t(s, s.part.slice(r2));
            Object.assign(s, e(i2, [a4]));
          }
          break;
        }
        if (r2 === s.part.length) {
          if (s.inert === null)
            s.inert = new Map;
          else if (s.inert.has(i2.charCodeAt(r2))) {
            s = s.inert.get(i2.charCodeAt(r2)), i2 = i2.slice(r2), r2 = 0;
            continue;
          }
          let t3 = e(i2.slice(r2));
          s.inert.set(i2.charCodeAt(r2), t3), s = t3;
          break;
        }
        if (i2[r2] !== s.part[r2]) {
          let a4 = t(s, s.part.slice(r2)), l2 = e(i2.slice(r2));
          Object.assign(s, e(s.part.slice(0, r2), [a4, l2])), s = l2;
          break;
        }
        ++r2;
      }
    }
    if (p < u.length) {
      let e2 = u[p], t3 = e2.slice(1);
      if (s.params === null)
        s.params = r(t3);
      else if (s.params.paramName !== t3)
        throw Error(`Cannot create route "${l}" with parameter "${t3}" because a route already exists with a different parameter name ("${s.params.paramName}") in the same location`);
      return s.params.store === null && (s.params.store = i), s.params.store;
    }
    return n ? (s.wildcardStore === null && (s.wildcardStore = i), s.wildcardStore) : (s.store === null && (s.store = i), s.store);
  }
  find(e2, t3) {
    let r2 = this.root[e2];
    return r2 ? a(t3, t3.length, r2, 0) : null;
  }
};
var a = (e2, t3, r2, l) => {
  let i = r2?.part, s = l + i.length;
  if (i.length > 1) {
    if (s > t3)
      return null;
    if (i.length < 15) {
      for (let t4 = 1, r3 = l + 1;t4 < i.length; ++t4, ++r3)
        if (i.charCodeAt(t4) !== e2.charCodeAt(r3))
          return null;
    } else if (e2.substring(l, s) !== i)
      return null;
  }
  if (s === t3)
    return r2.store !== null ? { store: r2.store, params: {} } : r2.wildcardStore !== null ? { store: r2.wildcardStore, params: { "*": "" } } : null;
  if (r2.inert !== null) {
    let l2 = r2.inert.get(e2.charCodeAt(s));
    if (l2 !== undefined) {
      let r3 = a(e2, t3, l2, s);
      if (r3 !== null)
        return r3;
    }
  }
  if (r2.params !== null) {
    let l2 = r2.params, i2 = e2.indexOf("/", s);
    if (i2 !== s) {
      if (i2 === -1 || i2 >= t3) {
        if (l2.store !== null) {
          let r3 = {};
          return r3[l2.paramName] = e2.substring(s, t3), { store: l2.store, params: r3 };
        }
      } else if (l2.inert !== null) {
        let r3 = a(e2, t3, l2.inert, i2);
        if (r3 !== null)
          return r3.params[l2.paramName] = e2.substring(s, i2), r3;
      }
    }
  }
  return r2.wildcardStore !== null ? { store: r2.wildcardStore, params: { "*": e2.substring(s, t3) } } : null;
};
var resolver = () => {
  let resolve;
  const promise5 = new Promise((r2) => {
    resolve = r2;
  });
  return [promise5, resolve];
};
var createSignal = () => {
  const [start, resolveStart] = resolver();
  const [end, resolveEnd] = resolver();
  const children = [];
  const resolvers = [];
  return {
    signal: start,
    consume: (trace) => {
      switch (trace.type) {
        case "begin":
          if (trace.unit && children.length === 0)
            for (let i = 0;i < trace.unit; i++) {
              const [start2, resolveStart2] = resolver();
              const [end2, resolveEnd2] = resolver();
              children.push(start2);
              resolvers.push([
                (trace2) => {
                  resolveStart2({
                    children: [],
                    end: end2,
                    name: trace2.name ?? "",
                    skip: false,
                    time: trace2.time
                  });
                },
                (time) => {
                  resolveEnd2(time);
                }
              ]);
            }
          resolveStart({
            children,
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          resolveEnd(trace.time);
          break;
      }
    },
    consumeChild(trace) {
      switch (trace.type) {
        case "begin":
          if (!resolvers[0])
            return;
          const [resolveStart2] = resolvers[0];
          resolveStart2({
            children: [],
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          const child = resolvers.shift();
          if (!child)
            return;
          child[1](trace.time);
      }
    },
    resolve() {
      resolveStart({
        children: [],
        end: new Promise((resolve) => resolve(0)),
        name: "",
        skip: true,
        time: 0
      });
      for (const [resolveStart2, resolveEnd2] of resolvers) {
        resolveStart2({
          children: [],
          end: new Promise((resolve) => resolve(0)),
          name: "",
          skip: true,
          time: 0
        });
        resolveEnd2(0);
      }
      resolveEnd(0);
    }
  };
};
var createTraceListener = (getReporter, totalListener, handler) => {
  if (typeof handler === "object")
    handler = handler.fn;
  return async function trace(trace) {
    if (trace.event !== "request" || trace.type !== "begin")
      return;
    const id = trace.id;
    const reporter = getReporter();
    const request = createSignal();
    const parse22 = createSignal();
    const transform7 = createSignal();
    const beforeHandle = createSignal();
    const handle = createSignal();
    const afterHandle = createSignal();
    const error22 = createSignal();
    const response = createSignal();
    request.consume(trace);
    const reducer = (event) => {
      if (event.id === id)
        switch (event.event) {
          case "request":
            request.consume(event);
            break;
          case "request.unit":
            request.consumeChild(event);
            break;
          case "parse":
            parse22.consume(event);
            break;
          case "parse.unit":
            parse22.consumeChild(event);
            break;
          case "transform":
            transform7.consume(event);
            break;
          case "transform.unit":
            transform7.consumeChild(event);
            break;
          case "beforeHandle":
            beforeHandle.consume(event);
            break;
          case "beforeHandle.unit":
            beforeHandle.consumeChild(event);
            break;
          case "handle":
            handle.consume(event);
            break;
          case "afterHandle":
            afterHandle.consume(event);
            break;
          case "afterHandle.unit":
            afterHandle.consumeChild(event);
            break;
          case "error":
            error22.consume(event);
            break;
          case "error.unit":
            error22.consumeChild(event);
            break;
          case "response":
            if (event.type === "begin") {
              request.resolve();
              parse22.resolve();
              transform7.resolve();
              beforeHandle.resolve();
              handle.resolve();
              afterHandle.resolve();
              error22.resolve();
            } else
              reporter.off("event", reducer);
            response.consume(event);
            break;
          case "response.unit":
            response.consumeChild(event);
            break;
          case "exit":
            request.resolve();
            parse22.resolve();
            transform7.resolve();
            beforeHandle.resolve();
            handle.resolve();
            afterHandle.resolve();
            error22.resolve();
            break;
        }
    };
    reporter.on("event", reducer);
    await handler({
      id,
      context: trace.ctx,
      set: trace.ctx?.set,
      store: trace.ctx?.store,
      time: trace.time,
      request: request.signal,
      parse: parse22.signal,
      transform: transform7.signal,
      beforeHandle: beforeHandle.signal,
      handle: handle.signal,
      afterHandle: afterHandle.signal,
      error: error22.signal,
      response: response.signal
    });
    reporter.emit(`res${id}.${totalListener}`, undefined);
  };
};
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(6);
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    index = code.indexOf(") => {\n");
    if (index !== -1)
      return [
        code.slice(1, index),
        code.slice(index + 5),
        { isArrowReturn: false }
      ];
    index = code.indexOf(") => ");
    if (index !== -1)
      return [
        code.slice(1, index),
        code.slice(index + 5),
        { isArrowReturn: true }
      ];
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    const end = code.indexOf(")");
    return [
      code.slice(index + 1, end),
      code.slice(end + 2),
      {
        isArrowReturn: false
      }
    ];
  }
  const start = code.indexOf("(");
  if (start !== -1) {
    const [parameter, body] = code.split("\n", 2);
    const end = parameter.lastIndexOf(")") + 1;
    return [
      parameter.slice(start, end),
      "{" + body,
      {
        isArrowReturn: false
      }
    ];
  }
  const x = code.split("\n", 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  const start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1;
  let deep = 1;
  for (;end < parameter.length; end++) {
    const char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  const end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1;
  let deep = 1;
  for (;start >= 0; start--) {
    const char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var retrieveRootParamters = (parameter) => {
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    parameter = parameter.slice(2, -2);
  while (true) {
    const [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    parameter = parameter.slice(0, start - 2) + parameter.slice(end + 1);
  }
  return parameter.replace(/:/g, "").trim();
};
var findParameterReference = (parameter, inference) => {
  const root = retrieveRootParamters(parameter);
  if (!inference.query && root.includes("query"))
    inference.query = true;
  if (!inference.headers && root.includes("headers"))
    inference.headers = true;
  if (!inference.body && root.includes("body"))
    inference.body = true;
  if (!inference.cookie && root.includes("cookie"))
    inference.cookie = true;
  if (!inference.set && root.includes("set"))
    inference.set = true;
  return root;
};
var findTraceParameterReference = (parameter, inference) => {
  const root = retrieveRootParamters(parameter);
  if (!inference.request && root.includes("request"))
    inference.request = true;
  if (!inference.parse && root.includes("parse"))
    inference.parse = true;
  if (!inference.transform && root.includes("transform"))
    inference.transform = true;
  if (!inference.handle && root.includes("handle"))
    inference.handle = true;
  if (!inference.beforeHandle && root.includes("beforeHandle"))
    inference.beforeHandle = true;
  if (!inference.afterHandle && root.includes("afterHandle"))
    inference.afterHandle = true;
  if (!inference.error && root.includes("error"))
    inference.error = true;
  if (!inference.context && root.includes("context"))
    inference.context = true;
  if (!inference.store && root.includes("store"))
    inference.store = true;
  if (!inference.set && root.includes("set"))
    inference.set = true;
  return root;
};
var findEndIndex = (type74, content, index) => {
  const newLineIndex = content.indexOf(type74 + "\n", index);
  const newTabIndex = content.indexOf(type74 + "	", index);
  const commaIndex = content.indexOf(type74 + ",", index);
  const semicolonIndex = content.indexOf(type74 + ";", index);
  const emptyIndex = content.indexOf(type74 + " ", index);
  return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a2, b) => a2 - b)[0] || -1;
};
var findAlias = (type74, body, depth = 0) => {
  if (depth > 5)
    return [];
  const aliases = [];
  let content = body;
  while (true) {
    let index = findEndIndex(" = " + type74, content);
    if (index === -1) {
      const lastIndex = content.indexOf(" = " + type74);
      if (lastIndex + 3 + type74.length !== content.length)
        break;
      index = lastIndex;
    }
    const part = content.slice(0, index);
    let variable = part.slice(part.lastIndexOf(" ") + 1);
    if (variable === "}") {
      const [start, end] = bracketPairRangeReverse(part);
      aliases.push(content.slice(start, end));
      content = content.slice(index + 3 + type74.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    aliases.push(variable);
    content = content.slice(index + 3 + type74.length);
  }
  for (const alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    const deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  const hasComma = parameter.includes(",");
  if (!hasComma) {
    if (parameter.includes("..."))
      return parameter.slice(parameter.indexOf("...") + 3);
    return parameter;
  }
  const spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  const access = (type74, alias) => code.includes(alias + "." + type74) || code.includes(alias + '["' + type74 + '"]') || code.includes(alias + "['" + type74 + "']");
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      alias = retrieveRootParamters(alias);
      if (!inference.query && alias.includes("query"))
        inference.query = true;
      if (!inference.headers && alias.includes("headers"))
        inference.headers = true;
      if (!inference.body && alias.includes("body"))
        inference.body = true;
      if (!inference.cookie && alias.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && alias.includes("set"))
        inference.set = true;
      continue;
    }
    if (code.includes("(" + alias + ")")) {
      inference.query = true;
      inference.headers = true;
      inference.body = true;
      inference.cookie = true;
      inference.set = true;
      inference.queries = [];
      inference.unknownQueries = true;
      break;
    }
    if (!inference.query && access("query", alias))
      inference.query = true;
    if (code.includes("return " + alias) || code.includes("return " + alias + ".query")) {
      inference.query = true;
      inference.unknownQueries = true;
      inference.queries = [];
    }
    if (!inference.unknownQueries && inference.query) {
      let keyword = alias + ".";
      if (code.includes(keyword + "query"))
        keyword = alias + ".query";
      while (true) {
        let start = code.indexOf(keyword);
        if (start === -1 && code.indexOf(alias + "[") !== -1) {
          inference.queries = [];
          inference.unknownQueries = true;
          break;
        }
        if (start !== -1) {
          let end = findEndIndex("", code, start + keyword.length + 1);
          if (end === -1)
            end = undefined;
          const index = start + alias.length + 1;
          code = code.slice(start + alias.length + 1);
          let query = code.slice(0, end ? end - index : end).trimEnd();
          while (start !== -1) {
            start = query.indexOf(".");
            if (start !== -1)
              query = query.slice(start + 1);
          }
          if (query.charCodeAt(query.length - 1) === 59)
            query = query.slice(0, -1);
          if (query.charCodeAt(query.length - 1) === 44)
            query = query.slice(0, -1);
          if (query.charCodeAt(query.length - 1) === 93)
            query = query.slice(0, -1);
          if (query.charCodeAt(query.length - 1) === 41)
            query = query.slice(0, -1);
          if (query && !inference.queries.includes(query)) {
            inference.queries.push(query);
            continue;
          }
        }
        break;
      }
    }
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set)
      break;
  }
  return aliases;
};
var removeDefaultParameter = (parameter) => {
  while (true) {
    const index = parameter.indexOf("=");
    if (index === -1)
      break;
    const commaIndex = parameter.indexOf(",", index);
    const bracketIndex = parameter.indexOf("}", index);
    const end = [commaIndex, bracketIndex].filter((i) => i > 0).sort((a2, b) => a2 - b)[0] || -1;
    if (end === -1) {
      parameter = parameter.slice(0, index);
      break;
    }
    parameter = parameter.slice(0, index) + parameter.slice(end);
  }
  return parameter.split(",").map((i) => i.trim()).join(", ");
};
var validateInferencedQueries = (queries) => {
  for (const query of queries) {
    if (query.charCodeAt(0) === 123)
      return false;
    if (query.indexOf("'") !== -1)
      return false;
    if (query.indexOf('"') !== -1)
      return false;
    if (query.indexOf("\n") !== -1)
      return false;
    if (query.indexOf("	") !== -1)
      return false;
  }
  return true;
};
var inferTraceBodyReference = (code, aliases, inference) => {
  const access = (type74, alias) => code.includes(type74 + "." + alias) || code.includes(type74 + '["' + alias + '"]') || code.includes(type74 + "['" + alias + "']");
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123) {
      alias = retrieveRootParamters(alias);
      if (!inference.request && alias.includes("request"))
        inference.request = true;
      if (!inference.parse && alias.includes("parse"))
        inference.parse = true;
      if (!inference.transform && alias.includes("transform"))
        inference.transform = true;
      if (!inference.handle && alias.includes("handle"))
        inference.handle = true;
      if (!inference.beforeHandle && alias.includes("beforeHandle"))
        inference.beforeHandle = true;
      if (!inference.afterHandle && alias.includes("afterHandle"))
        inference.afterHandle = true;
      if (!inference.error && alias.includes("error"))
        inference.error = true;
      if (!inference.context && alias.includes("context"))
        inference.context = true;
      if (!inference.store && alias.includes("store"))
        inference.store = true;
      if (!inference.set && alias.includes("set"))
        inference.set = true;
      continue;
    }
    if (code.includes("(" + alias + ")")) {
      inference.request = true;
      inference.parse = true;
      inference.transform = true;
      inference.handle = true;
      inference.beforeHandle = true;
      inference.afterHandle = true;
      inference.error = true;
      inference.context = true;
      inference.store = true;
      inference.set = true;
      break;
    }
    if (!inference.request && access("request", alias))
      inference.request = true;
    if (!inference.parse && access("parse", alias))
      inference.parse = true;
    if (!inference.transform && access("transform", alias))
      inference.transform = true;
    if (!inference.handle && access("handle", alias))
      inference.handle = true;
    if (!inference.beforeHandle && access("beforeHandle", alias))
      inference.beforeHandle = true;
    if (!inference.afterHandle && access("afterHandle", alias))
      inference.afterHandle = true;
    if (!inference.error && access("error", alias))
      inference.error = true;
    if (!inference.context && access("context", alias))
      inference.context = true;
    if (!inference.store && access("store", alias))
      inference.store = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (inference.request && inference.parse && inference.transform && inference.handle && inference.beforeHandle && inference.afterHandle && inference.error && inference.context && inference.store && inference.set)
      break;
  }
  return aliases;
};
var sucrose = (lifeCycle, inference = {
  queries: [],
  query: false,
  headers: false,
  body: false,
  cookie: false,
  set: false,
  unknownQueries: false
}) => {
  const events = [];
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.onResponse?.length)
    events.push(...lifeCycle.onResponse);
  for (const e2 of events) {
    if (!e2)
      continue;
    const event = "fn" in e2 ? e2.fn : e2;
    const [parameter, body, { isArrowReturn }] = separateFunction(event.toString());
    const rootParameters = findParameterReference(parameter, inference);
    const mainParameter = extractMainParameter(rootParameters);
    if (isArrowReturn && (body === "query" || rootParameters && body.startsWith(rootParameters + ".query"))) {
      inference.query = true;
      inference.unknownQueries = true;
      inference.queries = [];
    }
    if (mainParameter) {
      const aliases = findAlias(mainParameter, body);
      aliases.splice(0, -1, mainParameter);
      inferBodyReference(body, aliases, inference);
    }
    const context = rootParameters || mainParameter;
    if (context && body.includes("return " + context + ".query")) {
      inference.query = true;
      inference.unknownQueries = true;
      inference.queries = [];
    }
    if (inference.query) {
      inferBodyReference(body, ["query"], inference);
      const queryIndex = parameter.indexOf("query: {");
      if (queryIndex !== -1) {
        const part = parameter.slice(queryIndex + 7);
        const [start, end] = bracketPairRange(part);
        const queryBracket = removeDefaultParameter(part.slice(start, end));
        for (let query of queryBracket.slice(1, -1).split(",")) {
          const index = query.indexOf(":");
          if (index !== -1)
            query = query.slice(0, index);
          query = query.trim();
          if (query && !inference.queries.includes(query))
            inference.queries.push(query.trim());
        }
      }
    }
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set)
      break;
  }
  if (!validateInferencedQueries(inference.queries)) {
    inference.unknownQueries = true;
    inference.queries = [];
  }
  return inference;
};
var sucroseTrace = (traces, inference = {
  request: false,
  parse: false,
  transform: false,
  handle: false,
  beforeHandle: false,
  afterHandle: false,
  error: false,
  context: false,
  store: false,
  set: false
}) => {
  for (const handler of traces) {
    const [parameter, body] = separateFunction(handler.toString());
    const rootParameters = findTraceParameterReference(parameter, inference);
    const mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      const aliases = findAlias(mainParameter, body);
      aliases.splice(0, -1, mainParameter);
      inferTraceBodyReference(body, aliases, inference);
      continue;
    }
    if (inference.request && inference.parse && inference.transform && inference.handle && inference.beforeHandle && inference.afterHandle && inference.error && inference.context && inference.store && inference.set)
      break;
  }
  return inference;
};
var Cookie = class {
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    if (!(this.name in this.jar))
      return this.initial;
    return this.jar[this.name];
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value15) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name].value = value15;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.cookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.cookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.cookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.cookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.cookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.cookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.cookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.cookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.cookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.cookie.secrets = secrets;
  }
  update(config) {
    this.cookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config);
    return this;
  }
  set(config) {
    this.cookie = Object.assign({
      ...this.initial,
      value: this.value
    }, typeof config === "function" ? config(this.cookie) : config);
    return this;
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({
      expires: new Date(0),
      maxAge: 0,
      value: ""
    });
    return this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
};
var createCookieJar = (set2, store, initial) => {
  if (!set2.cookie)
    set2.cookie = {};
  return new Proxy(store, {
    get(_, key) {
      if (key in store)
        return new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
      return new Cookie(key, set2.cookie, Object.assign({}, initial));
    }
  });
};
var parseCookie = async (set2, cookieString, {
  secrets,
  sign,
  ...initial
} = {}) => {
  if (!cookieString)
    return createCookieJar(set2, {}, initial);
  const isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  const jar = {};
  const cookies = import_cookie2.parse(cookieString);
  for (const [name, v] of Object.entries(cookies)) {
    let value15 = import_fast_decode_uri_component.default(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        const temp = await unsignCookie(value15, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value15 = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          const temp = await unsignCookie(value15, secrets[i]);
          if (temp !== false) {
            decoded = true;
            value15 = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    const start = value15.charCodeAt(0);
    if (start === 123 || start === 91)
      try {
        jar[name] = {
          value: JSON.parse(value15)
        };
        continue;
      } catch {
      }
    if (isNumericString(value15)) {
      jar[name] = {
        value: parseInt(value15)
      };
      continue;
    }
    if (value15 === "true") {
      jar[name] = {
        value: true
      };
      continue;
    }
    if (value15 === "false") {
      jar[name] = {
        value: false
      };
      continue;
    }
    jar[name] = {
      value: value15
    };
  }
  return createCookieJar(set2, jar, initial);
};
var hasHeaderShorthand = "toJSON" in new Headers;
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (const x in obj)
    return true;
  return false;
};
var handleFile = (response, set2) => {
  const size = response.size;
  if (!set2 && size || size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        if (hasHeaderShorthand)
          set2.headers = set2.headers.toJSON();
        else
          for (const [key, value15] of set2.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value15;
      }
      return new Response(response, {
        status: set2.status,
        headers: Object.assign({
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`
        }, set2.headers)
      });
    }
    return new Response(response, {
      headers: {
        "accept-ranges": "bytes",
        "content-range": `bytes 0-${size - 1}/${size}`
      }
    });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("Set-Cookie");
  for (let i = 0;i < setCookie.length; i++) {
    const index = setCookie[i].indexOf("=");
    headers.append("Set-Cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  const set2 = [];
  for (const [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    const value15 = property.value;
    if (value15 === undefined || value15 === null)
      continue;
    set2.push(import_cookie.serialize(key, typeof value15 === "object" ? JSON.stringify(value15) : value15 + "", property));
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var mapResponse = (response, set2, request) => {
  if (response?.$passthrough)
    response = response?.[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = serializeCookie(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"])) {
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    }
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return Response.json(response, set2);
      case "Response":
        let isCookieSet = false;
        if (set2.headers instanceof Headers)
          for (const key of set2.headers.keys()) {
            if (key === "set-cookie") {
              if (isCookieSet)
                continue;
              isCookieSet = true;
              for (const cookie of set2.headers.getSetCookie()) {
                response.headers.append("set-cookie", cookie);
              }
            } else
              response.headers.append(key, set2.headers?.get(key) ?? "");
          }
        else
          for (const key in set2.headers)
            response.headers.append(key, set2.headers[key]);
        if (response.status !== set2.status)
          set2.status = response.status;
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse(x, set2));
      case "Function":
        return mapResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          let isCookieSet2 = false;
          if (set2.headers instanceof Headers)
            for (const key of set2.headers.keys()) {
              if (key === "set-cookie") {
                if (isCookieSet2)
                  continue;
                isCookieSet2 = true;
                for (const cookie of set2.headers.getSetCookie()) {
                  response.headers.append("set-cookie", cookie);
                }
              } else
                response.headers.append(key, set2.headers?.get(key) ?? "");
            }
          else
            for (const key in set2.headers)
              response.headers.append(key, set2.headers[key]);
          if (hasHeaderShorthand)
            set2.headers = response.headers.toJSON();
          else
            for (const [key, value15] of response.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value15;
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => {
          const r2 = mapCompactResponse(x);
          if (r2 !== undefined)
            return r2;
          return new Response("");
        });
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapEarlyResponse = (response, set2, request) => {
  if (response === undefined || response === null)
    return;
  if (response?.$passthrough)
    response = response?.[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = serializeCookie(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set2);
      case "Response":
        let isCookieSet = false;
        if (set2.headers instanceof Headers)
          for (const key of set2.headers.keys()) {
            if (key === "set-cookie") {
              if (isCookieSet)
                continue;
              isCookieSet = true;
              for (const cookie of set2.headers.getSetCookie()) {
                response.headers.append("set-cookie", cookie);
              }
            } else
              response.headers.append(key, set2.headers?.get(key) ?? "");
          }
        else
          for (const key in set2.headers)
            response.headers.append(key, set2.headers[key]);
        if (response.status !== set2.status)
          set2.status = response.status;
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          let isCookieSet2 = false;
          if (set2.headers instanceof Headers)
            for (const key of set2.headers.keys()) {
              if (key === "set-cookie") {
                if (isCookieSet2)
                  continue;
                isCookieSet2 = true;
                for (const cookie of set2.headers.getSetCookie()) {
                  response.headers.append("set-cookie", cookie);
                }
              } else
                response.headers.append(key, set2.headers?.get(key) ?? "");
            }
          else
            for (const key in set2.headers)
              response.headers.append(key, set2.headers[key]);
          if (response.status !== set2.status)
            set2.status = response.status;
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        request?.signal.addEventListener("abort", {
          handleEvent() {
            if (!request?.signal.aborted)
              response.cancel(request);
          }
        }, {
          once: true
        });
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        if ("charCodeAt" in response) {
          const code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set2.headers["Content-Type"])
              set2.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set2);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  if (response?.$passthrough)
    response = response?.[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE])
    return mapResponse(response.response, {
      status: response[ELYSIA_RESPONSE],
      headers: {}
    });
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Blob":
      return handleFile(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "ReadableStream":
      request?.signal.addEventListener("abort", {
        handleEvent() {
          if (!request?.signal.aborted)
            response.cancel(request);
        }
      }, {
        once: true
      });
      return new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then(mapCompactResponse);
    case "Function":
      return mapCompactResponse(response());
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    default:
      if (response instanceof Response)
        return new Response(response.body, {
          headers: {
            "Content-Type": "application/json"
          }
        });
      if (response instanceof Promise)
        return response.then(mapCompactResponse);
      if (response instanceof Error)
        return errorToResponse(response);
      if ("charCodeAt" in response) {
        const code = response.charCodeAt(0);
        if (code === 123 || code === 91) {
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        }
      }
      return new Response(response);
  }
};
var errorToResponse = (error22, set2) => new Response(JSON.stringify({
  name: error22?.name,
  message: error22?.message,
  cause: error22?.cause
}), {
  status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
  headers: set2?.headers
});
var replaceUrlPath = (url, pathname) => {
  const urlObject = new URL(url);
  urlObject.pathname = pathname;
  return urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, {
  skipKeys
} = {}) => {
  if (isObject(target) && isObject(source))
    for (const [key, value15] of Object.entries(source)) {
      if (skipKeys?.includes(key))
        continue;
      if (!isObject(value15) || !(key in target) || isClass(value15)) {
        target[key] = value15;
        continue;
      }
      target[key] = mergeDeep(target[key], value15);
    }
  return target;
};
var mergeCookie = (a2, b) => {
  const { properties: _, ...target } = a2 ?? {};
  const { properties: __, ...source } = b ?? {};
  return mergeDeep(target, source);
};
var mergeObjectArray = (a2 = [], b = []) => {
  if (!a2)
    return [];
  if (!b)
    return a2;
  const array5 = [];
  const checksums = [];
  if (!Array.isArray(a2))
    a2 = [a2];
  if (!Array.isArray(b))
    b = [b];
  for (const item of a2) {
    array5.push(item);
    if (item.checksum)
      checksums.push(item.checksum);
  }
  for (const item of b)
    if (!checksums.includes(item.checksum))
      array5.push(item);
  return array5;
};
var primitiveHooks = [
  "start",
  "request",
  "parse",
  "transform",
  "resolve",
  "beforeHandle",
  "afterHandle",
  "onResponse",
  "mapResponse",
  "trace",
  "error",
  "stop",
  "body",
  "headers",
  "params",
  "query",
  "response",
  "type",
  "detail"
];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse = (a2, b) => {
  const isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString);
  if (isRecordNumber(a2) && isRecordNumber(b))
    return { ...a2, ...b };
  return b ?? a2;
};
var mergeHook = (a2, b, { allowMacro = false } = {}) => {
  const rest4 = allowMacro ? {
    ...a2,
    ...b
  } : undefined;
  return {
    ...rest4,
    body: b?.body ?? a2?.body,
    headers: b?.headers ?? a2?.headers,
    params: b?.params ?? a2?.params,
    query: b?.query ?? a2?.query,
    response: mergeResponse(a2?.response, b?.response),
    type: a2?.type || b?.type,
    detail: mergeDeep(b?.detail ?? {}, a2?.detail ?? {}),
    parse: mergeObjectArray(a2?.parse, b?.parse),
    transform: mergeObjectArray(a2?.transform, b?.transform),
    beforeHandle: mergeObjectArray(a2?.beforeHandle, b?.beforeHandle),
    afterHandle: mergeObjectArray(a2?.afterHandle, b?.afterHandle),
    onResponse: mergeObjectArray(a2?.onResponse, b?.onResponse),
    mapResponse: mergeObjectArray(a2?.mapResponse, b?.mapResponse),
    trace: mergeObjectArray(a2?.trace, b?.trace),
    error: mergeObjectArray(a2?.error, b?.error)
  };
};
var getSchemaValidator = (s, {
  models = {},
  dynamic = false,
  normalize = false,
  additionalProperties = normalize
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const schema3 = typeof s === "string" ? models[s] : s;
  if (schema3.type === "object" && "additionalProperties" in schema3 === false)
    schema3.additionalProperties = additionalProperties;
  const cleaner = (value15) => exports_value2.Clean(schema3, value15);
  if (dynamic) {
    const validator = {
      schema: schema3,
      references: "",
      checkFunc: () => {
      },
      code: "",
      Check: (value15) => exports_value2.Check(schema3, value15),
      Errors: (value15) => exports_value2.Errors(schema3, value15),
      Code: () => ""
    };
    if (normalize && schema3.additionalProperties === true)
      validator.Clean = cleaner;
    if (schema3.config) {
      validator.config = schema3.config;
      if (validator?.schema?.config)
        delete validator.schema.config;
    }
    return validator;
  }
  const compiled = TypeCompiler.Compile(schema3, Object.values(models));
  compiled.Clean = cleaner;
  if (schema3.config) {
    compiled.config = schema3.config;
    if (compiled?.schema?.config)
      delete compiled.schema.config;
  }
  return compiled;
};
var getResponseSchemaValidator = (s, {
  models = {},
  dynamic = false,
  normalize = false,
  additionalProperties = normalize
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const maybeSchemaOrRecord = typeof s === "string" ? models[s] : s;
  const compile = (schema3, references) => {
    const cleaner = (value15) => exports_value2.Clean(schema3, value15);
    if (dynamic)
      return {
        schema: schema3,
        references: "",
        checkFunc: () => {
        },
        code: "",
        Check: (value15) => exports_value2.Check(schema3, value15),
        Errors: (value15) => exports_value2.Errors(schema3, value15),
        Code: () => ""
      };
    const compiledValidator = TypeCompiler.Compile(schema3, references);
    if (normalize && schema3.additionalProperties === true)
      compiledValidator.Clean = cleaner;
    return compiledValidator;
  };
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return {
      200: compile(maybeSchemaOrRecord, Object.values(models))
    };
  }
  const record4 = {};
  Object.keys(maybeSchemaOrRecord).forEach((status) => {
    const maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        const schema3 = models[maybeNameOrSchema];
        schema3.type === "object" && "additionalProperties" in schema3;
        record4[+status] = Kind in schema3 ? compile(schema3, Object.values(models)) : schema3;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record4[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  });
  return record4;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum = (s) => {
  if (hasHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
  return h = h ^ h >>> 9;
};
var getCookieValidator = ({
  validator,
  defaultConfig = {},
  config,
  dynamic,
  models
}) => {
  let cookieValidator = getSchemaValidator(validator, {
    dynamic,
    models,
    additionalProperties: true
  });
  if (isNotEmpty(defaultConfig)) {
    if (cookieValidator) {
      cookieValidator.config = mergeCookie(cookieValidator.config, config);
    } else {
      cookieValidator = getSchemaValidator(t2.Cookie({}), {
        dynamic,
        models,
        additionalProperties: true
      });
      cookieValidator.config = defaultConfig;
    }
  }
  return cookieValidator;
};
var mergeLifeCycle = (a2, b, checksum2) => {
  const injectChecksum = (x) => {
    if (!x)
      return;
    if (!Array.isArray(x)) {
      const fn = x;
      if (checksum2 && !fn.checksum)
        fn.checksum = checksum2;
      if (fn.scope === "scoped")
        fn.scope = "local";
      return fn;
    }
    const fns = [...x];
    for (const fn of fns) {
      if (checksum2 && !fn.checksum)
        fn.checksum = checksum2;
      if (fn.scope === "scoped")
        fn.scope = "local";
    }
    return fns;
  };
  return {
    start: mergeObjectArray(a2.start, injectChecksum(b?.start)),
    request: mergeObjectArray(a2.request, injectChecksum(b?.request)),
    parse: mergeObjectArray(a2.parse, injectChecksum(b?.parse)),
    transform: mergeObjectArray(a2.transform, injectChecksum(b?.transform)),
    beforeHandle: mergeObjectArray(a2.beforeHandle, injectChecksum(b?.beforeHandle)),
    afterHandle: mergeObjectArray(a2.afterHandle, injectChecksum(b?.afterHandle)),
    mapResponse: mergeObjectArray(a2.mapResponse, injectChecksum(b?.mapResponse)),
    onResponse: mergeObjectArray(a2.onResponse, injectChecksum(b?.onResponse)),
    trace: a2.trace,
    error: mergeObjectArray(a2.error, injectChecksum(b?.error)),
    stop: mergeObjectArray(a2.stop, injectChecksum(b?.stop))
  };
};
var asHookType = (fn, inject, { skipIfHasType = false } = {}) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (const x of fn)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  const array5 = [];
  for (const x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array5.push({
          ...x
        });
        break;
    }
  return array5;
};
var filterGlobalHook = (hook) => {
  return {
    ...hook,
    type: hook?.type,
    detail: hook?.detail,
    parse: filterGlobal(hook?.parse),
    transform: filterGlobal(hook?.transform),
    beforeHandle: filterGlobal(hook?.beforeHandle),
    afterHandle: filterGlobal(hook?.afterHandle),
    onResponse: filterGlobal(hook?.onResponse),
    error: filterGlobal(hook?.error),
    mapResponse: filterGlobal(hook?.mapResponse)
  };
};
var StatusMap = {
  Continue: 100,
  "Switching Protocols": 101,
  Processing: 102,
  "Early Hints": 103,
  OK: 200,
  Created: 201,
  Accepted: 202,
  "Non-Authoritative Information": 203,
  "No Content": 204,
  "Reset Content": 205,
  "Partial Content": 206,
  "Multi-Status": 207,
  "Already Reported": 208,
  "Multiple Choices": 300,
  "Moved Permanently": 301,
  Found: 302,
  "See Other": 303,
  "Not Modified": 304,
  "Temporary Redirect": 307,
  "Permanent Redirect": 308,
  "Bad Request": 400,
  Unauthorized: 401,
  "Payment Required": 402,
  Forbidden: 403,
  "Not Found": 404,
  "Method Not Allowed": 405,
  "Not Acceptable": 406,
  "Proxy Authentication Required": 407,
  "Request Timeout": 408,
  Conflict: 409,
  Gone: 410,
  "Length Required": 411,
  "Precondition Failed": 412,
  "Payload Too Large": 413,
  "URI Too Long": 414,
  "Unsupported Media Type": 415,
  "Range Not Satisfiable": 416,
  "Expectation Failed": 417,
  "I'm a teapot": 418,
  "Misdirected Request": 421,
  "Unprocessable Content": 422,
  Locked: 423,
  "Failed Dependency": 424,
  "Too Early": 425,
  "Upgrade Required": 426,
  "Precondition Required": 428,
  "Too Many Requests": 429,
  "Request Header Fields Too Large": 431,
  "Unavailable For Legal Reasons": 451,
  "Internal Server Error": 500,
  "Not Implemented": 501,
  "Bad Gateway": 502,
  "Service Unavailable": 503,
  "Gateway Timeout": 504,
  "HTTP Version Not Supported": 505,
  "Variant Also Negotiates": 506,
  "Insufficient Storage": 507,
  "Loop Detected": 508,
  "Not Extended": 510,
  "Network Authentication Required": 511
};
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k, v]) => [v, k]));
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const tentativeValue = input.slice(0, input.lastIndexOf("."));
  const expectedInput = await signCookie(tentativeValue, secret);
  return expectedInput === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, hooks = property) => {
  if (!extension || typeof extension !== "object" || !property)
    return;
  for (const [key, value15] of Object.entries(property)) {
    if (key in primitiveHookMap || !(key in extension))
      continue;
    const v = extension[key];
    if (typeof v === "function") {
      v(value15);
    } else if (typeof v === "object")
      traceBackMacro(v, value15, hooks);
  }
};
var createMacroManager = ({
  globalHook,
  localHook
}) => (stackName) => (type74, fn) => {
  if (typeof type74 === "function")
    type74 = {
      fn: type74
    };
  if ("fn" in type74 || Array.isArray(type74)) {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (Array.isArray(type74))
      localHook[stackName] = localHook[stackName].concat(type74);
    else
      localHook[stackName].push(type74);
    return;
  }
  const { insert = "after", stack = "local" } = type74;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global") {
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        globalHook[stackName].unshift(fn);
      } else {
        globalHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        globalHook[stackName] = fn.concat(globalHook[stackName]);
      } else {
        globalHook[stackName] = globalHook[stackName].concat(fn);
      }
    }
  } else {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (!Array.isArray(fn)) {
      if (insert === "before") {
        localHook[stackName].unshift(fn);
      } else {
        localHook[stackName].push(fn);
      }
    } else {
      if (insert === "before") {
        localHook[stackName] = fn.concat(localHook[stackName]);
      } else {
        localHook[stackName] = localHook[stackName].concat(fn);
      }
    }
  }
};
var isNumericString = (message) => {
  if (message.length < 16)
    return message.trim().length !== 0 && !Number.isNaN(Number(message));
  if (message.length === 16) {
    const numVal = Number(message);
    if (numVal.toString() === message)
      return message.trim().length !== 0 && !Number.isNaN(numVal);
  }
  return false;
};
var PromiseGroup = class {
  constructor(onError = console.error) {
    this.onError = onError;
    this.root = null;
    this.promises = [];
  }
  get size() {
    return this.promises.length;
  }
  add(promise5) {
    this.promises.push(promise5);
    this.root ||= this.drain();
    return promise5;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error22) {
        this.onError(error22);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
};
var fnToContainer = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function")
      return { fn };
    else if ("fn" in fn)
      return fn;
  }
  const fns = [];
  for (const x of fn) {
    if (typeof x === "function")
      fns.push({ fn: x });
    else if ("fn" in x)
      fns.push(x);
  }
  return fns;
};
var localHookToLifeCycleStore = (a2) => {
  return {
    ...a2,
    start: fnToContainer(a2?.start),
    request: fnToContainer(a2?.request),
    parse: fnToContainer(a2?.parse),
    transform: fnToContainer(a2?.transform),
    beforeHandle: fnToContainer(a2?.beforeHandle),
    afterHandle: fnToContainer(a2?.afterHandle),
    onResponse: fnToContainer(a2?.onResponse),
    mapResponse: fnToContainer(a2?.mapResponse),
    trace: fnToContainer(a2?.trace),
    error: fnToContainer(a2?.error),
    stop: fnToContainer(a2?.stop)
  };
};
var lifeCycleToFn = (a2) => {
  return {
    ...a2,
    start: a2.start?.map((x) => x.fn),
    request: a2.request?.map((x) => x.fn),
    parse: a2.parse?.map((x) => x.fn),
    transform: a2.transform?.map((x) => x.fn),
    beforeHandle: a2.beforeHandle?.map((x) => x.fn),
    afterHandle: a2.afterHandle?.map((x) => x.fn),
    onResponse: a2.onResponse?.map((x) => x.fn),
    mapResponse: a2.mapResponse?.map((x) => x.fn),
    trace: a2.trace?.map((x) => x.fn),
    error: a2.error?.map((x) => x.fn),
    stop: a2.stop?.map((x) => x.fn)
  };
};
var cloneInference = (inference) => ({
  event: {
    body: inference.event.body,
    cookie: inference.event.cookie,
    headers: inference.event.headers,
    queries: [...inference.event.queries],
    query: inference.event.query,
    set: inference.event.set,
    unknownQueries: inference.event.unknownQueries
  },
  trace: {
    request: inference.trace.request,
    parse: inference.trace.parse,
    transform: inference.trace.transform,
    handle: inference.trace.handle,
    beforeHandle: inference.trace.beforeHandle,
    afterHandle: inference.trace.afterHandle,
    error: inference.trace.error,
    context: inference.trace.context,
    store: inference.trace.store,
    set: inference.trace.set
  }
});
var redirect = (url, status = 301) => new Response(null, {
  status,
  headers: {
    Location: url
  }
});
var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var ELYSIA_RESPONSE = Symbol("ElysiaResponse");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var error22 = (code, response) => ({
  [ELYSIA_RESPONSE]: StatusMap[code] ?? code,
  response: response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code),
  _type: undefined
});
var InternalServerError = class extends Error {
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
    this.code = "INTERNAL_SERVER_ERROR";
    this.status = 500;
  }
};
var NotFoundError = class extends Error {
  constructor(message) {
    super(message ?? "NOT_FOUND");
    this.code = "NOT_FOUND";
    this.status = 404;
  }
};
var ParseError = class extends Error {
  constructor(message, body) {
    super(message ?? "PARSE");
    this.body = body;
    this.code = "PARSE";
    this.status = 400;
  }
};
var InvalidCookieSignature = class extends Error {
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
    this.code = "INVALID_COOKIE_SIGNATURE";
    this.status = 400;
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(type74, validator, value15) {
    if (typeof value15 === "object" && ELYSIA_RESPONSE in value15)
      value15 = value15.response;
    const error23 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value15).First() : exports_value2.Errors(validator, value15).First();
    const customError = error23?.schema.error ? typeof error23.schema.error === "function" ? error23.schema.error(type74, validator, value15) : error23.schema.error : undefined;
    const accessor = error23?.path || "root";
    let message = "";
    if (customError) {
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    } else if (isProduction) {
      message = JSON.stringify({
        type: "validation",
        on: type74,
        message: error23?.message,
        found: value15
      });
    } else {
      const schema3 = validator?.schema ?? validator;
      const errors5 = "Errors" in validator ? [...validator.Errors(value15)] : [...exports_value2.Errors(validator, value15)];
      let expected;
      try {
        expected = exports_value2.Create(schema3);
      } catch (error32) {
        expected = {
          type: "Could not create expected value",
          message: error32?.message,
          error: error32
        };
      }
      message = JSON.stringify({
        type: "validation",
        on: type74,
        property: accessor,
        message: error23?.message,
        expected,
        found: value15,
        errors: errors5
      }, null, 2);
    }
    super(message);
    this.type = type74;
    this.validator = validator;
    this.value = value15;
    this.code = "VALIDATION";
    this.status = 422;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel(validator) {
    const model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return _ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, {
      status: 400,
      headers: {
        ...headers,
        "content-type": "application/json"
      }
    });
  }
};
var websocket = {
  open(ws) {
    ws.data.open?.(ws);
  },
  message(ws, message) {
    ws.data.message?.(ws, message);
  },
  drain(ws) {
    ws.data.drain?.(ws);
  },
  close(ws, code, reason) {
    ws.data.close?.(ws, code, reason);
  }
};
var ElysiaWS = class {
  constructor(raw, data) {
    this.raw = raw;
    this.data = data;
    this.validator = raw.data.validator;
    if (raw.data.id) {
      this.id = raw.data.id;
    } else {
      const array5 = new Uint32Array(1);
      crypto.getRandomValues(array5);
      this.id = array5[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id(newID) {
    this.raw.data.id = newID;
  }
  get publish() {
    return (topic, data = undefined, compress) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.publish(topic, data, compress);
      return this;
    };
  }
  get send() {
    return (data) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (Buffer.isBuffer(data)) {
        this.raw.send(data);
        return this;
      }
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.send(data);
      return this;
    };
  }
  get subscribe() {
    return (room) => {
      this.raw.subscribe(room);
      return this;
    };
  }
  get unsubscribe() {
    return (room) => {
      this.raw.unsubscribe(room);
      return this;
    };
  }
  get cork() {
    return (callback) => {
      this.raw.cork(callback);
      return this;
    };
  }
  get close() {
    return () => {
      this.raw.close();
      return this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
};
var headersHasToJSON = new Headers().toJSON;
var requestId = { value: 0 };
var createReport = ({
  hasTrace,
  hasTraceSet = false,
  addFn,
  condition = {}
}) => {
  if (hasTrace) {
    addFn(`
const reporter = getReporter()
`);
    return (event, {
      name,
      attribute = "",
      unit = 0
    } = {}) => {
      const dotIndex = event.indexOf(".");
      const isGroup = dotIndex === -1;
      if (event !== "request" && event !== "response" && !condition[isGroup ? event : event.slice(0, dotIndex)])
        return () => {
          if (hasTraceSet && event === "afterHandle")
            addFn(`
await traceDone
`);
        };
      if (isGroup)
        name ||= event;
      else
        name ||= "anonymous";
      addFn("\n" + `reporter.emit('event', {
					id,
					event: '${event}',
					type: 'begin',
					name: '${name}',
					time: performance.now(),
					${isGroup ? `unit: ${unit},` : ""}
					${attribute}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      return () => {
        addFn("\n" + `reporter.emit('event', {
							id,
							event: '${event}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n");
        if (hasTraceSet && event === "afterHandle")
          addFn(`
await traceDone
`);
      };
    };
  } else {
    return () => () => {
    };
  }
};
var hasReturn = (fnLiteral) => {
  const parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    return true;
  }
  return fnLiteral.includes("return");
};
var composeValidationFactory = (hasErrorHandler, {
  injectResponse = "",
  normalize = false
} = {}) => ({
  composeValidation: (type74, value15 = `c.${type74}`) => hasErrorHandler ? `c.set.status = 422; throw new ValidationError('${type74}', ${type74}, ${value15})` : `c.set.status = 422; return new ValidationError('${type74}', ${type74}, ${value15}).toResponse(c.set.headers)`,
  composeResponseValidation: (name = "r") => {
    const returnError = hasErrorHandler ? `throw new ValidationError('response', response[c.set.status], ${name})` : `return new ValidationError('response', response[c.set.status], ${name}).toResponse(c.set.headers)`;
    let code = "\n" + injectResponse + "\n";
    code += `let er

		if(${name} && typeof ${name} === "object" && ELYSIA_RESPONSE in ${name})
			er = ${name}[ELYSIA_RESPONSE]
`;
    if (normalize)
      code += `
			if(!er && response[c.set.status]?.Clean)
				${name} = response[c.set.status]?.Clean(${name})
			else if(response[er]?.Clean)
				${name}.response = response[er]?.Clean(${name}.response)`;
    code += `
			if(er) {
				if(!(${name} instanceof Response) && response[er]?.Check(${name}.response) === false) {
					if(!(response instanceof Error)) {
						c.set.status = ${name}[ELYSIA_RESPONSE]

						${returnError}
					}
				}
			} else if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {
				if(!(response instanceof Error))
					${returnError}
			}
`;
    return code;
  }
});
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasProperty = (expectedProperty, schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object") {
    const properties = schema3.properties;
    if (!properties)
      return false;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++) {
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
        }
      }
    }
    return false;
  }
  return expectedProperty in schema3;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object" && schema3.properties) {
    const properties = schema3.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasTransform(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasTransform(property.anyOf[i]))
            return true;
      }
      const hasTransformSymbol = TransformSymbol in property;
      if (hasTransformSymbol)
        return true;
    }
    return false;
  }
  return TransformSymbol in schema3 || schema3.properties && TransformSymbol in schema3.properties;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsync = (v) => {
  const fn = "fn" in v ? v.fn : v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  const literal14 = fn.toString();
  if (literal14.includes("=> response.clone("))
    return false;
  if (literal14.includes("await"))
    return true;
  if (literal14.includes("async"))
    return true;
  return !!literal14.match(matchFnReturn);
};
var composeHandler = ({
  app,
  path,
  method,
  localHook,
  hooks,
  validator,
  handler,
  allowMeta = false,
  appInference: { event: eventInference, trace: traceInference }
}) => {
  const isHandleFn = typeof handler === "function";
  if (!isHandleFn)
    handler = mapResponse(handler, {
      headers: app.setHeaders ?? {}
    });
  const hasErrorHandler = app.config.forceErrorEncapsulation && (isHandleFn || hooks.afterHandle.length > 0 || hooks.beforeHandle.length > 0 || hooks.transform.length > 0) || hooks.error.length > 0 || app.event.error.length > 0 || typeof Bun === "undefined" || hooks.onResponse.length > 0 || !!hooks.trace.length;
  const handle = isHandleFn ? `handler(c)` : `handler`;
  const handleResponse = hooks.onResponse.length ? `
;(async () => {${hooks.onResponse.map((_, i) => `await res${i}(c)`).join(";")}})();
` : "";
  const traceConditions = traceInference;
  const hasTrace = hooks.trace.length > 0;
  let fnLiteral = "";
  const inference = sucrose(Object.assign(localHook, {
    handler
  }), eventInference);
  const hasQuery = inference.query || !!validator.query;
  const hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && hooks.type !== "none" && (inference.body || !!validator.body);
  const defaultHeaders = app.setHeaders;
  const hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length;
  const hasHeaders = inference.headers || validator.headers;
  const hasCookie = inference.cookie || !!validator.cookie;
  const cookieValidator = hasCookie ? getCookieValidator({
    validator: validator.cookie,
    defaultConfig: app.config.cookie,
    dynamic: !!app.config.aot,
    config: validator.cookie?.config ?? {},
    models: app.definitions.type
  }) : undefined;
  const cookieMeta = cookieValidator?.config;
  let encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
    if (cookieMeta.sign === true) {
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
    } else
      for (const name of cookieMeta.sign) {
        encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
      }
    encodeCookie += "}\n";
  }
  const normalize = app.config.normalize;
  const { composeValidation, composeResponseValidation } = composeValidationFactory(hasErrorHandler, {
    normalize
  });
  if (hasHeaders) {
    fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  }
  if (hasCookie) {
    const get = (name, defaultValue) => {
      const value15 = cookieMeta?.[name] ?? defaultValue;
      if (!value15)
        return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
      if (typeof value15 === "string")
        return `${name}: '${value15}',`;
      if (value15 instanceof Date)
        return `${name}: new Date(${value15.getTime()}),`;
      return `${name}: ${value15},`;
    };
    const options = cookieMeta ? `{
			secrets: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a2, b) => a2 + `'${b}',`, "") + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a2, b) => a2 + `'${b}',`, "") + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
    else
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
  }
  if (hasQuery) {
    let destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      destructured = Object.keys(validator.query.schema.properties);
    } else
      for (const query of inference.queries)
        if (destructured.indexOf(query) === -1)
          destructured.push(query);
    if (app.config.forceDynamicQuery === true || inference.unknownQueries === true || !destructured.length) {
      fnLiteral += `if(c.qi !== -1) {
				c.query = parseQuery(c.url.slice(c.qi + 1).replace(/\\+/g, ' '))

				// decodeURIComponent is already done in parseQuery function
				// for(const key of Object.keys(c.query))
				//  	c.query[key] = decodeURIComponentc.query[key])
			} else c.query = {}`;
    } else {
      fnLiteral += `if(c.qi !== -1) {
				let url = '&' + c.url.slice(c.qi + 1).replace(/\\+/g, ' ')

				${destructured.map((name, index) => `
						${index === 0 ? "let" : ""} memory = url.indexOf('&${name}=')
						let a${index}

						if (memory !== -1) {
							const start = memory + ${name.length + 2}
							memory = url.indexOf('&', start)

							if(memory === -1) a${index} = decodeURIComponent(url.slice(start))
							else a${index} = decodeURIComponent(url.slice(start, memory))
						}`).join("\n")}

				c.query = {
					${destructured.map((name, index) => `'${name}': a${index}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    }
  }
  const hasTraceSet = traceInference.set;
  const hasSet = inference.cookie || inference.set || hasTraceSet || hasHeaders || isHandleFn && hasDefaultHeaders;
  if (hasTrace)
    fnLiteral += "\nconst id = c.$$requestId\n";
  const report = createReport({
    hasTrace,
    hasTraceSet,
    condition: traceConditions,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += hasErrorHandler ? "\n try {\n" : "";
  if (hasTraceSet) {
    fnLiteral += `
const traceDone = Promise.all([`;
    for (let i = 0;i < hooks.trace.length; i++) {
      fnLiteral += `new Promise(r => { reporter.once(\`res\${id}.${i}\`, r) }),`;
    }
    fnLiteral += `])
`;
  }
  const isAsyncHandler = typeof handler === "function" && isAsync(handler);
  const maybeAsync = hasCookie || hasBody || hasTraceSet || isAsyncHandler || !!hooks.mapResponse.length || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync);
  const endParse = report("parse", {
    unit: hooks.parse.length
  });
  if (hasBody) {
    const hasBodyInference = hooks.parse.length || inference.body || validator.body;
    if (hooks.type && !hooks.parse.length) {
      switch (hooks.type) {
        case "json":
        case "application/json":
          if (hasErrorHandler)
            fnLiteral += `const tempBody = await c.request.text()

							try {
								c.body = JSON.parse(tempBody)
							} catch {
								throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
							}`;
          else
            fnLiteral += `c.body = await c.request.json()`;
          break;
        case "text":
        case "text/plain":
          fnLiteral += `c.body = await c.request.text()
`;
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += `c.body = parseQuery(await c.request.text())
`;
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += `c.body = await c.request.arrayBuffer()
`;
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
          break;
      }
    } else if (hasBodyInference) {
      fnLiteral += "\n";
      fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
      fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)

					c.contentType = contentType
`;
      if (hooks.parse.length) {
        fnLiteral += `let used = false
`;
        const endReport = report("parse", {
          unit: hooks.parse.length
        });
        for (let i = 0;i < hooks.parse.length; i++) {
          const endUnit = report("parse.unit", {
            name: hooks.parse[i].fn.name
          });
          const name = `bo${i}`;
          if (i !== 0)
            fnLiteral += `if(!used) {
`;
          fnLiteral += `let ${name} = parse[${i}](c, contentType)
`;
          fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
          fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
          endUnit();
          if (i !== 0)
            fnLiteral += `}`;
        }
        endReport();
      }
      fnLiteral += "\ndelete c.contentType\n";
      if (hooks.parse.length)
        fnLiteral += `if (!used) {`;
      if (hooks.type && !Array.isArray(hooks.type)) {
        switch (hooks.type) {
          case "json":
          case "application/json":
            if (hasErrorHandler)
              fnLiteral += `const tempBody = await c.request.text()

								try {
									c.body = JSON.parse(tempBody)
								} catch {
									throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
								}`;
            else
              fnLiteral += `c.body = await c.request.json()`;
            break;
          case "text":
          case "text/plain":
            fnLiteral += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += `c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}
`;
            break;
        }
      } else {
        fnLiteral += `
					switch (contentType) {
						case 'application/json':
							${hasErrorHandler ? `
							const tempBody = await c.request.text()

							try {
								c.body = JSON.parse(tempBody)
							} catch {
								throw new ParseError('Failed to parse body as found: ' + (typeof body === "string" ? "'" + body + "'" : body), body)
							}
							` : `c.body = await c.request.json()
`}
							break

						case 'text/plain':
							c.body = await c.request.text()
							break

						case 'application/x-www-form-urlencoded':
							c.body = parseQuery(await c.request.text())
							break

						case 'application/octet-stream':
							c.body = await c.request.arrayBuffer();
							break

						case 'multipart/form-data':
							c.body = {}

							const form = await c.request.formData()
							for (const key of form.keys()) {
								if (c.body[key])
									continue

								const value = form.getAll(key)
								if (value.length === 1)
									c.body[key] = value[0]
								else c.body[key] = value
							}

							break
					}`;
      }
      if (hooks.parse.length)
        fnLiteral += `}`;
      fnLiteral += "}\n";
    }
    fnLiteral += "\n";
  }
  endParse();
  if (hooks?.transform) {
    const endTransform = report("transform", {
      unit: hooks.transform.length
    });
    if (hooks.transform.length)
      fnLiteral += "\nlet transformed\n";
    for (let i = 0;i < hooks.transform.length; i++) {
      const transform7 = hooks.transform[i];
      const endUnit = report("transform.unit", {
        name: transform7.fn.name
      });
      fnLiteral += isAsync(transform7) ? `transformed = await transform[${i}](c)
` : `transformed = transform[${i}](c)
`;
      fnLiteral += `if(transformed?.[ELYSIA_RESPONSE])
				throw transformed
			else
				Object.assign(c, transformed)
`;
      endUnit();
    }
    endTransform();
  }
  if (validator) {
    fnLiteral += "\n";
    if (validator.headers) {
      if (hasProperty("default", validator.headers.params))
        for (const [key, value15] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
          if (parsed)
            fnLiteral += `c.headers['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
      if (hasTransform(validator.headers.schema))
        fnLiteral += `
c.headers = headers.Decode(c.headers)
`;
    }
    if (validator.params) {
      if (hasProperty("default", validator.params.schema))
        for (const [key, value15] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
          if (parsed)
            fnLiteral += `c.params['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
      if (hasTransform(validator.params.schema))
        fnLiteral += `
c.params = params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (normalize)
        fnLiteral += "c.query = query.Clean(c.query);\n";
      if (hasProperty("default", validator.query.schema))
        for (const [key, value15] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          const parsed = typeof value15 === "object" ? JSON.stringify(value15) : `'${value15}'`;
          if (parsed)
            fnLiteral += `c.query['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(query.Check(c.query) === false) {
				${composeValidation("query")}
			}`;
      if (hasTransform(validator.query.schema))
        fnLiteral += `
c.query = query.Decode(Object.assign({}, c.query))
`;
    }
    if (validator.body) {
      if (normalize)
        fnLiteral += "c.body = body.Clean(c.body);\n";
      if (hasProperty("default", validator.body.schema))
        fnLiteral += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(validator.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${composeValidation("body")}
     			}
            }`;
      else
        fnLiteral += `if(body.Check(c.body) === false) {
			${composeValidation("body")}
		}`;
      if (hasTransform(validator.body.schema))
        fnLiteral += `
c.body = body.Decode(c.body)
`;
    }
    if (isNotEmpty(cookieValidator?.schema.properties ?? {})) {
      fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
      if (hasProperty("default", cookieValidator.schema))
        for (const [key, value15] of Object.entries(exports_value2.Default(cookieValidator.schema, {}))) {
          fnLiteral += `cookieValue['${key}'] = ${typeof value15 === "object" ? JSON.stringify(value15) : value15}
`;
        }
      fnLiteral += `if(cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
    }
  }
  if (hooks?.beforeHandle) {
    const endBeforeHandle = report("beforeHandle", {
      unit: hooks.beforeHandle.length
    });
    let hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      const beforeHandle = hooks.beforeHandle[i];
      const endUnit = report("beforeHandle.unit", {
        name: beforeHandle.fn.name
      });
      const returning = hasReturn(beforeHandle.fn.toString());
      const isResolver = beforeHandle.subType === "resolve";
      if (isResolver) {
        if (!hasResolve) {
          hasResolve = true;
          fnLiteral += "\nlet resolved\n";
        }
        fnLiteral += isAsync(beforeHandle) ? `resolved = await beforeHandle[${i}](c);
` : `resolved = beforeHandle[${i}](c);
`;
        fnLiteral += `if(resolved[ELYSIA_RESPONSE])
						throw resolved
					else
						Object.assign(c, resolved)
`;
      } else if (!returning) {
        fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i}](c);
` : `beforeHandle[${i}](c);
`;
        endUnit();
      } else {
        fnLiteral += `Object.assign(c, be);`;
        fnLiteral += isAsync(beforeHandle) ? `be = await beforeHandle[${i}](c);
` : `be = beforeHandle[${i}](c);
`;
        endUnit();
        fnLiteral += `if(be !== undefined) {
`;
        endBeforeHandle();
        if (hooks.afterHandle?.length) {
          const endAfterHandle = report("afterHandle", {
            unit: hooks.transform.length
          });
          report("handle", {
            name: isHandleFn ? handler.name : undefined
          })();
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            const hook = hooks.afterHandle[i2];
            const returning2 = hasReturn(hook.fn.toString());
            const endUnit2 = report("afterHandle.unit", {
              name: hook.fn.name
            });
            fnLiteral += `c.response = be
`;
            if (!returning2) {
              fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
            } else {
              fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
              fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
            }
            endUnit2();
          }
          endAfterHandle();
        }
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        if (hooks.mapResponse.length) {
          fnLiteral += `c.response = be`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i2}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}
`;
          }
        }
        fnLiteral += encodeCookie;
        fnLiteral += `return mapEarlyResponse(be, c.set)}
`;
      }
    }
    endBeforeHandle();
  }
  if (hooks?.afterHandle.length) {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle};
` : `let r = c.response = ${handle};
`;
    else
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
    endHandle();
    const endAfterHandle = report("afterHandle", {
      unit: hooks.afterHandle.length
    });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      const hook = hooks.afterHandle[i];
      const returning = hasReturn(hook.fn.toString());
      const endUnit = report("afterHandle.unit", {
        name: hook.fn.name
      });
      if (!returning) {
        fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`;
        endUnit();
      } else {
        fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i}](c)
` : `af = afterHandle[${i}](c)
`;
        endUnit();
        if (validator.response) {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += composeResponseValidation("af");
          fnLiteral += `c.response = af }`;
        } else {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += `c.response = af}
`;
        }
      }
    }
    endAfterHandle();
    fnLiteral += `r = c.response
`;
    if (validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    if (hooks.mapResponse.length) {
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        fnLiteral += `
mr = onMapResponse[${i}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr
`;
      }
    }
    if (hasSet)
      fnLiteral += `return mapResponse(r, c.set)
`;
    else
      fnLiteral += `return mapCompactResponse(r)
`;
  } else {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (validator.response || hooks.mapResponse.length) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      if (validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle")();
      if (hooks.mapResponse.length) {
        fnLiteral += "c.response = r";
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
if(mr === undefined) {
						mr = onMapResponse[${i}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}
`;
        }
      }
      fnLiteral += encodeCookie;
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${handle}.clone(), c.set)
				else
					return ${handle}.clone()` : `return ${handle}.clone()`;
        fnLiteral += "\n";
      } else if (hasSet)
        fnLiteral += `return mapResponse(r, c.set)
`;
      else
        fnLiteral += `return mapCompactResponse(r)
`;
    } else if (traceConditions.handle || hasCookie) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      report("afterHandle")();
      if (hooks.mapResponse.length) {
        fnLiteral += "c.response = r";
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}
`;
        }
      }
      fnLiteral += encodeCookie;
      if (hasSet)
        fnLiteral += `return mapResponse(r, c.set)
`;
      else
        fnLiteral += `return mapCompactResponse(r)
`;
    } else {
      endHandle();
      const handled = isAsyncHandler ? `await ${handle}` : handle;
      report("afterHandle")();
      if (handler instanceof Response) {
        fnLiteral += inference.set ? `if(
					isNotEmpty(c.set.headers) ||
					c.set.status !== 200 ||
					c.set.redirect ||
					c.set.cookie
				)
					return mapResponse(${handle}.clone(), c.set)
				else
					return ${handle}.clone()` : `return ${handle}.clone()`;
        fnLiteral += "\n";
      } else if (hasSet)
        fnLiteral += `return mapResponse(${handled}, c.set)
`;
      else
        fnLiteral += `return mapCompactResponse(${handled})
`;
    }
  }
  if (hasErrorHandler || handleResponse) {
    fnLiteral += `
} catch(error) {`;
    if (!maybeAsync)
      fnLiteral += `return (async () => {`;
    fnLiteral += `const set = c.set
if (!set.status || set.status < 300) set.status = error?.status || 500
`;
    const endError = report("error", {
      unit: hooks.error.length
    });
    if (hooks.error.length) {
      fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let i = 0;i < hooks.error.length; i++) {
        const name = `er${i}`;
        const endUnit = report("error.unit", {
          name: hooks.error[i].fn.name
        });
        fnLiteral += `
let ${name} = handleErrors[${i}](c)
`;
        if (isAsync(hooks.error[i]))
          fnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}
`;
        endUnit();
        fnLiteral += `${name} = mapEarlyResponse(${name}, set)
`;
        fnLiteral += `if (${name}) {`;
        fnLiteral += `return ${name} }
`;
      }
    }
    endError();
    fnLiteral += `return handleError(c, error, true)

`;
    if (!maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
    if (handleResponse || hasTrace) {
      fnLiteral += ` finally { `;
      const endResponse = report("response", {
        unit: hooks.onResponse.length
      });
      fnLiteral += handleResponse;
      endResponse();
      fnLiteral += `}`;
    }
  }
  fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery,
			isNotEmpty
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError,
			ParseError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent,
		ELYSIA_RESPONSE
	} = hooks

	${hooks.onResponse.length ? `const ${hooks.onResponse.map((x, i) => `res${i} = onResponse[${i}]`).join(",")}` : ""}

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${allowMeta ? "c.schema = schema; c.defs = definitions" : ""}
		${fnLiteral}
	}`;
  const createHandler = Function("hooks", fnLiteral);
  return createHandler({
    handler,
    hooks: lifeCycleToFn(hooks),
    validator,
    handleError: app.handleError,
    utils: {
      mapResponse,
      mapCompactResponse,
      mapEarlyResponse,
      parseQuery: import_fast_querystring.parse,
      isNotEmpty
    },
    error: {
      NotFoundError,
      ValidationError,
      InternalServerError,
      ParseError
    },
    schema: app.router.history,
    definitions: app.definitions.type,
    ERROR_CODE,
    getReporter: () => app.reporter,
    requestId,
    parseCookie,
    signCookie,
    decodeURIComponent: import_fast_decode_uri_component2.default,
    ELYSIA_RESPONSE
  });
};
var composeGeneralHandler = (app) => {
  const inference = {
    event: {
      ...app.inference.event,
      queries: [...app.inference.event.queries]
    },
    trace: { ...app.inference.trace }
  };
  let decoratorsLiteral = "";
  let fnLiteral = "";
  const defaultHeaders = app.setHeaders;
  for (const key of Object.keys(app.singleton.decorator))
    decoratorsLiteral += `,${key}: app.singleton.decorator.${key}`;
  const router = app.router;
  const hasTrace = app.event.trace.length > 0;
  let findDynamicRoute = `
	const route = router.find(request.method, path) ${router.http.root.ALL ? '?? router.find("ALL", path)' : ""}

	if (route === null)
		return ${app.event.error.length ? `app.handleError(ctx, notFound)` : app.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params
`;
  const shouldPrecompile = app.config.precompile === true || typeof app.config.precompile === "object" && app.config.precompile.compose === true;
  if (!shouldPrecompile)
    findDynamicRoute += `
			if(route.store.composed)
				return route.store.composed(ctx)

			if(route.store.compose)
				return (route.store.compose())(ctx)`;
  else
    findDynamicRoute += `return route.store(ctx)`;
  findDynamicRoute += "\n";
  let switchMap = ``;
  for (const [path, { code, all }] of Object.entries(router.static.http.map))
    switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? `default: break map`}}

`;
  const maybeAsync = app.event.request.some(isAsync);
  const init = `

	const url = request.url
	const s = url.indexOf('/', 11)
	const qi = url.indexOf('?', s + 1)
	let path
	if(qi === -1)
		path = url.substring(s)
	else
		path = url.substring(s, qi)
`;
  fnLiteral += `const {
		app,
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError,
		error,
		redirect
	} = data

	const store = app.singleton.store
	const staticRouter = app.router.static.http
	const wsRouter = app.router.ws
	const router = app.router.http

	const notFound = new NotFoundError()

	${app.event.request.length ? `const onRequest = app.event.request.map(x => x.fn)` : ""}
	${router.static.http.variables}
	${app.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${maybeAsync ? "async" : ""} function map(request) {
`;
  if (app.event.request.length)
    fnLiteral += `let re`;
  const report = createReport({
    hasTrace,
    hasTraceSet: inference.trace.set,
    condition: {
      request: inference.trace.request
    },
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  if (app.event.request.length) {
    fnLiteral += `
			${hasTrace ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				redirect,
				set: {
					headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				},
				error
				${hasTrace ? ",$$requestId: +id" : ""}
				${decoratorsLiteral}
			}
		`;
    const endReport = report("request", {
      attribute: "ctx",
      unit: app.event.request.length
    });
    fnLiteral += `
 try {
`;
    for (let i = 0;i < app.event.request.length; i++) {
      const hook = app.event.request[i];
      const withReturn = hasReturn(hook.fn.toString());
      const maybeAsync2 = isAsync(hook);
      const endUnit = report("request.unit", {
        name: app.event.request[i].fn.name
      });
      if (withReturn) {
        fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
					ctx.set,
					request
				)
`;
        endUnit();
        fnLiteral += `if(re !== undefined) return re
`;
      } else {
        fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)
`;
        endUnit();
      }
    }
    fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
    endReport();
    fnLiteral += init;
    fnLiteral += `
ctx.qi = qi
 ctx.path = path
ctx.url=url`;
  } else {
    fnLiteral += init;
    fnLiteral += `${hasTrace ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			url,
			redirect,
			set: {
				headers: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			},
			error
			${hasTrace ? ",$$requestId: id" : ""}
			${decoratorsLiteral}
		}`;
    report("request", {
      unit: app.event.request.length,
      attribute: inference.trace.context || inference.trace.store || inference.trace.set ? "ctx" : ""
    })();
  }
  const wsPaths = app.router.static.ws;
  const wsRouter = app.router.ws;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (const [path, index] of Object.entries(wsPaths)) {
      fnLiteral += `
					case '${path}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${index}(ctx)

						break`;
    }
    fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`;
  }
  fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}`;
  const handleError = composeErrorHandler(app);
  app.handleError = handleError;
  return Function("data", fnLiteral)({
    app,
    mapEarlyResponse,
    NotFoundError,
    getReporter: () => app.reporter,
    requestId,
    handleError,
    error: error22,
    redirect
  });
};
var composeErrorHandler = (app) => {
  let fnLiteral = `const {
		app: { event: { error: onErrorContainer, onResponse: resContainer } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	const onError = onErrorContainer.map(x => x.fn)
	const res = resContainer.map(x => x.fn)

	return ${app.event.error.find(isAsync) ? "async" : ""} function(context, error, skipGlobal) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(typeof error === "object" && ELYSIA_RESPONSE in error) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let i = 0;i < app.event.error.length; i++) {
    const handler = app.event.error[i];
    const response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)`;
    fnLiteral += "\nif(skipGlobal !== true) {\n";
    if (hasReturn(handler.fn.toString()))
      fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}

				if(set.status === 200) set.status = error.status
				return mapResponse(r, set, context.request)
			}
`;
    else
      fnLiteral += response + "\n";
    fnLiteral += "\n}\n";
  }
  fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 422
		return new Response(
			error.message,
			{
				headers: Object.assign(
					{ 'content-type': 'application/json'},
					set.headers
				),
				status: set.status
			}
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set, context.request)
	}
}`;
  return Function("inject", fnLiteral)({
    app,
    mapResponse,
    ERROR_CODE,
    ELYSIA_RESPONSE
  });
};
var jitRoute = (index) => `if(stc${index}) return stc${index}(ctx)
if(st${index}.compose) return (stc${index} = st${index}.compose())(ctx)

return st${index}(ctx)`;
var createDynamicHandler = (app) => async (request) => {
  const url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi);
  const set2 = {
    cookie: {},
    status: 200,
    headers: {}
  };
  const context = Object.assign({}, app.singleton.decorator, {
    set: set2,
    store: app.singleton.store,
    request,
    path,
    qi
  });
  try {
    for (let i = 0;i < app.event.request.length; i++) {
      const onRequest = app.event.request[i].fn;
      let response2 = onRequest(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      response2 = mapEarlyResponse(response2, set2);
      if (response2)
        return response2;
    }
    const handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
    if (!handler)
      throw new NotFoundError;
    const { handle, hooks, validator, content } = handler.store;
    let body;
    if (request.method !== "GET" && request.method !== "HEAD") {
      if (content) {
        switch (content) {
          case "application/json":
            body = await request.json();
            break;
          case "text/plain":
            body = await request.text();
            break;
          case "application/x-www-form-urlencoded":
            body = import_fast_querystring2.parse(await request.text());
            break;
          case "application/octet-stream":
            body = await request.arrayBuffer();
            break;
          case "multipart/form-data":
            body = {};
            const form = await request.formData();
            for (const key of form.keys()) {
              if (body[key])
                continue;
              const value15 = form.getAll(key);
              if (value15.length === 1)
                body[key] = value15[0];
              else
                body[key] = value15;
            }
            break;
        }
      } else {
        let contentType = request.headers.get("content-type");
        if (contentType) {
          const index = contentType.indexOf(";");
          if (index !== -1)
            contentType = contentType.slice(0, index);
          context.contentType = contentType;
          for (let i = 0;i < hooks.parse.length; i++) {
            const hook = hooks.parse[i].fn;
            let temp = hook(context, contentType);
            if (temp instanceof Promise)
              temp = await temp;
            if (temp) {
              body = temp;
              break;
            }
          }
          delete context.contentType;
          if (body === undefined) {
            switch (contentType) {
              case "application/json":
                body = await request.json();
                break;
              case "text/plain":
                body = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body = import_fast_querystring2.parse(await request.text());
                break;
              case "application/octet-stream":
                body = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body = {};
                const form = await request.formData();
                for (const key of form.keys()) {
                  if (body[key])
                    continue;
                  const value15 = form.getAll(key);
                  if (value15.length === 1)
                    body[key] = value15[0];
                  else
                    body[key] = value15;
                }
                break;
            }
          }
        }
      }
    }
    context.body = body;
    context.params = handler?.params || undefined;
    context.query = qi === -1 ? {} : import_fast_querystring2.parse(url.substring(qi + 1));
    context.headers = {};
    for (const [key, value15] of request.headers.entries())
      context.headers[key] = value15;
    const cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config);
    const cookieHeaderValue = request.headers.get("cookie");
    context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta ? {
      secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
      sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
    } : undefined);
    for (let i = 0;i < hooks.transform.length; i++) {
      const hook = hooks.transform[i];
      const operation = hook.fn(context);
      if (hook.subType === "derive") {
        if (operation instanceof Promise)
          Object.assign(context, await operation);
        else
          Object.assign(context, operation);
      } else if (operation instanceof Promise)
        await operation;
    }
    if (validator) {
      if (validator.headers) {
        const _header = {};
        for (const key in request.headers)
          _header[key] = request.headers.get(key);
        if (validator.headers.Check(_header) === false)
          throw new ValidationError("header", validator.headers, _header);
      }
      if (validator.params?.Check(context.params) === false)
        throw new ValidationError("params", validator.params, context.params);
      if (validator.query?.Check(context.query) === false)
        throw new ValidationError("query", validator.query, context.query);
      if (validator.cookie) {
        const cookieValue = {};
        for (const [key, value15] of Object.entries(context.cookie))
          cookieValue[key] = value15.value;
        if (validator.cookie?.Check(cookieValue) === false)
          throw new ValidationError("cookie", validator.cookie, cookieValue);
      }
      if (validator.body?.Check(body) === false)
        throw new ValidationError("body", validator.body, body);
    }
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let response2 = hooks.beforeHandle[i].fn(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      if (response2 !== undefined) {
        context.response = response2;
        for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
          let newResponse = hooks.afterHandle[i2].fn(context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          if (newResponse)
            response2 = newResponse;
        }
        const result = mapEarlyResponse(response2, context.set);
        if (result)
          return result;
      }
    }
    let response = handle(context);
    if (response instanceof Promise)
      response = await response;
    if (!hooks.afterHandle.length) {
      const responseValidator = validator?.response?.[response.status];
      if (responseValidator?.Check(response) === false)
        throw new ValidationError("response", responseValidator, response);
    } else {
      context.response = response;
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        let newResponse = hooks.afterHandle[i].fn(context);
        if (newResponse instanceof Promise)
          newResponse = await newResponse;
        const result = mapEarlyResponse(newResponse, context.set);
        if (result !== undefined) {
          const responseValidator = validator?.response?.[response.status];
          if (responseValidator?.Check(result) === false)
            throw new ValidationError("response", responseValidator, result);
          return result;
        }
      }
    }
    if (context.set.cookie && cookieMeta?.sign) {
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (cookieMeta.sign === true)
        for (const [key, cookie] of Object.entries(context.set.cookie))
          context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
      else {
        const properties = validator?.cookie?.schema?.properties;
        for (const name of cookieMeta.sign) {
          if (!(name in properties))
            continue;
          if (context.set.cookie[name]?.value) {
            context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
          }
        }
      }
    }
    return mapResponse(response, context.set);
  } catch (error23) {
    if (error23.status)
      set2.status = error23.status;
    return app.handleError(context, error23);
  } finally {
    for (const onResponse of app.event.onResponse)
      await onResponse.fn(context);
  }
};
var createDynamicErrorHandler = (app) => async (context, error23) => {
  const errorContext = Object.assign(context, { error: error23, code: error23.code });
  errorContext.set = context.set;
  for (let i = 0;i < app.event.error.length; i++) {
    const hook = app.event.error[i];
    let response = hook.fn(errorContext);
    if (response instanceof Promise)
      response = await response;
    if (response !== undefined && response !== null)
      return mapResponse(response, context.set);
  }
  return new Response(typeof error23.cause === "string" ? error23.cause : error23.message, {
    headers: context.set.headers,
    status: error23.status ?? 500
  });
};
var fullFormats = {
  date: date5,
  time: getTime(true),
  "date-time": getDateTime(true),
  "iso-time": getTime(false),
  "iso-date-time": getDateTime(false),
  duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
  uri,
  "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
  "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
  url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
  ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
  regex,
  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
  "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
  "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
  "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
  byte,
  int32: { type: "number", validate: validateInt32 },
  int64: { type: "number", validate: validateInt64 },
  float: { type: "number", validate: validateNumber },
  double: { type: "number", validate: validateNumber },
  password: true,
  binary: true
};
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
var DATE_TIME_SEPARATOR = /t|\s/i;
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
var MIN_INT32 = -(2 ** 31);
var MAX_INT32 = 2 ** 31 - 1;
var Z_ANCHOR = /[^\\]\\Z/;
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  TypeSystem.Format("date", (value15) => {
    const temp = value15.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      const date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  TypeSystem.Format("date-time", (value15) => {
    const temp = value15.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      const date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  const [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      TypeSystem.Format(formatName, (value15) => formatValue.test(value15));
    else if (typeof formatValue === "function")
      TypeSystem.Format(formatName, formatValue);
  }
});
var t2 = Object.assign({}, Type);
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile = (options, value15) => {
  if (!(value15 instanceof Blob))
    return false;
  if (options.minSize && value15.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value15.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value15.type.startsWith(options.extension))
        return false;
    } else {
      for (let i = 0;i < options.extension.length; i++)
        if (value15.type.startsWith(options.extension[i]))
          return true;
      return false;
    }
  return true;
};
var File = exports_type.Get("Files") ?? TypeSystem.Type("File", validateFile);
var Files = exports_type.Get("Files") ?? TypeSystem.Type("Files", (options, value15) => {
  if (!Array.isArray(value15))
    return validateFile(options, value15);
  if (options.minItems && value15.length < options.minItems)
    return false;
  if (options.maxItems && value15.length > options.maxItems)
    return false;
  for (let i = 0;i < value15.length; i++)
    if (!validateFile(options, value15[i]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value15) => !!value15 && !isNaN(+value15));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value15) => value15 === "true" || value15 === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value15) => {
    let start = value15.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value15.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value15);
      return true;
    } catch {
      return false;
    }
  });
var ElysiaType = {
  Numeric: (property) => {
    const schema3 = Type.Number(property);
    return t2.Transform(t2.Union([
      t2.String({
        format: "numeric",
        default: 0
      }),
      t2.Number(property)
    ], property)).Decode((value15) => {
      const number7 = +value15;
      if (isNaN(number7))
        return value15;
      if (property && !exports_value2.Check(schema3, number7))
        throw new ValidationError("property", schema3, number7);
      return number7;
    }).Encode((value15) => value15);
  },
  Date: (property) => {
    const schema3 = Type.Date(property);
    return t2.Transform(t2.Union([
      Type.Date(property),
      t2.String({
        format: "date",
        default: (new Date()).toISOString()
      }),
      t2.String({
        format: "date-time",
        default: (new Date()).toISOString()
      })
    ], property)).Decode((value15) => {
      if (value15 instanceof Date)
        return value15;
      const date22 = new Date(value15);
      if (!exports_value2.Check(schema3, date22))
        throw new ValidationError("property", schema3, date22);
      return date22;
    }).Encode((value15) => {
      if (typeof value15 === "string")
        return new Date(value15);
      return value15;
    });
  },
  BooleanString: (property) => {
    const schema3 = Type.Boolean(property);
    return t2.Transform(t2.Union([
      t2.String({
        format: "boolean",
        default: false
      }),
      t2.Boolean(property)
    ], property)).Decode((value15) => {
      if (typeof value15 === "string")
        return value15 === "true";
      if (property && !exports_value2.Check(schema3, value15))
        throw new ValidationError("property", schema3, value15);
      return value15;
    }).Encode((value15) => value15);
  },
  ObjectString: (properties = {}, options) => {
    const schema3 = t2.Object(properties, options);
    const defaultValue = JSON.stringify(exports_value2.Create(schema3));
    return t2.Transform(t2.Union([
      t2.String({
        format: "ObjectString",
        default: defaultValue
      }),
      schema3
    ])).Decode((value15) => {
      if (typeof value15 === "string") {
        try {
          value15 = JSON.parse(value15);
        } catch {
          throw new ValidationError("property", schema3, value15);
        }
        if (!exports_value2.Check(schema3, value15))
          throw new ValidationError("property", schema3, value15);
        return value15;
      }
      return value15;
    }).Encode((value15) => {
      if (typeof value15 === "string")
        try {
          value15 = JSON.parse(value15);
        } catch {
          throw new ValidationError("property", schema3, value15);
        }
      if (!exports_value2.Check(schema3, value15))
        throw new ValidationError("property", schema3, value15);
      return JSON.stringify(value15);
    });
  },
  File,
  Files: (options = {}) => t2.Transform(Files(options)).Decode((value15) => {
    if (Array.isArray(value15))
      return value15;
    return [value15];
  }).Encode((value15) => value15),
  Nullable: (schema3) => t2.Union([t2.Null(), schema3]),
  MaybeEmpty: (schema3) => t2.Union([t2.Null(), t2.Undefined(), schema3]),
  Cookie: (properties, {
    domain,
    expires,
    httpOnly,
    maxAge,
    path,
    priority,
    sameSite,
    secure,
    secrets,
    sign,
    ...options
  } = {}) => {
    const v = t2.Object(properties, options);
    v.config = {
      domain,
      expires,
      httpOnly,
      maxAge,
      path,
      priority,
      sameSite,
      secure,
      secrets,
      sign
    };
    return v;
  }
};
t2.BooleanString = ElysiaType.BooleanString;
t2.ObjectString = ElysiaType.ObjectString;
t2.Numeric = ElysiaType.Numeric;
t2.File = (arg = {}) => ElysiaType.File({
  default: "File",
  ...arg,
  extension: arg?.type,
  type: "string",
  format: "binary"
});
t2.Files = (arg = {}) => ElysiaType.Files({
  ...arg,
  elysiaMeta: "Files",
  default: "Files",
  extension: arg?.type,
  type: "array",
  items: {
    ...arg,
    default: "Files",
    type: "string",
    format: "binary"
  }
});
t2.Nullable = (schema3) => ElysiaType.Nullable(schema3);
t2.MaybeEmpty = ElysiaType.MaybeEmpty;
t2.Cookie = ElysiaType.Cookie;
t2.Date = ElysiaType.Date;
var Elysia = class _Elysia {
  constructor(config) {
    this.server = null;
    this.dependencies = {};
    this.reporter = new eventemitter3_default;
    this._routes = {};
    this._types = {
      Prefix: "",
      Scoped: false,
      Singleton: {},
      Definitions: {},
      Metadata: {}
    };
    this._ephemeral = {};
    this._volatile = {};
    this.singleton = {
      decorator: {},
      store: {},
      derive: {},
      resolve: {}
    };
    this.definitions = {
      type: {},
      error: {}
    };
    this.extender = {
      macros: []
    };
    this.validator = null;
    this.event = {
      start: [],
      request: [],
      parse: [],
      transform: [],
      beforeHandle: [],
      afterHandle: [],
      mapResponse: [],
      onResponse: [],
      trace: [],
      error: [],
      stop: []
    };
    this.telemetry = {
      stack: undefined
    };
    this.router = {
      http: new Memoirist,
      ws: new Memoirist,
      dynamic: new Memoirist,
      static: {
        http: {
          handlers: [],
          variables: "",
          map: {},
          all: ""
        },
        ws: {}
      },
      history: []
    };
    this.inference = {
      event: {
        body: false,
        cookie: false,
        headers: false,
        queries: [],
        query: false,
        set: false,
        unknownQueries: false
      },
      trace: {
        request: false,
        parse: false,
        transform: false,
        handle: false,
        beforeHandle: false,
        afterHandle: false,
        error: false,
        context: false,
        store: false,
        set: false
      }
    };
    this.promisedModules = new PromiseGroup;
    this.routeTree = new Map;
    this.handle = async (request) => this.fetch(request);
    this.fetch = (request) => {
      if (false)
        ;
      return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
    };
    this.handleError = async (context, error23) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error23);
    this.outerErrorHandler = (error23) => new Response(error23.message || error23.name || "Error", {
      status: error23?.status ?? 500
    });
    this.listen = (options, callback) => {
      if (typeof Bun === "undefined")
        throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
      this.compile();
      if (typeof options === "string") {
        if (!isNumericString(options))
          throw new Error("Port must be a numeric value");
        options = parseInt(options);
      }
      const fetch2 = this.fetch;
      const serve = typeof options === "object" ? {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        ...options || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        fetch: fetch2,
        error: this.outerErrorHandler
      } : {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        port: options,
        fetch: fetch2,
        error: this.outerErrorHandler
      };
      this.server = Bun?.serve(serve);
      for (let i = 0;i < this.event.start.length; i++)
        this.event.start[i].fn(this);
      if (callback)
        callback(this.server);
      process.on("beforeExit", () => {
        if (this.server) {
          this.server.stop();
          this.server = null;
          for (let i = 0;i < this.event.stop.length; i++)
            this.event.stop[i].fn(this);
        }
      });
      this.promisedModules.then(() => {
        Bun?.gc(false);
      });
      return this;
    };
    this.stop = async () => {
      if (!this.server)
        throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
      if (this.server) {
        this.server.stop();
        this.server = null;
        if (this.event.stop.length)
          for (let i = 0;i < this.event.stop.length; i++)
            this.event.stop[i].fn(this);
      }
    };
    if (config?.tags) {
      if (!config.detail)
        config.detail = {
          tags: config.tags
        };
      else
        config.detail.tags = config.tags;
    }
    this.config = {
      forceErrorEncapsulation: true,
      prefix: "",
      aot: true,
      strictPath: false,
      global: false,
      cookie: {},
      analytic: false,
      ...config,
      experimental: config?.experimental ?? {},
      seed: config?.seed === undefined ? "" : config?.seed
    };
    if (config?.analytic && (config?.name || config?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  getServer() {
    return this.server;
  }
  get routes() {
    return this.router.history;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      const manage = createMacroManager({
        globalHook: this.event,
        localHook
      });
      const manager = {
        events: {
          global: this.event,
          local: localHook
        },
        onParse: manage("parse"),
        onTransform: manage("transform"),
        onBeforeHandle: manage("beforeHandle"),
        onAfterHandle: manage("afterHandle"),
        onResponse: manage("onResponse"),
        mapResponse: manage("mapResponse"),
        onError: manage("error")
      };
      for (const macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook);
    }
  }
  add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = {
    allowMeta: false,
    skipPrefix: false
  }) {
    localHook = localHookToLifeCycleStore(localHook);
    if (path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix && !this.config.scoped)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    const models = this.definitions.type;
    let _body, _headers, _params, _query, _cookie, _response;
    const dynamic = !this.config.aot;
    const cloned = {
      body: localHook?.body ?? this.validator?.body,
      headers: localHook?.headers ?? this.validator?.headers,
      params: localHook?.params ?? this.validator?.params,
      query: localHook?.query ?? this.validator?.query,
      cookie: localHook?.cookie ?? this.validator?.cookie,
      response: localHook?.response ?? this.validator?.response
    };
    const cookieValidator = () => cloned.cookie ? getCookieValidator({
      validator: cloned.cookie,
      defaultConfig: this.config.cookie,
      config: cloned.cookie?.config ?? {},
      dynamic,
      models
    }) : undefined;
    const normalize = this.config.normalize;
    const validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? {
      body: getSchemaValidator(cloned.body, {
        dynamic,
        models,
        normalize
      }),
      headers: getSchemaValidator(cloned.headers, {
        dynamic,
        models,
        additionalProperties: true
      }),
      params: getSchemaValidator(cloned.params, {
        dynamic,
        models
      }),
      query: getSchemaValidator(cloned.query, {
        dynamic,
        models,
        normalize
      }),
      cookie: cookieValidator(),
      response: getResponseSchemaValidator(cloned.response, {
        dynamic,
        models,
        normalize
      })
    } : {
      get body() {
        if (_body)
          return _body;
        return _body = getSchemaValidator(cloned.body, {
          dynamic,
          models,
          normalize
        });
      },
      get headers() {
        if (_headers)
          return _headers;
        return getSchemaValidator(cloned.headers, {
          dynamic,
          models,
          additionalProperties: true
        });
      },
      get params() {
        if (_params)
          return _params;
        return _params = getSchemaValidator(cloned.params, {
          dynamic,
          models
        });
      },
      get query() {
        if (_query)
          return _query;
        return _query = getSchemaValidator(cloned.query, {
          dynamic,
          models
        });
      },
      get cookie() {
        if (_cookie)
          return _cookie;
        return _cookie = cookieValidator();
      },
      get response() {
        if (_response)
          return _response;
        return _response = getResponseSchemaValidator(cloned.response, {
          dynamic,
          models,
          normalize
        });
      }
    };
    const loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
    localHook = mergeHook(localHook, {}, { allowMacro: true });
    if (localHook.tags) {
      if (!localHook.detail)
        localHook.detail = {
          tags: localHook.tags
        };
      else
        localHook.detail.tags = localHook.tags;
    }
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    this.applyMacro(localHook);
    const hooks = mergeHook(this.event, localHook);
    if (this.config.aot === false) {
      this.router.dynamic.add(method, path, {
        validator,
        hooks,
        content: localHook?.type,
        handle
      });
      if (this.config.strictPath === false) {
        this.router.dynamic.add(method, loosePath, {
          validator,
          hooks,
          content: localHook?.type,
          handle
        });
      }
      this.router.history.push({
        method,
        path,
        composed: null,
        handler: handle,
        hooks
      });
      return;
    }
    let composed = undefined;
    const shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true;
    const appInference = cloneInference(this.inference);
    const mainHandler = shouldPrecompile ? composeHandler({
      app: this,
      path,
      method,
      localHook: mergeHook(localHook),
      hooks,
      validator,
      handler: handle,
      allowMeta,
      appInference
    }) : (context) => {
      if (composed)
        return composed(context);
      return (composed = composeHandler({
        app: this,
        path,
        method,
        localHook: mergeHook(localHook),
        hooks,
        validator,
        handler: handle,
        allowMeta,
        appInference
      }))(context);
    };
    if (!shouldPrecompile)
      mainHandler.compose = () => {
        return mainHandler.composed = composeHandler({
          app: this,
          path,
          method,
          localHook: mergeHook(localHook),
          hooks,
          validator,
          handler: handle,
          allowMeta,
          appInference
        });
      };
    let routeIndex = this.router.history.length;
    if (this.routeTree.has(method + path)) {
      routeIndex = this.router.history.findIndex((route) => route.path === path && route.method === method);
      if (routeIndex !== -1) {
        const removed = this.router.history.splice(routeIndex, 1)[0];
        if (removed && this.routeTree.has(removed?.method + removed?.path))
          this.routeTree.delete(removed.method + removed.path);
      }
    }
    this.routeTree.set(method + path, routeIndex);
    this.router.history.push({
      method,
      path,
      composed: mainHandler,
      handler: handle,
      hooks
    });
    const staticRouter = this.router.static.http;
    if (method === "$INTERNALWS") {
      const loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
        const index = staticRouter.handlers.length;
        staticRouter.handlers.push(mainHandler);
        staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
        this.router.static.ws[path] = index;
        if (loose)
          this.router.static.ws[loose] = index;
      } else {
        this.router.ws.add("ws", path, mainHandler);
        if (loose)
          this.router.ws.add("ws", loose, mainHandler);
      }
      return;
    }
    if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
      const index = staticRouter.handlers.length;
      staticRouter.handlers.push(mainHandler);
      staticRouter.variables += shouldPrecompile ? `const st${index} = staticRouter.handlers[${index}]
` : `let st${index} = staticRouter.handlers[${index}]
let stc${index}
`;
      if (!staticRouter.map[path])
        staticRouter.map[path] = {
          code: ""
        };
      if (method === "ALL")
        staticRouter.map[path].all = shouldPrecompile ? `default: return st${index}(ctx)
` : `default: ${jitRoute(index)}
`;
      else
        staticRouter.map[path].code = shouldPrecompile ? `case '${method}': return st${index}(ctx)
${staticRouter.map[path].code}` : `case '${method}': ${jitRoute(index)}
${staticRouter.map[path].code}`;
      if (!this.config.strictPath) {
        if (!staticRouter.map[loosePath])
          staticRouter.map[loosePath] = {
            code: ""
          };
        if (method === "ALL")
          staticRouter.map[loosePath].all = shouldPrecompile ? `default: return st${index}(ctx)
` : `default: ${jitRoute(index)}
`;
        else
          staticRouter.map[loosePath].code = shouldPrecompile ? `case '${method}': return st${index}(ctx)
${staticRouter.map[loosePath].code}` : `case '${method}': ${jitRoute(index)}
${staticRouter.map[loosePath].code}`;
      }
    } else {
      this.router.http.add(method, path, mainHandler);
      if (!this.config.strictPath)
        this.router.http.add(method, path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/", mainHandler);
    }
  }
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    this.setHeaders = mergeDeep(this.setHeaders, header);
    return this;
  }
  onStart(handler) {
    this.on("start", handler);
    return this;
  }
  onRequest(handler) {
    this.on("request", handler);
    return this;
  }
  onParse(options, handler) {
    if (!handler)
      return this.on("parse", options);
    return this.on(options, "parse", handler);
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve) {
      resolve = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "resolve",
      fn: resolve
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper) {
      mapper = optionsOrResolve;
      optionsOrResolve = { as: "local" };
    }
    const hook = {
      subType: "resolve",
      fn: mapper
    };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onResponse(options, handler) {
    if (!handler)
      return this.on("response", options);
    return this.on(options, "response", handler);
  }
  trace(options, handler) {
    if (!handler) {
      handler = options;
      options = { as: "local" };
    }
    if (!Array.isArray(handler))
      handler = [handler];
    for (const fn of handler)
      this.reporter.on("event", createTraceListener(() => this.reporter, this.event.trace.length, fn));
    this.on(options, "trace", handler);
    return this;
  }
  error(name, error23) {
    switch (typeof name) {
      case "string":
        error23.prototype[ERROR_CODE] = name;
        this.definitions.error[name] = error23;
        return this;
      case "function":
        this.definitions.error = name(this.definitions.error);
        return this;
    }
    for (const [code, error32] of Object.entries(name)) {
      error32.prototype[ERROR_CODE] = code;
      this.definitions.error[code] = error32;
    }
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    this.on("stop", handler);
    return this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type74;
    switch (typeof optionsOrType) {
      case "string":
        type74 = optionsOrType;
        handlers = typeOrHandlers;
        break;
      case "object":
        type74 = typeOrHandlers;
        break;
    }
    if (type74 === "response")
      type74 = "onResponse";
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else {
      if (typeof handlers === "function")
        handlers = [
          {
            fn: handlers
          }
        ];
      else
        handlers = [handlers];
    }
    const handles = handlers;
    for (const handle of handles)
      handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
    if (type74 === "trace")
      sucroseTrace(handles.map((x) => x.fn), this.inference.trace);
    else
      sucrose({
        [type74]: handles.map((x) => x.fn)
      }, this.inference.event);
    for (const handle of handles) {
      const fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type74) {
        case "start":
          this.event.start.push(fn);
          break;
        case "request":
          this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform.push(fn);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(fn);
          break;
        case "afterHandle":
          this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse.push(fn);
          break;
        case "onResponse":
          this.event.onResponse.push(fn);
          break;
        case "trace":
          this.event.trace.push(fn);
          break;
        case "error":
          this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  propagate() {
    const promoteEvent = (events) => {
      for (const event of events) {
        if ("scope" in event && event.scope === "local")
          event.scope = "scoped";
      }
    };
    promoteEvent(this.event.parse);
    promoteEvent(this.event.transform);
    promoteEvent(this.event.beforeHandle);
    promoteEvent(this.event.afterHandle);
    promoteEvent(this.event.mapResponse);
    promoteEvent(this.event.onResponse);
    promoteEvent(this.event.trace);
    promoteEvent(this.event.error);
    return this;
  }
  group(prefix, schemaOrRun, run) {
    const instance = new _Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.getServer = () => this.server;
    instance.inference = cloneInference(this.inference);
    instance.extender = { ...this.extender };
    const isSchema = typeof schemaOrRun === "object";
    const sandbox = (isSchema ? run : schemaOrRun)(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      path = (isSchema ? "" : this.config.prefix) + prefix + path;
      if (isSchema) {
        const hook = schemaOrRun;
        const localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || {}
          ] : [
            localHook.error,
            ...sandbox.event.error || {}
          ]
        }));
      } else {
        this.add(method, path, handler, mergeHook(hooks, {
          error: sandbox.event.error
        }), {
          skipPrefix: true
        });
      }
    });
    return this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        this.applyMacro(hook);
        this.event = mergeLifeCycle(this.event, hook);
        this.validator = {
          body: hook.body ?? this.validator?.body,
          headers: hook.headers ?? this.validator?.headers,
          params: hook.params ?? this.validator?.params,
          query: hook.query ?? this.validator?.query,
          response: hook.response ?? this.validator?.response,
          cookie: hook.cookie ?? this.validator?.cookie
        };
        if (hook.detail) {
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        }
        if (hook?.tags) {
          if (!this.config.detail)
            this.config.detail = {
              tags: hook.tags
            };
          else
            this.config.detail.tags = hook.tags;
        }
        return this;
      }
      return this.guard({}, hook);
    }
    const instance = new _Elysia({
      ...this.config,
      prefix: ""
    });
    instance.singleton = { ...this.singleton };
    instance.definitions = { ...this.definitions };
    instance.inference = cloneInference(this.inference);
    instance.extender = { ...this.extender };
    const sandbox = run(instance);
    this.singleton = mergeDeep(this.singleton, instance.singleton);
    this.definitions = mergeDeep(this.definitions, instance.definitions);
    sandbox.getServer = () => this.server;
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, {
        ...localHook || {},
        error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
          ...localHook.error || {},
          ...sandbox.event.error || []
        ] : [
          localHook.error,
          ...sandbox.event.error || []
        ]
      }, {
        allowMacro: true
      }));
    });
    return this;
  }
  use(plugin, options) {
    if (options?.scoped)
      return this.guard({}, (app) => app.use(plugin));
    if (Array.isArray(plugin)) {
      let current = this;
      for (const p of plugin)
        current = this.use(p);
      return current;
    }
    if (plugin instanceof Promise) {
      this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof _Elysia)
          return this._use(plugin2);
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof _Elysia)
          return this._use(plugin2.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((x) => x.compile()));
      return this;
    }
    return this._use(plugin);
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      const instance = plugin(this);
      if (instance instanceof Promise) {
        this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof _Elysia) {
            this.compile();
            for (const {
              method,
              path,
              handler,
              hooks
            } of Object.values(plugin2.router.history)) {
              this.add(method, path, handler, mergeHook(hooks, {
                error: plugin2.event.error
              }));
            }
            return plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile()));
        return this;
      }
      return instance;
    }
    if (plugin.promisedModules.size) {
      this.promisedModules.add(plugin.modules.then(() => this._use(plugin)).then((x) => x.compile()));
      return this;
    }
    const { name, seed } = plugin.config;
    plugin.getServer = () => this.getServer();
    plugin.model(this.definitions.type);
    plugin.error(this.definitions.error);
    const isScoped = plugin.config.scoped;
    if (isScoped) {
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.telemetry.stack,
          routes: plugin.router.history,
          decorators: plugin.singleton.decorator,
          store: plugin.singleton.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({
            fn: x.fn.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({
            fn: x.fn.toString(),
            stack: new Error().stack ?? ""
          }))
        });
      }
      plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      const macroHashes = [];
      for (let i = 0;i < plugin.extender.macros.length; i++) {
        const macro = this.extender.macros[i];
        if (macroHashes.includes(macro.checksum)) {
          plugin.extender.macros.splice(i, 1);
          i--;
        }
        macroHashes.push(macro.checksum);
      }
      plugin.onRequest((context) => {
        Object.assign(context, this.singleton.decorator);
        Object.assign(context.store, this.singleton.store);
      });
      if (plugin.event.trace.length)
        plugin.event.trace.push(...plugin.event.trace);
      if (!plugin.config.prefix)
        console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
      if (plugin.event.error.length)
        plugin.event.error.push(...this.event.error);
      if (plugin.config.aot)
        plugin.compile();
      if (isScoped === true && plugin.config.prefix) {
        this.mount(plugin.config.prefix + "/", plugin.fetch);
        for (const route of plugin.router.history) {
          this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length);
          this.router.history.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
        }
      } else {
        this.mount(plugin.fetch);
        for (const route of plugin.router.history) {
          this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length);
          this.router.history.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
        }
      }
      return this;
    } else {
      this.headers(plugin.setHeaders);
      plugin.reporter = this.reporter;
      for (const trace of plugin.event.trace)
        if (trace.scope && trace.scope !== "local")
          this.trace(trace);
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      } else {
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      }
      const macroHashes = [];
      for (let i = 0;i < this.extender.macros.length; i++) {
        const macro = this.extender.macros[i];
        if (macro.checksum) {
          if (macroHashes.includes(macro.checksum)) {
            this.extender.macros.splice(i, 1);
            i--;
          }
          macroHashes.push(macro.checksum);
        }
      }
      this.inference = {
        event: {
          body: this.inference.event.body || plugin.inference.event.body,
          cookie: this.inference.event.cookie || plugin.inference.event.cookie,
          headers: this.inference.event.headers || plugin.inference.event.headers,
          queries: [
            ...this.inference.event.queries,
            ...plugin.inference.event.queries
          ],
          query: this.inference.event.query || plugin.inference.event.query,
          set: this.inference.event.set || plugin.inference.event.set,
          unknownQueries: this.inference.event.unknownQueries || plugin.inference.event.unknownQueries
        },
        trace: {
          request: this.inference.trace.request || plugin.inference.trace.request,
          parse: this.inference.trace.parse || plugin.inference.trace.parse,
          transform: this.inference.trace.transform || plugin.inference.trace.transform,
          handle: this.inference.trace.handle || plugin.inference.trace.handle,
          beforeHandle: this.inference.trace.beforeHandle || plugin.inference.trace.beforeHandle,
          afterHandle: this.inference.trace.afterHandle || plugin.inference.trace.afterHandle,
          error: this.inference.trace.error || plugin.inference.trace.error,
          context: this.inference.trace.context || plugin.inference.trace.context,
          store: this.inference.trace.store || plugin.inference.trace.store,
          set: this.inference.trace.set || plugin.inference.trace.set
        }
      };
    }
    this.decorate(plugin.singleton.decorator);
    this.state(plugin.singleton.store);
    this.model(plugin.definitions.type);
    this.error(plugin.definitions.error);
    for (const { method, path, handler, hooks } of Object.values(plugin.router.history)) {
      this.add(method, path, handler, mergeHook(hooks, {
        error: plugin.event.error
      }));
    }
    if (!isScoped)
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.telemetry.stack,
          routes: plugin.router.history,
          decorators: plugin.singleton,
          store: plugin.singleton.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x?.subType === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x?.subType === "resolve").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          }))
        });
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
      } else {
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
      }
    return this;
  }
  macro(macro) {
    const hook = {
      checksum: checksum(JSON.stringify({
        name: this.config.name,
        seed: this.config.seed,
        content: macro.toString()
      })),
      fn: macro
    };
    this.extender.macros.push(hook);
    return this;
  }
  mount(path, handle) {
    if (path instanceof _Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      const run = typeof path === "function" ? path : path instanceof _Elysia ? path.compile().fetch : handle instanceof _Elysia ? handle.compile().fetch : handle;
      const handler2 = async ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2 || "/"), request));
      this.all("/*", handler2, {
        type: "none"
      });
      return this;
    }
    const length = path.length;
    if (handle instanceof _Elysia)
      handle = handle.compile().fetch;
    const handler = async ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), request));
    this.all(path, handler, {
      type: "none"
    });
    this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
      type: "none"
    });
    return this;
  }
  get(path, handler, hook) {
    this.add("GET", path, handler, hook);
    return this;
  }
  post(path, handler, hook) {
    this.add("POST", path, handler, hook);
    return this;
  }
  put(path, handler, hook) {
    this.add("PUT", path, handler, hook);
    return this;
  }
  patch(path, handler, hook) {
    this.add("PATCH", path, handler, hook);
    return this;
  }
  delete(path, handler, hook) {
    this.add("DELETE", path, handler, hook);
    return this;
  }
  options(path, handler, hook) {
    this.add("OPTIONS", path, handler, hook);
    return this;
  }
  all(path, handler, hook) {
    this.add("ALL", path, handler, hook);
    return this;
  }
  head(path, handler, hook) {
    this.add("HEAD", path, handler, hook);
    return this;
  }
  connect(path, handler, hook) {
    this.add("CONNECT", path, handler, hook);
    return this;
  }
  route(method, path, handler, hook) {
    this.add(method.toUpperCase(), path, handler, hook, hook?.config);
    return this;
  }
  ws(path, options) {
    const transform7 = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined;
    let server = null;
    const validateMessage = getSchemaValidator(options?.body, {
      models: this.definitions.type,
      normalize: this.config.normalize
    });
    const validateResponse = getSchemaValidator(options?.response, {
      models: this.definitions.type,
      normalize: this.config.normalize
    });
    const parseMessage = (message) => {
      if (typeof message === "string") {
        const start = message?.charCodeAt(0);
        if (start === 47 || start === 123)
          try {
            message = JSON.parse(message);
          } catch {
          }
        else if (isNumericString(message))
          message = +message;
      }
      if (transform7?.length)
        for (let i = 0;i < transform7.length; i++) {
          const temp = transform7[i](message);
          if (temp !== undefined)
            message = temp;
        }
      return message;
    };
    this.route("$INTERNALWS", path, (context) => {
      const { set: set2, path: path2, qi, headers, query, params } = context;
      if (server === null)
        server = this.getServer();
      if (server?.upgrade(context.request, {
        headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
        data: {
          validator: validateResponse,
          open(ws) {
            options.open?.(new ElysiaWS(ws, context));
          },
          message: (ws, msg) => {
            const message = parseMessage(msg);
            if (validateMessage?.Check(message) === false)
              return void ws.send(new ValidationError("message", validateMessage, message).message);
            options.message?.(new ElysiaWS(ws, context), message);
          },
          drain(ws) {
            options.drain?.(new ElysiaWS(ws, context));
          },
          close(ws, code, reason) {
            options.close?.(new ElysiaWS(ws, context), code, reason);
          }
        }
      }))
        return;
      set2.status = 400;
      return "Expected a websocket connection";
    }, {
      beforeHandle: options.beforeHandle,
      transform: options.transform,
      headers: options.headers,
      params: options.params,
      query: options.query
    });
    return this;
  }
  state(name, value15) {
    switch (typeof name) {
      case "object":
        this.singleton.store = mergeDeep(this.singleton.store, name);
        return this;
      case "function":
        this.singleton.store = name(this.singleton.store);
        return this;
    }
    if (!(name in this.singleton.store)) {
      this.singleton.store[name] = value15;
    }
    return this;
  }
  decorate(name, value15) {
    switch (typeof name) {
      case "object":
        this.singleton.decorator = mergeDeep(this.singleton.decorator, name);
        return this;
      case "function":
        this.singleton.decorator = name(this.singleton.decorator);
        return this;
    }
    if (!(name in this.singleton.decorator))
      this.singleton.decorator[name] = value15;
    return this;
  }
  derive(optionsOrTransform, transform7) {
    if (!transform7) {
      transform7 = optionsOrTransform;
      optionsOrTransform = { as: "local" };
    }
    const hook = {
      subType: "derive",
      fn: transform7
    };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        Object.entries(name).forEach(([key, value15]) => {
          if (!(key in this.definitions.type))
            this.definitions.type[key] = value15;
        });
        return this;
      case "function":
        this.definitions.type = name(this.definitions.type);
        return this;
    }
    this.definitions.type[name] = model;
    return this;
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper) {
      mapper = optionsOrDerive;
      optionsOrDerive = { as: "local" };
    }
    const hook = {
      subType: "derive",
      fn: mapper
    };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type74, word) {
    if (word === "")
      return this;
    const delimieter = ["_", "-", " "];
    const capitalize2 = (word2) => word2[0].toUpperCase() + word2.slice(1);
    const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize2(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize2(suffix);
    const remap = (type210) => {
      const store = {};
      switch (type210) {
        case "decorator":
          for (const key in this.singleton.decorator) {
            store[joinKey(word, key)] = this.singleton.decorator[key];
          }
          this.singleton.decorator = store;
          break;
        case "state":
          for (const key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (const key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (const key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    };
    const types = Array.isArray(type74) ? type74 : [type74];
    for (const type210 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type210);
    return this;
  }
  prefix(type74, word) {
    return this.affix("prefix", type74, word);
  }
  suffix(type74, word) {
    return this.affix("suffix", type74, word);
  }
  compile() {
    this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this);
    if (typeof this.server?.reload === "function")
      this.server.reload({
        ...this.server || {},
        fetch: this.fetch
      });
    return this;
  }
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
};

// src/index.ts
var html = __toESM(require_cjs2(), 1);
var import_validator = __toESM(require_validator(), 1);
import {readFile} from "node:fs/promises";
import {join} from "node:path";

// src/common/constants.ts
var message_prompt = `I'll be giving you ingredient names and you'll be responding with recipes containing either some of the recipes or all of the ingredients. I want you to respond with json compliant text using the following format:

{
    "title": place recipe title here,
    "description": short description of meal,
    "serves": how many people this meal serves,
    "prep_time": time to prep ingredients,
    "cook_time": time to cook ingredients,
    "difficulty": difficulty to cook this meal, use options "Easy", "Medium", "Hard",
    "ingredients": an array of tuples, with the first value of each tuple being the amount and the second being the ingredient name,
    "prep_instructions": an array of string with preparation instructions
    "instructions": an array of strings with instructions
    "link": a link to a recipe
}

If the user only gives one ingredient then either find the simplest recipe and use JSON format above with the ingredient listed in the ingredients list or just reply with the simplest way to cook said ingredients whilst using the above json format

If user doesn't ask for a recipe, doesn't give you an ingredient to come up with a recipe, or you can't give instructions on how to cook ingredients alone, then ask them politely to try searching for a recipe instead and use the json structure:
    
{ "error": true, "message": place your message here } If only an ingredient is given and user doesn't ask for use in other recipes, return only the title, description, and simple instructions on how to cook the ingredient alone
`;
var visual_message_prompt = `you are an assistant that only replies with JSON compliant text. Use the following format:

[ <place list of items seen here> ]

Now, give me a list of the items you can see in the picture attached

If you cannot find any items then don't place anything in the list`;

// src/controllers/GeminiController.ts
var { GoogleGenerativeAI } = require_dist();

class GeminiControllerSingleton {
  gemini;
  textModel;
  visionModel;
  constructor() {
    this.gemini = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
    this.textModel = this.gemini.getGenerativeModel({
      model: "gemini-1.5-pro-latest",
      generationConfig: {
        temperature: 0
      }
    });
    this.visionModel = this.gemini.getGenerativeModel({
      model: "gemini-pro-vision",
      generationConfig: {
        temperature: 0
      }
    });
  }
  async get_recipe(prompt) {
    const result = await this.textModel.generateContent([
      message_prompt,
      `Here's a list of items, using only items that can be ingredients in a recipe, give me a recipe that can have most or all of the ingredients in this list: ${prompt}`
    ]);
    const response = await result.response;
    console.log("res text:", response.text());
    return response.text().replaceAll("```json", "").replace("```", "").trim();
  }
  async get_recipe_from_image({ data, type: mimeType }) {
    try {
      const prompt_data = {
        inlineData: {
          data,
          mimeType
        }
      };
      console.log("visual prompt starting");
      const visual_result = await this.visionModel.generateContent([
        visual_message_prompt,
        prompt_data
      ]);
      const visual_response = await visual_result.response;
      const response_text = visual_response.text().replaceAll("```json", "").replace("```", "").trim();
      console.log("visual:", response_text);
      if (response_text) {
        const response_json = JSON.parse(response_text);
        if (response_json?.length) {
          return this.get_recipe(response_text);
        } else {
          return JSON.stringify({ error: true, message: "I can't see any ingredients, please try again." });
        }
      }
    } catch (err) {
    }
  }
}
var GeminiController = new GeminiControllerSingleton;

// src/services/get_recipe.ts
var get_recipe = async (prompt) => {
  return await GeminiController.get_recipe(prompt);
};
var get_recipe_image_prompt = async (image) => {
  return await GeminiController.get_recipe_from_image(image);
};

// src/index.ts
var PORT = process.env.PORT || 9000;
var app = new Elysia().use(html.html()).get("/", async (resp) => {
  console.log("A user has arrived!!", Date.now());
  return (await readFile(join(import.meta.dir, "views/index.html"))).toString();
}).post("/prompt", (resp) => {
  const prompt_payload = JSON.parse(resp.body);
  const msg = import_validator.default.escape(prompt_payload.msg || "");
  if (prompt_payload.img) {
    return get_recipe_image_prompt(prompt_payload.img);
  }
  return get_recipe(msg);
}).listen(PORT);
console.log(`\uD83E\uDD8A Elysia is running at ${app.server?.hostname}:${app.server?.port}`);
